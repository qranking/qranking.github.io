<html>
	<head><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110075493-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110075493-1');
</script>
<!-- Google AdSense -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6168511236629369",
    enable_page_level_ads: true
  });
</script>

		<meta charset="UTF-8" />
		<title>Qiita Ranking (b4b4r07)</title>
		<link rel="stylesheet" type="text/css" href="../qranking.css">
	</head>
	<body>
<div class="headerContainer">
<h1>Qiitaいいね数ランキング (b4b4r07 さんの投稿分)</h1>
</div><!--class="headerContainer"-->
<p><i><img width="16" height="16" src="../thumb-up-120px.png" /></i>が同じ値の場合は投稿日時の新しいものが上位としています。</p>
<p><i><img width="16" height="16" src="../thumb-up-120px.png" /></i>がついていない記事は表示していません。</p>
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />1位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>1179</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/9ea50f9ff94973c99ebe">シェルスクリプトを書くときに気をつける9箇条</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-24 20:46:14</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>最新の類似投稿として<a href="http://qiita.com/b4b4r07/items/62d56b7de2b9d6844bb5" id="reference-6d4043b2b760410ce98c">シェルスクリプトのコーディングルール2014</a>も併せてどうぞ。<br>
<strong>2014/10/09追記</strong></p>

<p>ぼくがシェルスクリプトを書くときに気にしていること、過去の失敗で書き留めたことを忘れないために。</p>

<h1>
<span id="1-グローバル変数は大文字" class="fragment"></span><a href="#1-%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%81%AF%E5%A4%A7%E6%96%87%E5%AD%97"><i class="fa fa-link"></i></a>1. グローバル変数は大文字</h1>

<p><code>PATH</code> や <code>HOME</code> など、環境変数が大文字なので、エクスポートする変数を大文字で書くという習慣は一般的であるような気がしますが、エクスポートする変数を抱えるシェルスクリプトを作成する機会が稀なので。</p>

<ul>
<li>グローバル変数は大文字</li>
<li>ローカル変数は小文字</li>
<li>エクスポートする変数も大文字</li>
</ul>

<p>関数内からグローバル変数にアクセスする場合がありますが、やはり区別していると、可読性が増すような気がするのでお勧めです。</p>

<h1>
<span id="2-awk-を知る" class="fragment"></span><a href="#2-awk-%E3%82%92%E7%9F%A5%E3%82%8B"><i class="fa fa-link"></i></a>2. awk を知る</h1>

<p>Unix 上にて文書処理をするときに、数多くのフィルタコマンド（grep、cut、tr、head、sort、uniq、sed、awk、wc、paste）を駆使して加工してゆくと思いますが、awk オンリーで解決できる場合が多かったりします。</p>

<p>例として家計簿を記した csv ファイルをあげます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">sh</span></div>
<div class="highlight"><pre><span></span>b4b4r07:~$ cat test.csv 
日付,カテゴリ,金額,備考
<span class="m">09</span>/25,仕送り,+25000,
<span class="m">10</span>/01,食費,-1253,
<span class="m">10</span>/02,医療,-1200,皮膚科
<span class="m">10</span>/02,医療,-760,薬局の処方薬
<span class="m">10</span>/02,PC用品,-3180,外付けCDドライブ
<span class="m">10</span>/03,食費,-379,
<span class="m">10</span>/03,食費,-398,
<span class="m">10</span>/03,美容室,3150,
<span class="m">10</span>/04,食費,-580,
<span class="m">10</span>/05,食費,-667,
<span class="m">10</span>/06,食費,-420,
b4b4r07:~$ <span class="nb">declare</span> -i <span class="nv">sum</span><span class="o">=</span><span class="m">0</span><span class="p">;</span> <span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> <span class="sb">`</span>grep <span class="s2">"食費"</span> test.csv <span class="p">|</span> wc -l<span class="sb">`</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nv">sum</span><span class="o">+=</span><span class="sb">`</span>grep <span class="s2">"食費"</span> test.csv <span class="p">|</span> cut -d, -f3 <span class="p">|</span> head -<span class="nv">$i</span> <span class="p">|</span> tail -1<span class="sb">`</span><span class="p">;</span> <span class="k">done</span>
b4b4r07:~$ <span class="nb">echo</span> <span class="nv">$sum</span>
-3697
b4b4r07:~$ 
</pre></div>
</div>

<p>家計簿から食費だけを算出しようとしたとき、フィルタコマンドの組み合わせでやろうとすると、結構複雑に書かなければなりません。しかし awk を知ると</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>b4b4r07:~$ awk -F, '$2=="食費"{ sum += $3 }; END{ print sum }' test.csv 
-3697
</pre></div></div>

<p>と書けてしまいます。収支の算出も簡単です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>b4b4r07:~$ awk -F, '$3 ~ /\+/{p += $3}; $3 ~ /^\-/{m += $3}; END{print "[income]",p, "[used]",m, "[rest]",p+m}' test.csv
[income] 25000 [used] -8837 [rest] 16163
</pre></div></div>

<p>スマートに書くことが出来ます。awk や sed はフィルタコマンドの域を超えた小さなプログラミング言語と称されることが多いです。そのくらいに多くのことができるので、知っておくまたは使いこなせるようになるとできることの幅がグッと広がります。</p>

<h1>
<span id="3-bash-に依存しているのに-binsh-と書かない" class="fragment"></span><a href="#3-bash-%E3%81%AB%E4%BE%9D%E5%AD%98%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%AB-binsh-%E3%81%A8%E6%9B%B8%E3%81%8B%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>3. bash に依存しているのに #!/bin/sh と書かない</h1>

<p>普段シェバンとしてシェルスクリプトの冒頭に書くアレですが、<code>#!/bin/sh</code> の実態は環境によってまちまちです。さまざまなシェルのシンボリックリンクになっていることが多いです（Ubuntu では ash 亜種の dash となっている模様）。なので、予期せぬエラーや動作しないといったことが起きる場合があります。bash やその他シェルに依存したスクリプトを書くのなら、それ上での動作を予定しているわけだから、シェバンには <code>#!/bin/bash</code> と書いたほうが良い。</p>

<h1>
<span id="4-改行コードに気をつける" class="fragment"></span><a href="#4-%E6%94%B9%E8%A1%8C%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AB%E6%B0%97%E3%82%92%E3%81%A4%E3%81%91%E3%82%8B"><i class="fa fa-link"></i></a>4. 改行コードに気をつける</h1>

<p>改行コードについては<a href="http://ja.wikipedia.org/wiki/%E6%94%B9%E8%A1%8C%E3%82%B3%E3%83%BC%E3%83%89" rel="nofollow noopener" target="_blank">Wikipedia: 改行コード</a>を参照してください。歴史的背景やその実践について書かれています。<br>
簡単に書き表すと以下のようになります。Mac OS とはバージョン9までを指します。今はなかなかお目にかからないので、その心配は大丈夫かと思います。</p>

<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: center">Windows</th>
<th style="text-align: center">Mac OS</th>
<th style="text-align: center">Unix (OS X含む)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">改行コード</td>
<td style="text-align: center">CR+LF</td>
<td style="text-align: center">CR（復帰）</td>
<td style="text-align: center">LF（改行）</td>
</tr>
</tbody>
</table>

<p>Windows で作成したスクリプトを Unix 環境で実行すると <code>command not found</code> や <code>No such file or directory</code> など予期せぬエラーが出る場合があります。これらの大抵の原因は改行コードによるものです。Windows 側で指定しなければデフォルトでは <code>CR+LF</code> で保存されます。狭義での"改行"とは Unix でも標準である <code>LF</code> のみです。<br>
ゆえに Windows での <code>#!/bin/bash&lt;CR&gt;&lt;LF&gt;</code> は <code>#!/bin/bash</code> ですが、Unix などでは <code>#!/bin/bash&lt;CR&gt;</code> となるのです。つまり、改行判断の際に余った <code>CR</code> をコマンドの一部として解釈しようとするため、エラーが出るのです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ cat test.sh
#!/bin/bash
cat myfile

$ ./test.sh
cat: file\r: No such file or directory
</pre></div></div>

<p>一見、問題のないようなスクリプトですが実行してみると、エラーが吐かれてしまいます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ cat -A test.sh
#!/bin/bash^M$
cat file^M$
</pre></div></div>

<p><code>cat -A</code> で確認してみると <code>CR</code> を表す <code>^M</code> が可視化されています。ちなみに"改行"は <code>$</code> です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ tr -d '\r' test.sh
</pre></div></div>

<p>で、削除できるので、ようやく解決です。</p>

<p>ちなみに、BSD 版の <code>cat</code> には <code>-A</code> オプションはありません。GNU 版オンリーです。BSD 版では <code>cat -e</code> で同様のことが出来ます。 </p>

<blockquote>
<p>\r　＝　CR 復帰 キャリッジリターン ^M<br><br>
\n　＝　LF 改行 ラインフィード ^J</p>
</blockquote>

<h1>
<span id="5-サブシェルを意識する" class="fragment"></span><a href="#5-%E3%82%B5%E3%83%96%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%92%E6%84%8F%E8%AD%98%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>5. サブシェルを意識する</h1>

<p>意識するという表現は、嵌ってしまいやすいが、逆に利用してやるとスマートな記述が可能になるという意味です。</p>

<h2>
<span id="嵌りやすい場合" class="fragment"></span><a href="#%E5%B5%8C%E3%82%8A%E3%82%84%E3%81%99%E3%81%84%E5%A0%B4%E5%90%88"><i class="fa fa-link"></i></a>嵌りやすい場合</h2>

<p><strong>(1) while ループで変数が変更されない</strong></p>

<p>ファイルからデータを読みこませる方法として <code>while</code> と <code>read</code> を組み合わせることはよくあります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>while read LINE
do
    ……
    ……
done &lt; file
</pre></div></div>

<p>注意するのはこの <code>while</code> ループはサブシェルで動作しているということです。このとき、<code>while</code> の入力をファイルからリダイレクトしているためです。<br>
ループで利用した変数はループの外では無価値です。いくらループの中で何かに値を入れたりデータを編集しても、ループの外ではその結果を利用できません。<br><br>
これを解決するには、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>exec &lt; file
while read LINE
do
    ……
    ……
done
</pre></div></div>

<p>として、<code>exec</code> コマンドにリダイレクトし、カレントシェルとしてやらなくてはいけません。</p>

<p><strong>(2) while ループで変数が変更されない・2</strong></p>

<p>上の例で紹介した <code>while</code> は少し前の時代の <code>while</code> です。今使用されている多くのシェルではこの仕様（バグ？）は修正されて「変数が変更されない」ということはなくなったようです。しかし、後述する汎用性を高めるという点で、(1) の方法が一番無難でしょう。</p>

<p><strong>(3) パイプ先はサブシェル</strong></p>

<p><code>find</code> したファイルを <code>files</code> という配列に代入したいとします。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>files=()
find . -type f | while read f; do
    files+=("$f")
done
echo "${files[@]}"
</pre></div></div>

<p>しかし、この結果で <code>echo</code> は何も出力しません。パイプの先はサブシェルで動作します。そもそもパイプとは標準出力をそのまま別のプロセスの標準入力に渡す仕込みのことです。「|」で多段に接続された各々のコマンドは別プロセスとして動きますので、そのいずれのプロセスも親である shell に変数を渡すことは出来ません。<br>
パイプの場合、前段の実行が完了しなくても後段の実行が始まります。<br>
　これは個々のプロセスが親である shell とは独立して動いていることを意味しますので、その <code>while</code> は sub shell と呼ばれる子プロセスによって実行されている訳です。<br>
　shell 変数は一つのプロセス内でしか共有出来ませんから、その内容を他のプロセスから見ることは不可能です。</p>

<p>これを解決するには以下のようにするのが良いでしょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>files=()
while read f; do
    files+=("$f")
done &lt; &lt;(find . -type f)
echo "${files[@]}"
</pre></div></div>

<p><code>diff</code> のときによくやるあれです。プロセス置換と呼ばれています。この機能を使用しないで期待通りの結果を導きたい場合は、いったん外部ファイル（tmpfile のような）に出力して、それを入力としてやるくらいしかありません。しかしそれだと、外部ファイルの後始末の処理を組み込まないといけないので、すこし面倒だし、美しくないでしょう。</p>

<h2>
<span id="利用してやる場合" class="fragment"></span><a href="#%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%82%84%E3%82%8B%E5%A0%B4%E5%90%88"><i class="fa fa-link"></i></a>利用してやる場合</h2>

<p>サブシェルでの変数の変更などは、カレントシェルに影響しません。これを巧みに使用すると <code>IFS</code> をサブシェルに閉じ込めることで、変更による影響をなくすことができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>(IFS=$'\n'; echo "${array[*]}")
</pre></div></div>

<p><code>cd</code> なども同じです。サブシェルでの移動は影響しないです。カレントディレクトリを一時的に変更して、すぐに戻りたい場合なんかに利用するといいでしょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>( cd ~/src &amp;&amp; tar cf - myproject ) | gzip -c &gt; myproject.tar.gz
</pre></div></div>

<p>ファイルの上書きでもスマートな記述が可能になります。通常、ファイルを上書きしようとすると、空ファイルになってしまいます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">sh</span></div>
<div class="highlight"><pre><span></span>b4b4r07:~$ cat file 
apple
orange
grape
banana
strawberry
cherry
pear
pineapple
mandarin
tangerine
melon
b4b4r07:~$ grep -v <span class="s2">"e</span>$<span class="s2">"</span> file &gt;file <span class="c1">#フィルタリングして上書き</span>
b4b4r07:~$ cat file <span class="c1">#何も出力されない（空）</span>
b4b4r07:~$ 
</pre></div>
</div>

<p>コマンドオプションなどの標準で上書きできるのは、<code>sort</code> や <code>sed</code> くらいしかありません。自前で上書きするには、いっかい一時ファイルに書き出して、リネームしなければなりません。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ grep -v "e$" file &gt;file.tmp
$ mv -f file.tmp file
</pre></div></div>

<p>しかし、サブシェルを利用することで簡単に記述できます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">sh</span></div>
<div class="highlight"><pre><span></span>b4b4r07:~$ <span class="o">(</span>rm file<span class="p">;</span> grep <span class="s2">"e</span>$<span class="s2">"</span> &gt;file<span class="o">)</span> &lt;file
b4b4r07:~$ cat file 
apple
orange
grape
pineapple
tangerine
b4b4r07:~$
</pre></div>
</div>

<p>しかし、<code>rm</code> を最初に行う関係上危険性が生じます。<code>rm</code> ゴミ箱スクリプトのエイリアスや関数を使用されることをおすすめします。</p>

<h1>
<span id="6-汎用性を高める" class="fragment"></span><a href="#6-%E6%B1%8E%E7%94%A8%E6%80%A7%E3%82%92%E9%AB%98%E3%82%81%E3%82%8B"><i class="fa fa-link"></i></a>6. 汎用性を高める</h1>

<p>シェルスクリプトは、Unix 系 OS のユーザにとって最も身近なプログラミング言語でもあり、その習得は必須の技能であると言えます。ほとんど改変を加えずに、様々なシステムでそのまま利用できるという汎用性の高さは非常に優れたものです。<br><br>
シェルスクリプトの使用は以下の様な利益をもたらします。</p>

<ul>
<li>システムの標準の機能</li>
</ul>

<p>組み込み機器の問題などの様々な制約で、<code>perl</code> や <code>ruby</code> が利用できない場合においても Bourne Shell は使用可能なので頼もしいです。</p>

<ul>
<li>互換性が非常に高い</li>
</ul>

<p>OS の種類やバージョンに依らず利用できるということは、システム間の互換性が非常に高いということです。シェルごとの若干の方言や、インストールされている外部コマンドの違いにさえ注意すれば、同じスクリプトを使いまわすことができます。移植の際の再コンパイル作業等も必要ありません。</p>

<p>などなど、数多くのメリットが有ります。しかし、Unix 系に関して些細な方言が存在するのを頭の隅にでもいれておかなければならない状況が来ると思います。「汎用性を高める」とは要するに、どのシステムにも含まれており、処理が異ならないコマンドだけを使っていれば、一番汎用性が高いことになります。つまり <code>/bin/sh</code> でシェルスクリプトを書くということです。しかしながら、そういうコマンドばかり使っているわけにもいかない（たとえば、<code>echo</code> コマンド。System V 系と BSD 系では動作が異なる）ので、その対処法についてなのですが、これに関しては記述量が多いため、別記事にしたいと思います。</p>

<h1>
<span id="7-例外に関する対応" class="fragment"></span><a href="#7-%E4%BE%8B%E5%A4%96%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E5%AF%BE%E5%BF%9C"><i class="fa fa-link"></i></a>7. 例外に関する対応</h1>

<p><code>$?</code> によって条件分岐したり、<code>&amp;&amp;</code> や <code>||</code> を利用しましょう。また、直前のコマンドにパイプが含まれる場合は、一番最後のコマンドの終了結果しか見てくれないので、<code>$?</code> を使う際は最初のコマンドのみをまず捕捉するか、bash などの限定表現にはなりますが、<code>${PIPESTATUS[@]}</code>を使いましょう。</p>

<h1>
<span id="8--を書き示す" class="fragment"></span><a href="#8--%E3%82%92%E6%9B%B8%E3%81%8D%E7%A4%BA%E3%81%99"><i class="fa fa-link"></i></a>8. <em>@(#)</em> を書き示す</h1>

<p>シェルスクリプトの冒頭に、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># @(#) This script is ~.
</pre></div></div>

<p>といった記述がありますが、これは <code>what</code> コマンドで使用するためです。<br><br>
<code>what</code> コマンドとはプログラムやそれを構成するモジュールのバージョンを調べるときに使用します。シェルスクリプトの場合もこれを書くことで対応させることができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ what mycmd
mycmd
        This script is ~.
</pre></div></div>

<h1>
<span id="9-環境変数-path-を管理する" class="fragment"></span><a href="#9-%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0-path-%E3%82%92%E7%AE%A1%E7%90%86%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>9. 環境変数 PATH を管理する</h1>

<p><code>PATH</code> 変数に .（ドット）を含ませることの危険性についてです。セキュリティ意識を高めるためにも重要な項目です。</p>

<p>シェルスクリプトやプログラムを新規に作ったとき、当然ためしに実行させてみるものです。<code>abc</code> というコマンドを作ったとして、それをそのディレクトリで <code>abc</code> とタイプしても <code>not found</code> と言われてしまうことがあります。それは <code>PATH</code> 変数に .（ドット）が含まれていないからです。ドットはカレントディレクトリを指すので、<code>PATH</code> にこれがセットされていない場合は、現在のディレクトリにある <code>abc</code> というコマンドを探してはくれません。よってテスト実行するときには、<code>./abc</code> というように「このディレクトリの」の部分を明示しなくてはなりません。<br><br>
これを避けるために、<code>PATH</code> にドットを含めている人も少なからずいます。確かにこれがあるとないとでは使い勝手がずいぶん違うため、ある方がよっぽど快適に作業を行えます。<br><br>
しかし、ドットを <code>PATH</code> に入れておくことは非常に危険なことであるということも認識しておいてください。<code>ls</code> というコマンドは非常に頻繁に利用されるかと思います。誰か悪意を持った人が、誰かのディレクトリの下に <code>ls</code> というシェルスクリプトを置いたとします。そのシェルスクリプトの内容が「<code>rm -rf *</code>」というものであったらどうなるでしょうか。その人は気づかないままリストを表示しようとして <code>ls</code> とタイプし、全部ファイルを消してしまうことにもなりかねません。<br><br>
<code>PATH</code> の先頭にドットを置くからこのようなことが起こり得るのであって、<code>PATH</code> の一番最後に置けば問題ないと考えられるかもしれませんが、結局は同じです。<code>ls</code> については、これで問題回避できるかもしれませんが、<code>l</code> というファイルを作って、あなたがタイプミスするのを待っているのかもしれないのです。<br><br>
自分のデータは自分で守る、ということをきちんとやらなくてはならない場合、「<code>PATH</code> 変数にドットを入れない」ことをまず最初に考慮します。</p>

<p>また、シェルスクリプトの中で <code>PATH</code> に相対パスを追加してはいけません。ディレクトリが変わったら相対パスも変わってくるので、<code>PATH</code> の中に不要なディレクトリのリストが含まれてしまうだけです。</p>

<h2>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h2>

<ul>
<li>可読性（保守性）</li>
<li>汎用性（移植性）</li>
</ul>

<p>この2点を意識するというのに尽きるかもしれません。可読性が増せば、コード自体が美しくなるし、保守もしやすくなります（シェルスクリプト自体の可読性が良くないというツッコミはなしで）。汎用性が高いコードを書けば、もちろん移植のしやすさに直結するでしょう。Unix の精神にも徹することができるわけです。9項目にはランク・インしていませんが、「``」の使用なんかも可読性の問題です。ダブルクオートや括弧が入り混じる中にバッククォートなんか使っていては目が大変です。「$()」を使用すると、スッキリ見やすいでしょう（でもこの書き方は一部では利用できないようなので、汎用性という点で少し劣りますね）。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />2位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>1093</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/6efebc2f3d1cbbd393fc">パッケージ管理システム Homebrew </a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-10-01 02:04:33</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[Mac]</b> <b>[MacOSX]</b> <b>[homebrew]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p><a href="https://camo.qiitausercontent.com/def97430c9686e139225301b7435d19a881affa6/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f37363661656364362d616363662d666364632d653262642d3339636434633138636532622e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/def97430c9686e139225301b7435d19a881affa6/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f37363661656364362d616363662d666364632d653262642d3339636434633138636532622e706e67" alt="home-brew.png" title="home-brew.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/766aecd6-accf-fcdc-e2bd-39cd4c18ce2b.png"></a></p>

<p><a href="http://brew.sh/" rel="nofollow noopener" target="_blank">Homebrew</a>（ホームブルー）とは、Mac OS X オペレーティングシステム上でソフトウェアの導入を単純化するパッケージ管理システムのひとつです。<code>yum</code> や <code>apt-get</code> の類の一つです。</p>

<h1>
<span id="macports-との違い" class="fragment"></span><a href="#macports-%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84"><i class="fa fa-link"></i></a>MacPorts との違い</h1>

<p>Mac OS X には Homebrew と双璧をなすパッケージ管理システムがあります。<br>
MacPorts です。以下に簡単な比較を載せておきます。</p>

<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center"><strong>Homebrew</strong></th>
<th style="text-align: center"><strong>MacPorts</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">既存のソフトウェアへの影響</td>
<td style="text-align: center">なるべく既存を利用</td>
<td style="text-align: center">新しくインストールする</td>
</tr>
<tr>
<td style="text-align: center">インストール可能なユーザ</td>
<td style="text-align: center">一般ユーザ</td>
<td style="text-align: center">スーパーユーザ（管理者権限 sudo が必要）</td>
</tr>
<tr>
<td style="text-align: center">パッケージのインストール先</td>
<td style="text-align: center">/usr/local</td>
<td style="text-align: center">/opt/local</td>
</tr>
<tr>
<td style="text-align: center">扱えるパッケージ数</td>
<td style="text-align: center">少ない</td>
<td style="text-align: center">多い</td>
</tr>
<tr>
<td style="text-align: center">インストールにかかる時間</td>
<td style="text-align: center">少ない</td>
<td style="text-align: center">多い</td>
</tr>
<tr>
<td style="text-align: center">システムへの依存度</td>
<td style="text-align: center">大きい</td>
<td style="text-align: center">小さい</td>
</tr>
</tbody>
</table>

<p>MacPorts と比べて Homebrew は依存関係でインストールされるソフトが少ないためか、パッケージ管理システムとしての人気が高まってきています。<br>
MacPorts は、Mac に最初から入っているソフトウェアを無視してパッケージが依存するソフトを新規でインストールするという性質を持っていますが、Homebrew は極力 Mac に入っているものを使うように作られています。ゆえに、パッケージ導入時のシステムへの負担や、インストールにかかる時間が比較的少なくて済むようです。<br>
また、Homebrew はスーパーユーザでコマンドを実行する必要が無く、一般ユーザー権限で使うことが出来ます。</p>

<p>※【2015/07/07 追記】最近では Homebrew が大きく台頭してきて、MacPorts の名前を見ることは減ってきました</p>

<h1>
<span id="homebrew-について" class="fragment"></span><a href="#homebrew-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6"><i class="fa fa-link"></i></a>Homebrew について</h1>

<p>Homebrew は「ユーザが自らパッケージをビルドして使用する」ことのメタファーで「ビールを自家醸造して保存する・飲む」ことを意味しています。そのため、独特なキーワードを用いるので下記で表にしておきます。</p>

<table>
<thead>
<tr>
<th style="text-align: center">キーワード</th>
<th style="text-align: center">本来の意味</th>
<th style="text-align: center">たとえ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center"><strong>Brew</strong></td>
<td style="text-align: center">ビールを醸造する</td>
<td style="text-align: center">make する</td>
</tr>
<tr>
<td style="text-align: center"><strong>Homebrew</strong></td>
<td style="text-align: center">自家醸造</td>
<td style="text-align: center">ユーザ自らがビルドする</td>
</tr>
<tr>
<td style="text-align: center"><strong>Cellar</strong></td>
<td style="text-align: center">セラー（ワインセラーのなどのセラー。ビール貯蔵庫）</td>
<td style="text-align: center">インストール（保存）先</td>
</tr>
<tr>
<td style="text-align: center"><strong>Keg</strong></td>
<td style="text-align: center">樽、醸成用</td>
<td style="text-align: center">make 材料</td>
</tr>
<tr>
<td style="text-align: center"><strong>Formula</strong></td>
<td style="text-align: center">調理法、手順</td>
<td style="text-align: center">ビルド方法・手順が書かれたスクリプト</td>
</tr>
</tbody>
</table>

<p>Homebrew 用のサブコマンドを叩いたり、エラー処理しているときなど、様々な局面で上記のようなキーワードを目にすることになると思うので覚えておくといいかもしれません。</p>

<h1>
<span id="homebrew-をインストールする" class="fragment"></span><a href="#homebrew-%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>Homebrew をインストールする</h1>

<p>何個かステップを経るため、先に手順だけ書いておきます。</p>

<ol>
<li>Java をインストールする</li>
<li>Command Line Tools のインストール</li>
<li>Homebrew 本体のインストール</li>
</ol>

<h2>
<span id="1-java-をインストールする" class="fragment"></span><a href="#1-java-%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>1. Java をインストールする</h2>

<p>OSX は Java を必要とするような動作をした時、OS 側から 「Java の未インストールの情報」と「インストールするかどうかの選択肢」を与えてくれます。<br>
下記のコマンドを <strong>ターミナル（Terminal.app）</strong> から実行することで、Java がインストールされていればバージョンを表示、されていなければインストールするか聞いてきてくれます。</p>

<p><strong>インストール済み</strong></p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="gp">$</span> java -version
<span class="go">java version "1.6.0_51"</span>
<span class="go">Java(TM) SE Runtime Environment (build 1.6.0_51-b11-457-11M4509)</span>
<span class="go">Java HotSpot(TM) 64-Bit Server VM (build 20.51-b01-457, mixed mode)</span>
</pre></div></div>

<p><strong>未インストール</strong></p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="gp">$</span> java -version
<span class="go">No Java runtime present, requesting install.</span>
</pre></div></div>

<p><a href="https://camo.qiitausercontent.com/5807733ba74a5d0839f308b1046cd3cdc2ff8a27/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f62656263343032382d353931392d336438352d373134342d3034326537383434383336622e6a706567" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/5807733ba74a5d0839f308b1046cd3cdc2ff8a27/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f62656263343032382d353931392d336438352d373134342d3034326537383434383336622e6a706567" alt="java.jpg" title="java.jpg" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/bebc4028-5919-3d85-7144-042e7844836b.jpeg"></a></p>

<h2>
<span id="2-command-line-tools-のインストール" class="fragment"></span><a href="#2-command-line-tools-%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB"><i class="fa fa-link"></i></a>2. Command Line Tools のインストール</h2>

<p>このインストール方法は2通りあります。<br>
ちなみに、Command Line Tools をインストールすることで、<code>gcc</code> といったコマンドも使用することができるようになります。</p>

<ul>
<li>
<strong>2.1.</strong> Xcode を利用する</li>
</ul>

<p>App Store にて <a href="https://itunes.apple.com/jp/app/xcode/id497799835?mt=12" rel="nofollow noopener" target="_blank">Xcode</a>をダウンロードすることが出来ます。インストールが完了したら、ターミナルから</p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="gp">$</span> xcode-select --install
</pre></div></div>

<ul>
<li>
<strong>2.2.</strong> Developer を利用する</li>
</ul>

<p>Xcode をインストールしたくない人、出来ない人などはこの方法がおすすめです。しかし、Apple ID などが必要になるので準備しておいてください。無料です。</p>

<p><a href="https://developer.apple.com/downloads/index.action" class="autolink" rel="nofollow noopener" target="_blank">https://developer.apple.com/downloads/index.action</a></p>

<p><a href="https://camo.qiitausercontent.com/2a27f6202e2433f66290c73b250ed63290a8b692/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f39303931373530322d353334382d656162352d666632662d3963653639386561313833382e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/2a27f6202e2433f66290c73b250ed63290a8b692/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f39303931373530322d353334382d656162352d666632662d3963653639386561313833382e706e67" alt="Sign_in_with_your_Apple_ID_-_Apple_Developer.png" title="Sign_in_with_your_Apple_ID_-_Apple_Developer.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/90917502-5348-eab5-ff2f-9ce698ea1838.png"></a></p>

<h2>
<span id="3-homebrew-本体をインストールする" class="fragment"></span><a href="#3-homebrew-%E6%9C%AC%E4%BD%93%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>3. Homebrew 本体をインストールする</h2>

<p><a href="http://brew.sh/" rel="nofollow noopener" target="_blank">Homebrew 公式サイト</a>に書かれている方法を用いてインストールします。<br>
下記のコマンドを <strong>ターミナル（Terminal.app）</strong> から実行するだけです。<br>
※この下記コマンドは公式サイト上でまれに変更される場合があるので、公式サイトへ飛んでコピペしたほうが最新です。</p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="gp">$</span> ruby -e <span class="s2">"</span><span class="k">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install<span class="k">)</span><span class="s2">"</span>
</pre></div></div>

<p>インストールが完了すると、その旨と簡単なセットアップを促すメッセージが出力されます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>==&gt; Installation successful!
You should run `brew doctor' *before* you install anything.
</pre></div></div>

<h1>
<span id="homebrew-を使用する" class="fragment"></span><a href="#homebrew-%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>Homebrew を使用する</h1>

<p>インストールが完了したら、まず下記コマンドを実行します。</p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew doctor
</pre></div></div>

<p>問題がないかチェックし、あった場合はその解決策を示してくれます。<br>
いざ、打ってみるとさっそく。。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>Warning: You have MacPorts or Fink installed:
  /opt/local/bin/port

This can cause trouble. You don't have to uninstall them, but you may want to
temporarily move them out of the way, e.g.

  sudo mv /opt/local ~/macports

Warning: You have a non-Homebrew 'pkg-config' in your PATH:
  /opt/local/bin/pkg-config

`./configure` may have problems finding brew-installed packages using
this other pkg-config.
</pre></div></div>

<p>今回は、MacPorts の存在がエラーの原因でした。解決策が示されているので、乗っかってみましよう。</p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ sudo mv /opt/local ~/macports
</pre></div></div>

<p><code>mv</code> の第二引数は何でもよくて、とりあえず除けたかったみたいです。もう一度 <code>brew doctor</code> してみて、</p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="go">Your system is ready to brew.</span>
</pre></div></div>

<p>と表示されれば、インストールの完了です。</p>

<p>===========</p>

<p>余談として、お決まりの本体アップデートをしておきます。<br>
最新版にするには、</p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="gp">$</span> brew update
</pre></div></div>

<p>バージョンチェックは、</p>

<div class="code-frame" data-lang="console"><div class="highlight"><pre><span></span><span class="gp">$</span> brew -v
</pre></div></div>

<p>です。</p>

<h1>
<span id="homebrew-の基本操作をする" class="fragment"></span><a href="#homebrew-%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E3%82%92%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>Homebrew の基本操作をする</h1>

<p><code>wget</code> コマンドをパッケージの例に説明していきます。<br>
以下に示すコマンド郡を使用できたら、実使用では無問題でしょう。</p>

<p><strong>パッケージを探す</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew search wget
</pre></div></div>

<p><strong>パッケージをインストール</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew install wget
</pre></div></div>

<p><strong>パッケージの有効化と無効化</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew unlink wget   <span class="c1"># 一時的に無効化</span>
$ brew link wget     <span class="c1"># 有効化</span>
</pre></div></div>

<p><strong>パッケージ一覧の更新</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew update     <span class="c1"># formula を更新</span>
$ brew upgrade    <span class="c1"># 更新があるパッケージを再ビルドする</span>
</pre></div></div>

<p><strong>インストールされたリストを表示する</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew list
</pre></div></div>

<p><strong>パッケージをアンインストール</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew remove wget
</pre></div></div>

<p><strong>Homebrew の設定一覧</strong></p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ brew --config
HOMEBREW_VERSION: <span class="m">0</span>.9.5
ORIGIN: https://github.com/mxcl/homebrew
HEAD: 57272977eaa0ec0509a29be6c8e90b5f4b338f65
HOMEBREW_PREFIX: /usr/local
HOMEBREW_CELLAR: /usr/local/Cellar
CPU: quad-core <span class="m">64</span>-bit ivybridge
OS X: <span class="m">10</span>.8.5-x86_64
Xcode: <span class="m">4</span>.6.3
CLT: <span class="m">4</span>.6.0.0.1.1365549073
LLVM-GCC: build <span class="m">2336</span>
Clang: <span class="m">4</span>.2 build <span class="m">425</span>
X11: N/A
System Ruby: <span class="m">1</span>.8.7-358
Perl: /usr/bin/perl
Python: /usr/bin/python
Ruby: /usr/bin/ruby <span class="o">=</span>&gt; /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby
</pre></div></div>

<h1>
<span id="homebrew-をアンインストール" class="fragment"></span><a href="#homebrew-%E3%82%92%E3%82%A2%E3%83%B3%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB"><i class="fa fa-link"></i></a>Homebrew をアンインストール</h1>

<p>世の中には気に食わないソフトウェアてのもあるものです。<br>
そんな時は以下をあせらずに実行し、一掃しましょう。</p>

<div class="code-frame" data-lang="bash"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="sb">`</span>brew --prefix<span class="sb">`</span>
$ rm -rf Cellar
$ brew prune
$ rm <span class="sb">`</span>git ls-files<span class="sb">`</span>
$ rmdir Library/Homebrew Library/Aliases Library/Formula Library/Contributions
$ rm -rf .git
$ rm -rf ~/Library/Caches/Homebrew
</pre></div></div>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />3位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>526</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/dcd6be0bb9c9185475bb">bash によるオプション解析</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-19 21:13:29</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>すこし記事が長いため、簡単なアウトラインを書いておきます。要点だけ掴みたい場合は、最終項の「まとめ」を読むのがいいかもしれません。</p>

<ul>
<li>コマンドライン引数の一般的な解析手法</li>
<li>それぞれの特徴 〜 getopt と getopts の違い</li>
<li>getopts（メリット・デメリット）</li>
<li>getopt（メリット・デメリット）</li>
<li>自前で解析しちゃう（唯一のデメリット）</li>
<li>まとめ</li>
</ul>

<p>=============================</p>

<p>コマンドライン引数を処理する一般的な手法として、</p>

<ol>
<li>getopts</li>
<li>getopt</li>
<li>shift などで自力で解析</li>
</ol>

<p>といった具合に、上から順に考えつくかと思います。<code>getopt(3)</code> は UNIX において、コマンドの引数を処理する一般的な C 言語のライブラリ関数です。それを用いて実装されたコマンドが <code>getopt(1)</code> です。Bourne シェル系だと内部関数になりますが、同系統の <code>getopts</code> という関数があります。</p>

<p><code>getopt</code> だと外部コマンドであるため、色々と面倒なことがあるので、Bourne シェル系だと <code>getopts</code> を使った方が余計なことがなくて良いとされています。</p>

<h2>
<span id="それぞれの特徴--getopt-と-getopts-の違い" class="fragment"></span><a href="#%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E3%81%AE%E7%89%B9%E5%BE%B4--getopt-%E3%81%A8-getopts-%E3%81%AE%E9%81%95%E3%81%84"><i class="fa fa-link"></i></a>それぞれの特徴 〜 <em>getopt と getopts の違い</em>
</h2>

<h3>
<span id="getopts" class="fragment"></span><a href="#getopts"><i class="fa fa-link"></i></a>getopts</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ type getopts
getopts is a shell builtin
</pre></div></div>

<p><strong>メリット</strong></p>

<p>とりあえず<code>getopts</code> は bash のビルドインコマンドであることです。ゆえに bash スクリプトとの親和性が高いとされます。<code>getopts</code> は <code>while</code> ループと <code>case</code> 文を用いることが定石です。<code>getopts</code> は第一引数に、使用したいオプション文字列を受け付けます。もし、そのオプションが引数を取る場合はコロンを後に付けると、<code>OPTARG</code> 変数にその値が保持されます。疑問符が返ってきたときは、無効なオプションが渡された時です。<code>break</code> で抜けるか、使い方を表示して <code>exit</code> が一般的です。そして、最後に処理した引数の数だけ、<code>shift</code> し終了です。</p>

<p>説明文の羅列だけでは分かりづらいので以下、テンプレートです。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">getopts.sh</span></div>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

usage_exit<span class="o">()</span> <span class="o">{</span>
        <span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$0</span><span class="s2"> [-a] [-d dir] item ..."</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
        <span class="nb">exit</span> <span class="m">1</span>
<span class="o">}</span>

<span class="k">while</span> <span class="nb">getopts</span> ad:h OPT
<span class="k">do</span>
    <span class="k">case</span> <span class="nv">$OPT</span> in
        a<span class="o">)</span>  <span class="nv">FLAG_A</span><span class="o">=</span><span class="m">1</span>
            <span class="p">;;</span>
        d<span class="o">)</span>  <span class="nv">VALUE_D</span><span class="o">=</span><span class="nv">$OPTARG</span>
            <span class="p">;;</span>
        h<span class="o">)</span>  usage_exit
            <span class="p">;;</span>
        <span class="se">\?</span><span class="o">)</span> usage_exit
            <span class="p">;;</span>
    <span class="k">esac</span>
<span class="k">done</span>

<span class="nb">shift</span> <span class="k">$((</span>OPTIND <span class="o">-</span> <span class="m">1</span><span class="k">))</span>
</pre></div>
</div>

<p>ここでの例では、<code>-a</code> オプションは引数を取らず、<code>-d</code> オプションは引数が必要としています。また、<code>-h</code> オプションまたはその他に関しては、ヘルプ表示を行う<code>usage_exit</code> 関数を実行し終了しています。</p>

<p><code>while getopts ad:h OPT</code> にてオプション解析をしていきますが、ここで指名していないオプション（例えば -b など）を指定した場合やオプションに引数が必要なのに無い場合など、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>./test.sh: option requires an argument -- d
./test.sh: illegal option -- x
</pre></div></div>

<p>といったようなエラー報告が行われます。ここで <code>while getopts :ad:h OPT</code> というように先頭にコロンを置くことで、こういったエラー表示は行われなくなりますので、自前でのエラー処理が行えます。</p>

<p><strong>デメリット</strong></p>

<ul>
<li>コマンドの引数のあとでオプションが使用できない</li>
</ul>

<p>bash スクリプトでオプション解析をする際には、bash 組み込みコマンドの <code>getopts</code> を使っていれば大抵の場合は問題ありません。しかし、<code>getopts</code> だと、コマンドラインの後半でオプションを指定できないことに気がつきました。 具体的には、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>Usage: command.bash [-a] [-d dir] item1 item2 ... 
</pre></div></div>

<p>のような構文の場合に、<code>-d dir</code> を <code>item</code> の後ろに指定しても、期待した処理がされません。</p>

<ul>
<li>ロングオプションが使用できない</li>
</ul>

<p><code>--help</code> や <code>--version</code> などのようなロングオプションが使用できないことです。一文字オプションでは文字の競合などが起こり、どのような規則で命名されたのか分かりにくく、これが必要なときもあります。</p>

<h3>
<span id="getopt" class="fragment"></span><a href="#getopt"><i class="fa fa-link"></i></a>getopt</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ type getopt
getopt is /usr/bin/getopt
</pre></div></div>

<p><strong>メリット</strong></p>

<p>上で挙げた <code>getopts</code>   のデメリットである、引数のあとにオプションを使用できない件と、ロングオプションの件を <em>条件付きで</em> 満たしています。<br>
<em>一般に</em> 使用される <code>getopt</code> のテンプレートは以下です。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">getopt.sh</span></div>
<div class="highlight"><pre><span></span><span class="nb">set</span> -- <span class="s1">'getopt ad: "$@"'</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> !<span class="o">=</span> <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$0</span><span class="s2"> [-a] [-d dir]"</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="k">for</span> OPT in <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="k">do</span>
    <span class="k">case</span> <span class="nv">$OPT</span> in
        -a<span class="o">)</span> <span class="nv">A_FLAG</span><span class="o">=</span><span class="m">1</span>
            <span class="nb">shift</span>
            <span class="p">;;</span>
        -d<span class="o">)</span> <span class="nv">B_ARG</span><span class="o">=</span><span class="nv">$2</span>
            <span class="nb">shift</span> <span class="m">2</span>
            <span class="p">;;</span>
        --<span class="o">)</span> <span class="nb">shift</span>
            <span class="nb">break</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
<span class="k">done</span>
</pre></div>
</div>

<p><code>getopt</code> の機能を拡張したものが <code>getopts</code> であるため、一般に使用する場合その優位性は <code>getopts</code> にあります。しかし、既存のシェルスクリプトでは <code>getopt</code> によって書かれたものも多く存在するので、すくなくとも読めたほうが良いです。</p>

<p><strong>デメリット</strong></p>

<p><code>getopt</code> は 外部コマンドのため、バージョンや環境によって差異があります。それが、BSD 系と GNU 系の違いです。</p>

<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: center">BSD系 実装</th>
<th style="text-align: center">GNU 実装</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">主なOS</td>
<td style="text-align: center">Mac OS X</td>
<td style="text-align: center">Ubuntu</td>
</tr>
<tr>
<td style="text-align: left">ロングオプション</td>
<td style="text-align: center"><strong>不可能</strong></td>
<td style="text-align: center">可能</td>
</tr>
<tr>
<td style="text-align: left">引数のあとにオプション</td>
<td style="text-align: center"><strong>不可能</strong></td>
<td style="text-align: center">可能</td>
</tr>
</tbody>
</table>

<p>つまり、<code>getopt</code> は使用する環境によって大きく処理が異なります。<br>
なら、BSD でも GNU のものを使えばいいじゃないか！ということで GNU 版 <code>getopt</code> のソースを入手しても、Mac OS X ではコンパイルは出来ません。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ gcc -o getopt getopt.c
Undefined symbols for architecture x86_64:
  "_main", referenced from:
      start in crt1.10.6.o
ld: symbol(s) not found for architecture x86_64
collect2: ld returned 1 exit status
exit 1
</pre></div></div>

<p>Ubuntu 上ではコンパイルも実行も可能ですが、当然ながら Mac OS X 上では作動してくれません。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ ./getopt
-bash: ./getopt: cannot execute binary file
exit 126
$ file getopt
getopt: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, not stripped
</pre></div></div>

<p>しかし、完全に Ubuntu でしか使用しないなら <code>getopt</code> の優位性は逆転します。<code>getopts</code> のデメリットを解消できるので、以下に使用テンプレを載せておきます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">getopt4ubuntu.sh</span></div>
<div class="highlight"><pre><span></span><span class="nv">OPT</span><span class="o">=</span><span class="sb">`</span>getopt -o ab:c --long long-a,  long-b:,long-c -- <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span><span class="sb">`</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> !<span class="o">=</span> <span class="m">0</span> <span class="o">]</span> <span class="p">;</span> <span class="k">then</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
<span class="nb">eval</span> <span class="nb">set</span> -- <span class="s2">"</span><span class="nv">$OPT</span><span class="s2">"</span>

<span class="k">while</span> <span class="nb">true</span>
<span class="k">do</span>
    <span class="k">case</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> in
    -a <span class="p">|</span> --long-a<span class="o">)</span>
        <span class="c1"># -a のときの処理</span>
        <span class="nb">shift</span>
        <span class="p">;;</span>
    -b <span class="p">|</span> --long-b<span class="o">)</span>
        <span class="c1"># -b のときの処理</span>
        <span class="nb">shift</span> <span class="m">2</span>
        <span class="p">;;</span>
    -c <span class="p">|</span> --long-c<span class="o">)</span>
        <span class="c1"># -c のときの処理</span>
        <span class="nb">shift</span>
        <span class="p">;;</span>
    --<span class="o">)</span>
        <span class="nb">shift</span>
        <span class="nb">break</span>
        <span class="p">;;</span>
    *<span class="o">)</span>
        <span class="nb">echo</span> <span class="s2">"Internal error!"</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
        <span class="nb">exit</span> <span class="m">1</span>
        <span class="p">;;</span>
    <span class="k">esac</span>
<span class="k">done</span>
</pre></div>
</div>

<p>GNU 版の <code>optget</code> は、ロングオプションも使用でき、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ getopt ab:c -b aaa -a bbb -c
-b aaa -a -c -- bbb
</pre></div></div>

<p>というように、<code>-c</code> オプションの前にあるコマンドの引数が、順番が入れ替えられて正常に出力される。</p>

<p>結果として、</p>

<ul>
<li><code>Ubuntu なら getopts &lt;&lt; getopt</code></li>
<li><code>Mac OS X なら getopts &gt;&gt; getopt</code></li>
</ul>

<p>であると言えます。</p>

<blockquote>
<p><strong>重大なバグに関して</strong><br><br>
getopt には重大な落とし穴があります。それは、スペースや特殊文字が引数に含まれていた場合、正しく処理できないということです。あるシェルスクリプトで getopt を使った場合、空白や特殊文字は絶対に使うな、という注意書きが必要になります。これを何とかしのごうとするのは容易ではありません。</p>
</blockquote>

<h2>
<span id="いっそ自前で解析しちゃう" class="fragment"></span><a href="#%E3%81%84%E3%81%A3%E3%81%9D%E8%87%AA%E5%89%8D%E3%81%A7%E8%A7%A3%E6%9E%90%E3%81%97%E3%81%A1%E3%82%83%E3%81%86"><i class="fa fa-link"></i></a>いっそ自前で解析しちゃう</h2>

<p>これらの組み込み関数や外部コマンドを使用しない簡単な例として、以下のように書くことが一般的であるといえるでしょう。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">shift.sh</span></div>
<div class="highlight"><pre><span></span><span class="k">for</span> OPT in <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="k">do</span>
    <span class="k">case</span> <span class="nv">$OPT</span> in
        <span class="s1">'-a'</span> <span class="o">)</span>
            <span class="nv">FLAG_A</span><span class="o">=</span><span class="m">1</span>
            <span class="p">;;</span>
        <span class="s1">'-b'</span> <span class="o">)</span>
            <span class="nv">FLAG_B</span><span class="o">=</span><span class="m">1</span>
            <span class="nv">VALUE_B</span><span class="o">=</span><span class="nv">$2</span>
            <span class="nb">shift</span> <span class="m">2</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
    <span class="nb">shift</span>
<span class="k">done</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$FLAG_A</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">"Option -a specified."</span>
<span class="k">fi</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$FLAG_B</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">"Option -b </span><span class="nv">$VALUE_B</span><span class="s2"> specified."</span>
<span class="k">fi</span>
</pre></div>
</div>

<p>このままでは、ロングオプションとコマンドの引数のあとでオプション指定の件が満たされていません。BSD 系の <code>getopt</code> 状態です。これらのデメリットを解消するため、実装していきましょう。</p>

<p>getopt(s) をめぐる差異は非常に厄介なので、<code>shift</code> しながらゴリゴリ処理してしまうパターン改。<br>
以下、ソース。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">shift2.sh</span></div>
<div class="highlight"><pre><span></span><span class="nv">PROGNAME</span><span class="o">=</span><span class="k">$(</span>basename <span class="nv">$0</span><span class="k">)</span>
<span class="nv">VERSION</span><span class="o">=</span><span class="s2">"1.0"</span>

usage<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$PROGNAME</span><span class="s2"> [OPTIONS] FILE"</span>
    <span class="nb">echo</span> <span class="s2">"  This script is ~."</span>
    <span class="nb">echo</span>
    <span class="nb">echo</span> <span class="s2">"Options:"</span>
    <span class="nb">echo</span> <span class="s2">"  -h, --help"</span>
    <span class="nb">echo</span> <span class="s2">"      --version"</span>
    <span class="nb">echo</span> <span class="s2">"  -a, --long-a ARG"</span>
    <span class="nb">echo</span> <span class="s2">"  -b, --long-b [ARG]"</span>
    <span class="nb">echo</span> <span class="s2">"  -c, --long-c"</span>
    <span class="nb">echo</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="o">}</span>

<span class="k">for</span> OPT in <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="k">do</span>
    <span class="k">case</span> <span class="s2">"</span><span class="nv">$OPT</span><span class="s2">"</span> in
        <span class="s1">'-h'</span><span class="p">|</span><span class="s1">'--help'</span> <span class="o">)</span>
            usage
            <span class="nb">exit</span> <span class="m">1</span>
            <span class="p">;;</span>
        <span class="s1">'--version'</span> <span class="o">)</span>
            <span class="nb">echo</span> <span class="nv">$VERSION</span>
            <span class="nb">exit</span> <span class="m">1</span>
            <span class="p">;;</span>
        <span class="s1">'-a'</span><span class="p">|</span><span class="s1">'--long-a'</span> <span class="o">)</span>
            <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> <span class="o">=</span>~ ^-+ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
                <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$PROGNAME</span><span class="s2">: option requires an argument -- </span><span class="nv">$1</span><span class="s2">"</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
                <span class="nb">exit</span> <span class="m">1</span>
            <span class="k">fi</span>
            <span class="nv">ARG_A</span><span class="o">=</span><span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>
            <span class="nb">shift</span> <span class="m">2</span>
            <span class="p">;;</span>
        <span class="s1">'-b'</span><span class="p">|</span><span class="s1">'--long-b'</span> <span class="o">)</span>
            <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> <span class="o">=</span>~ ^-+ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
                <span class="nb">shift</span>
            <span class="k">else</span>
                <span class="nb">shift</span> <span class="m">2</span>
            <span class="k">fi</span>
            <span class="p">;;</span>
        <span class="s1">'-c'</span><span class="p">|</span><span class="s1">'--long-c'</span> <span class="o">)</span>
            <span class="nb">shift</span> <span class="m">1</span>
            <span class="p">;;</span>
        <span class="s1">'--'</span><span class="p">|</span><span class="s1">'-'</span> <span class="o">)</span>
            <span class="nb">shift</span> <span class="m">1</span>
            <span class="nv">param</span><span class="o">+=(</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span> <span class="o">)</span>
            <span class="nb">break</span>
            <span class="p">;;</span>
        -*<span class="o">)</span>
            <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$PROGNAME</span><span class="s2">: illegal option -- '</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$1</span> <span class="p">|</span> sed <span class="s1">'s/^-*//'</span><span class="k">)</span><span class="s2">'"</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
            <span class="nb">exit</span> <span class="m">1</span>
            <span class="p">;;</span>
        *<span class="o">)</span>
            <span class="k">if</span> <span class="o">[[</span> ! -z <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="o">[[</span> ! <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span>~ ^-+ <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
                <span class="c1">#param=( ${param[@]} "$1" )</span>
                <span class="nv">param</span><span class="o">+=(</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">)</span>
                <span class="nb">shift</span> <span class="m">1</span>
            <span class="k">fi</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
<span class="k">done</span>

<span class="k">if</span> <span class="o">[</span> -z <span class="nv">$param</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$PROGNAME</span><span class="s2">: too few arguments"</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">echo</span> <span class="s2">"Try '</span><span class="nv">$PROGNAME</span><span class="s2"> --help' for more information."</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</pre></div>
</div>

<p>コマンドの引数（$@ にあたるもの）は <code>param</code> 変数に保持されます。ゆえにコマンドが引数の必要を絶対としない場合は、下からの5行はコメントアウトしてください。</p>

<p><strong>唯一のデメリット</strong></p>

<blockquote>
<p>GNU 版 <code>getopt</code> と肩を並べた以上のサンプルコードですが、組み込み関数 <code>getopts</code>・BSD 版 <code>getopt</code>・GNU 版 <code>getopt</code> では問題なかった、<code>-ab</code> というようなオプションの複数同時指定ができません。<code>-a -b</code> というようにバラさなければいけないのです。もちろん実装できなくもないですが、オプション解析がスクリプト本体の行数を超えかねないので、簡潔さを優先させ断念しました。</p>
</blockquote>

<p><strong>（以下 2014/10/10 追記）</strong></p>

<p>と以前は書いていたのですが単純ですが以下の方法で <code>-ab</code>、<code>-ba</code> というようなオプションの併記も可能です。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">manually_complete_version.sh</span></div>
<div class="highlight"><pre><span></span><span class="nb">declare</span> -i <span class="nv">argc</span><span class="o">=</span><span class="m">0</span>
<span class="nb">declare</span> -a <span class="nv">argv</span><span class="o">=()</span>

<span class="k">while</span> <span class="o">((</span> <span class="nv">$#</span> &gt; <span class="m">0</span> <span class="o">))</span>
<span class="k">do</span>
    <span class="k">case</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> in
        -*<span class="o">)</span>
            <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span>~ <span class="s1">'n'</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
                <span class="nv">nflag</span><span class="o">=</span><span class="s1">'-n'</span>
            <span class="k">fi</span>
            <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span>~ <span class="s1">'l'</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
                <span class="nv">lflag</span><span class="o">=</span><span class="s1">'-l'</span>
            <span class="k">fi</span>
            <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span>~ <span class="s1">'p'</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
                <span class="nv">pflag</span><span class="o">=</span><span class="s1">'-p'</span>
            <span class="k">fi</span>
            <span class="nb">shift</span>
            <span class="p">;;</span>
        *<span class="o">)</span>
            <span class="o">((</span>++argc<span class="o">))</span>
            <span class="nv">argv</span><span class="o">=(</span><span class="s2">"</span><span class="si">${</span><span class="nv">argv</span><span class="p">[@]</span><span class="si">}</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="o">)</span>
            <span class="nb">shift</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
<span class="k">done</span>
</pre></div>
</div>

<p>bash の組み込みである <code>[[</code> を使用して正規表現的に「含まれているか」を調べてオプションを設定しています。<br>
実引数（オプションを除く引数）の数 <code>argc</code> や実引数 <code>argv</code> も取得できます。<br>
よって直前の <code>shift2.sh</code> のスクリプトと組み合わせると、</p>

<ul>
<li>ショートオプション／ロングオプション対応 <code>$ command --long arg1 arg2</code>
</li>
<li>オプションの後付け可能 <code>$ command -s arg1 arg2 --long</code>
</li>
<li>オプションの複数併記可能 <code>$ command -ab -dc arg1</code>
</li>
<li>環境に依存しない</li>
</ul>

<p>これらの問題を克服して bash でオプション解析が可能になります。</p>

<h2>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h2>

<ul>
<li>
<code>getopts</code> は bash の組み込みコマンドである。ロングオプションは使用不可能、コマンドライン行後半でのオプション指定は不可能</li>
<li>BSD 版 <code>getopt</code> は <code>getopts</code> に劣るといえる</li>
<li>しかし、GNU 版 <code>getopt</code> はロングオプションが使用でき、コマンドライン行後半でのオプション指定は可能であるが、BSD 環境での使用はできない</li>
<li>
<code>getopt</code> は外部コマンドのため、以上のような環境での違いもあり、重大なバグも存在するためその使用は推奨されない</li>
<li>自前での解析は、数々の問題点をすべて解消できる。
<strong>しかし唯一、オプションの複数同時指定ができないという問題が発生する（2014/10/10 追記）</strong>
</li>
<li>やっぱり自前解析が一番いいとおもう（2014/10/10 現在の結論）</li>
</ul>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />4位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>281</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/e56a8e3471fb45df2f59">bash 配列まとめ</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-20 14:44:28</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>Linux ディストリビューションなどで標準搭載されている bash ですが、基本的にデフォルトで使えるデータ構造は配列くらいです。そこで、その扱いについてまとめました。</p>

<h2>
<span id="-配列を生成する" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>■ 配列を生成する</h2>

<p>たとえば、空の配列を生成するには以下のようにします。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>array=()
</pre></div></div>

<p>また、ビルトインコマンドの <code>declare</code>（関数スコープでの定義は <code>local</code>）で生成することも可能です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>declare -a array=()               # 宣言
declare -a array=("a" "b" "c")    # 初期化

some_func() {
    local local_array=()           # 関数内スコープは local で定義できる      ...
}
</pre></div></div>

<h2>
<span id="-配列の要素数" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%81%AE%E8%A6%81%E7%B4%A0%E6%95%B0"><i class="fa fa-link"></i></a>■ 配列の要素数</h2>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>echo ${#array[@]}              # 3
echo ${#array[*]}              # 3
</pre></div></div>

<p>配列の要素数をチェックする場合は、<code>[@]</code> でも <code>[*]</code> でも差異はないようです。</p>

<h2>
<span id="-配列のデータを操作する" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E6%93%8D%E4%BD%9C%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>■ 配列のデータを操作する</h2>

<h3>
<span id="-データを追加する" class="fragment"></span><a href="#-%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>● データを追加する</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># 先頭に追加
array=(3 "${array[@]}")        # array は (3 “a” "b" "c")

# 末尾に追加
array=("${array[@]}" 4)        # array は (3 "a" "b" "c" 4)
array+=( 5 )                   # array は (3 "a" "b" "c" 4 5)
</pre></div></div>

<p>末尾に追加する書き方は二通りですが、どちらでも同じようです。しかし、前者のほうが「先頭に追加」の表記方法と整合性が取れるので、可読性を高めそうです。</p>

<h3>
<span id="-配列からデータを取り出す" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%81%8B%E3%82%89%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%96%E3%82%8A%E5%87%BA%E3%81%99"><i class="fa fa-link"></i></a>● 配列からデータを取り出す</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># データの先頭要素を取り出す（破壊的操作）
array=("${array[@]:1}")                   # array は ("a" "b" "c" 4 5)

# データの末尾要素取り出す（破壊的操作）
declare -i num=${#array[@]}-1
array=("${array[@]:0:$num}")              # array は ("a" "b" "c" 4)
# 一行でも書けます
array=(${array[@]:0:((${#array[@]}-1))})  # array は ("a" "b" "c")
</pre></div></div>

<h3>
<span id="-配列のデータを参照する" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%82%E7%85%A7%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>● 配列のデータを参照する</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>i=0
for e in ${array[@]}; do
    echo "array[$i] = ${e}"
    let i++
done
</pre></div></div>

<p>array[0] = a<br>
array[1] = b<br>
array[2] = c</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># C言語風に記述する
for ((i = 0; i &lt; ${#array[@]}; i++)) {
    echo "array[$i] = ${array[i]}"
}
</pre></div></div>

<p>array[0] = a<br>
array[1] = b<br>
array[2] = c</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># Bash 独自の記述 1
echo "${array[@]}"
</pre></div></div>

<p>a b c</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># Bash 独自の記述 2
IFS=$'\n'
echo "${array[*]}"
</pre></div></div>

<p>a<br>
b<br>
c</p>

<h3>
<span id="-配列のデータから任意の要素を削除する" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8B%E3%82%89%E4%BB%BB%E6%84%8F%E3%81%AE%E8%A6%81%E7%B4%A0%E3%82%92%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>● 配列のデータから任意の要素を削除する</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span># ある要素を削除
unset array[1]
echo "${array[@]}"             # arrayは("a" "c")

echo ${array[0]}               # array[0]は"a"
echo ${array[1]}               # array[1]は ""（空）
echo ${array[2]}               # array[2]は"c"
</pre></div></div>

<p>配列の中身のデータは削除できても、配列自体は削除できません。<br><br>
添字を詰めたければ、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>array=("${array[@]}"
</pre></div></div>

<p>代入しなおす必要があります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>unset array[@]                 # 全削除する
echo "${array[@]}"             # 配列 array は ""（空）
echo "${#array[@]}"            # 要素数は0
</pre></div></div>

<h3>
<span id="-配列にデータを格納する" class="fragment"></span><a href="#-%E9%85%8D%E5%88%97%E3%81%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E6%A0%BC%E7%B4%8D%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>● 配列にデータを格納する</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>array[0]=1
array[1]="a"
</pre></div></div>

<p>以上です。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />5位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>99</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/77c589f21a99db8bb682">シェルスクリプトでパイプを判断する</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-26 00:52:28</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>Unix の基本的考え方のひとつに「フィルタとして振る舞う」というものがあります。標準入力から入力をして何らかの処理を行い、標準出力に出力を行うように設計されているコマンドを <strong>フィルタ</strong> と呼びます。フィルタ・コマンドそれ自身は単純な機能しか持っていませんが、これを | （バーティカルバー）で結びつけることでフィルタを部品のように扱い、大きな機能をもったコマンドとして機能させることが出来ます。</p>

<p><a href="https://camo.qiitausercontent.com/6d7ee650244ea8a7610964e29b88171258bdc80f/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f37333635653537652d393161372d633831332d623832612d6266626430333535633637342e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/6d7ee650244ea8a7610964e29b88171258bdc80f/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f37333635653537652d393161372d633831332d623832612d6266626430333535633637342e706e67" alt="pipe.png" title="pipe.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/7365e57e-91a7-c813-b82a-bfbd0355c674.png"></a></p>

<p>（例）</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ history | awk '{print $2}' | sort | uniq -c | sort -nr | head
162 ls
110 mkdir
68 mv
23 rm
11 touch
</pre></div></div>

<p>この例ではパイプごとに説明すると、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>ヒストリを表示し｜第２フィールドのみを切り出し｜ソートして｜重複するものをカウントしながらまとめて｜数字の大きい順にソートして｜先頭を取り出す
</pre></div></div>

<p>ということを行っています。このような芸当ができるのは、Unix のコマンドがフィルタとして振る舞うように設計されているからです。</p>

<h1>
<span id="自作コマンドでもフィルタしたい" class="fragment"></span><a href="#%E8%87%AA%E4%BD%9C%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%A7%E3%82%82%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%81%97%E3%81%9F%E3%81%84"><i class="fa fa-link"></i></a>自作コマンドでもフィルタしたい</h1>

<p>フィルタとしてのコマンドを作成する場合、そのコマンドにおいてパイプによる入力を捕捉しなくてはなりません。以下が解答例です。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">is_pipe.func</span></div>
<div class="highlight"><pre><span></span><span class="k">function</span> is_pipe<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> -p /dev/stdin <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c1">#if [ -p /dev/fd/0  ]; then</span>
    <span class="c1">#if [ -p /proc/self/fd/0 ]; then</span>
    <span class="c1">#if [ -t 0 ]; then</span>
        <span class="c1"># echo a | is_pipe</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="k">elif</span> <span class="o">[</span> -p /dev/stdout <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="c1"># is_pipe | cat</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="k">else</span>
        <span class="c1"># is_pipe (Only!)</span>
        <span class="k">return</span> <span class="m">1</span>
    <span class="k">fi</span>
<span class="o">}</span>
</pre></div>
</div>

<h2>
<span id="解説" class="fragment"></span><a href="#%E8%A7%A3%E8%AA%AC"><i class="fa fa-link"></i></a>解説</h2>

<ul>
<li>
<code>test</code> コマンドのオプションの意味</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-p</td>
<td style="text-align: center">名前付きパイプであれば真</td>
</tr>
<tr>
<td style="text-align: center">-t</td>
<td style="text-align: center">端末にてオープンされていれば真</td>
</tr>
</tbody>
</table>

<ul>
<li>標準入出力の捕捉</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: center">標準入力の捕捉</th>
<th style="text-align: center">標準出力の捕捉</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">[ -p /dev/stdin ]</td>
<td style="text-align: center">[ -p /dev/stdout ]</td>
</tr>
<tr>
<td style="text-align: center">[ -p /dev/fd/0 ]</td>
<td style="text-align: center">[ -p /dev/fd/1 ]</td>
</tr>
<tr>
<td style="text-align: center">[ -p /proc/self/fd/0 ]</td>
<td style="text-align: center">[ -p /proc/self/fd/1 ]</td>
</tr>
<tr>
<td style="text-align: center">[ -t 0 ]</td>
<td style="text-align: center">[ -t 1 ]</td>
</tr>
</tbody>
</table>

<h2>
<span id="使い勝手良く" class="fragment"></span><a href="#%E4%BD%BF%E3%81%84%E5%8B%9D%E6%89%8B%E8%89%AF%E3%81%8F"><i class="fa fa-link"></i></a>使い勝手良く</h2>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">in_pipe.sh</span></div>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">[</span> -p /dev/stdin <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">"pipe!"</span>
    cat -
    <span class="nb">exit</span> <span class="m">0</span>
<span class="k">else</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</pre></div>
</div>

<p>パイプを検知したら <code>pipe!</code> と出力し、標準入力をそのまま標準出力に流すスクリプトです。以下実行例。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ echo a | ./in_pipe.sh
pipe!
a
</pre></div></div>

<p>次は、パイプ直前に実行された場合のみ <code>pipe!</code> と出力するスクリプトです。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">out_pipe.sh</span></div>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">[</span> -p /dev/stdout <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">"pipe!"</span>
    <span class="nb">exit</span> <span class="m">0</span>
<span class="k">else</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</pre></div>
</div>

<p>以下実行例です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ ./out_pipe | cat
pipe!
</pre></div></div>

<p>抽象的すぎてわかりづらいかもしれません。具体化しましょう。</p>

<h1>
<span id="具体例" class="fragment"></span><a href="#%E5%85%B7%E4%BD%93%E4%BE%8B"><i class="fa fa-link"></i></a>具体例</h1>

<p><code>.bak</code> 拡張子を持つコピーファイルを作成する簡易バックアップコマンド <code>bak</code> を例に、このパイプ判断スクリプトの利点を説明します。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">bak</span></div>
<div class="highlight"><pre><span></span><span class="k">for</span> FILE <span class="k">do</span>
    <span class="o">[</span> ! -e <span class="nv">$FILE</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">{</span> <span class="nb">echo</span> <span class="m">1</span>&gt;<span class="p">&amp;</span><span class="m">2</span> <span class="s2">"</span><span class="nv">$FILE</span><span class="s2">: no exist"</span><span class="p">;</span> <span class="k">continue</span><span class="p">;</span> <span class="o">}</span>
    <span class="k">if</span> <span class="o">[</span> -p /dev/stdout <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c1">#if out_pipe; then の意味</span>
        <span class="c1"># コピーファイルを作成</span>
        cp <span class="nv">$FILE</span> <span class="nv">$FILE</span>.bak
        <span class="c1"># 自作関数 abs_path でフルパスを標準出力へ流す</span>
        <span class="nb">echo</span> <span class="k">$(</span>abs_path <span class="nv">$_</span><span class="k">)</span>
    <span class="k">else</span>
        <span class="c1"># copy to current dir</span>
        cp <span class="nv">$FILE</span> <span class="nv">$FILE</span>.bak
    <span class="k">fi</span>
<span class="k">done</span>
</pre></div>
</div>

<p>パイプがなければ普通に <code>.bak</code> をもつコピーファイルを作成して終了（以下）。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ bak myfile
$ ls
myfile  myfile.bak
</pre></div></div>

<p>パイプがある場合は、<code>.bak</code> をもつコピーファイルを作成して、そのコピーファイルのフルパスを標準出力に流します。<br>
実際にやってみる（以下）。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ bak myfile | xargs mv -t Work/
$ ls
myfile
$ ls Work/
myfile.bak
</pre></div></div>

<p><code>bak</code> コマンドによる複製が行われてそのまま、<code>mv</code> によるコピーファイルの移動が行われていますね。<br>
ちなみに、今回使用した <code>mv</code> コマンドの <code>-t</code> オプションは GNU のものです。BSD その他の <code>mv</code> では使用できません。</p>

<h1>
<span id="合わせて読みたい" class="fragment"></span><a href="#%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E8%AA%AD%E3%81%BF%E3%81%9F%E3%81%84"><i class="fa fa-link"></i></a>合わせて読みたい</h1>

<p><a href="http://qiita.com/b4b4r07/items/129f11c80aa34479b764" id="reference-0e8a22b85903ad028edc">自作コマンドの作り方</a>を記事にしました。<br>
<a href="http://qiita.com/b4b4r07/items/30d34016a95f52f8b9ab">絶対パス・相対パスを取得する</a>を記事にしました。<code>abs_path</code> はこの記事でも使用した関数です。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />6位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>94</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/1a53862e3ee857b8888e">コマンドラインにイラストを</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-10-06 17:36:09</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>Unix には <code>cowsay</code> というウシが喋るコマンドがあります。<br>
動作は単純で、メッセージをつぶやくウシのアスキーアートを生成するプログラムです。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">sh</span></div>
<div class="highlight"><pre><span></span>b4b4r07:~$ cowsay Hello!
 ________ 
&lt; Hello! &gt;
 -------- 
        <span class="se">\ </span>  ^__^
         <span class="se">\ </span> <span class="o">(</span>oo<span class="o">)</span><span class="se">\_</span>______
            <span class="o">(</span>__<span class="o">)</span><span class="se">\ </span>      <span class="o">)</span><span class="se">\/\</span>
                <span class="o">||</span>----w <span class="p">|</span>
                <span class="o">||</span>     <span class="o">||</span>
b4b4r07:~$ 
</pre></div>
</div>

<p>ウシ以外にも様々なアスキーアートが用意されていて、色々なイラストを表示できます。<br>
<code>cowsay -l</code> で表示することの出来るイラスト群をリストアップできます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">sh</span></div>
<div class="highlight"><pre><span></span>b4b4r07:~$ cowsay -f Dragon Hello!
 ________ 
&lt; Hello! &gt;
 -------- 
      <span class="se">\ </span>                   / <span class="se">\ </span> //<span class="se">\</span>
       <span class="se">\ </span>   <span class="p">|</span><span class="se">\_</span>__/<span class="p">|</span>      /   <span class="se">\/</span>/  <span class="se">\\</span>
            /0  <span class="m">0</span>  <span class="se">\_</span>_  /    //  <span class="p">|</span> <span class="se">\ \ </span>   
           /     /  <span class="se">\/</span>_/    //   <span class="p">|</span>  <span class="se">\ </span> <span class="se">\ </span> 
           @_^_@<span class="s1">'/   \/_   //    |   \   \ </span>
<span class="s1">           //_^_/     \/_ //     |    \    \</span>
<span class="s1">        ( //) |        \///      |     \     \</span>
<span class="s1">      ( / /) _|_ /   )  //       |      \     _\</span>
<span class="s1">    ( // /) '</span>/,_ _ _/  <span class="o">(</span> <span class="p">;</span> -.    <span class="p">|</span>    _ _<span class="se">\.</span>-~        .-~~~^-.
  <span class="o">((</span> / / <span class="o">))</span> ,-<span class="o">{</span>        _      <span class="sb">`</span>-.<span class="p">|</span>.-~-.           .~         <span class="sb">`</span>.
 <span class="o">((</span> // / <span class="o">))</span>  <span class="s1">'/\      /                 ~-. _ .-~      .-~^-.  \</span>
<span class="s1"> (( /// ))      `.   {            }                   /      \  \</span>
<span class="s1">  (( / ))     .----~-.\        \-'</span>                 .~         <span class="se">\ </span> <span class="sb">`</span>. <span class="se">\^</span>-.
             ///.----..&gt;        <span class="se">\ </span>            _ -~             <span class="sb">`</span>.  ^-<span class="sb">`</span>  ^-_
               ///-._ _ _ _ _ _ _<span class="o">}</span>^ - - - - ~                     ~-- ,.-~
                                                                  /.-~
b4b4r07:~$ 
</pre></div>
</div>

<h2>
<span id="インストール方法" class="fragment"></span><a href="#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E6%96%B9%E6%B3%95"><i class="fa fa-link"></i></a>インストール方法</h2>

<p>Mac OSX の利用者は <a href="http://qiita.com/b4b4r07/items/6efebc2f3d1cbbd393fc#1-3" id="reference-6fd73aa131793bc61990">Homebrew</a> を利用すれば大丈夫です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ brew install cowsay
</pre></div></div>

<p>Homebrew のインストール方法は<a href="http://qiita.com/b4b4r07/items/6efebc2f3d1cbbd393fc#1-4" id="reference-6fd73aa131793bc61990">ここ</a>にあります。</p>

<p>Ubuntu などの Linux では、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ sudo apt-get install cowsay
</pre></div></div>

<p>でいけます。</p>

<h1>
<span id="ログイン時に表示させる" class="fragment"></span><a href="#%E3%83%AD%E3%82%B0%E3%82%A4%E3%83%B3%E6%99%82%E3%81%AB%E8%A1%A8%E7%A4%BA%E3%81%95%E3%81%9B%E3%82%8B"><i class="fa fa-link"></i></a>ログイン時に表示させる</h1>

<p><code>~/.bashrc</code> に <code>cowsay &lt;文字列&gt;</code> を書き込めば表示はされるものの、文字イラスト固定では飽きてしまいます。毎回違うイラストが、色々しゃべると楽しい！ということで、書いてみました。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">~/.bashrc</span></div>
<div class="highlight"><pre><span></span><span class="k">function</span> random_cowsay<span class="o">()</span> <span class="o">{</span>
    <span class="c1"># Only brew user!</span>
    <span class="c1"># If you are not brew user, change 'COWS' path</span>
    <span class="nv">COWS</span><span class="o">=</span><span class="sb">`</span>brew --prefix<span class="sb">`</span>/Cellar/cowsay/3.03/share/cows
    <span class="nv">NBRE_COWS</span><span class="o">=</span><span class="k">$(</span>ls -1 <span class="nv">$COWS</span> <span class="p">|</span> wc -l<span class="k">)</span>
    <span class="nv">COWS_RANDOM</span><span class="o">=</span><span class="k">$(</span>expr <span class="nv">$RANDOM</span> % <span class="nv">$NBRE_COWS</span> + <span class="m">1</span><span class="k">)</span>
    <span class="nv">COW_NAME</span><span class="o">=</span><span class="k">$(</span>ls -1 <span class="nv">$COWS</span> <span class="p">|</span> awk -F<span class="se">\.</span> -v <span class="nv">COWS_RANDOM_AWK</span><span class="o">=</span><span class="nv">$COWS_RANDOM</span> <span class="s1">'NR == COWS_RANDOM_AWK {print $1}'</span><span class="k">)</span>
    cowsay -f <span class="nv">$COW_NAME</span> <span class="s2">"`Fortune -s`"</span>
<span class="o">}</span>
<span class="k">if</span> which fortune cowsay &gt;/dev/null<span class="p">;</span> <span class="k">then</span>
    <span class="k">while</span> :
    <span class="k">do</span>
        random_cowsay <span class="m">2</span>&gt;/dev/null <span class="o">&amp;&amp;</span> <span class="nb">break</span>
    <span class="k">done</span>
<span class="k">fi</span> <span class="o">&amp;&amp;</span> <span class="nb">unset</span> -f random_cowsay
</pre></div>
</div>

<p>あせって動かした方はまだ動かなかったかもしれません。<br>
最後の仕上げとして、ランダムな文字列を生成させるコマンドをインストールしましょう。<br>
<a href="http://ja.wikipedia.org/wiki/Fortune" rel="nofollow noopener" target="_blank">fortune</a> という有名人の格言などをランダムに表示させるコマンドがあります。</p>

<p><code>cowsay</code> と同じように、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ brew install fortune
</pre></div></div>

<p>または</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ sudo apt-get install fortune
</pre></div></div>

<p>で大丈夫なはずです。</p>

<h1>
<span id="bash-再起動" class="fragment"></span><a href="#bash-%E5%86%8D%E8%B5%B7%E5%8B%95"><i class="fa fa-link"></i></a>bash 再起動</h1>

<p><a href="https://camo.qiitausercontent.com/5faee3dbfeb5ab225d3edf1efe1f0edeae628ceb/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f64663033393933632d613964612d656664622d623463342d3432663763663561323230332e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/5faee3dbfeb5ab225d3edf1efe1f0edeae628ceb/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f64663033393933632d613964612d656664622d623463342d3432663763663561323230332e706e67" alt="fu7ur3_—_bash_—_82×26.png" title="fu7ur3_—_bash_—_82×26.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/df03993c-a9da-efdb-b4c4-42f7cf5a2203.png"></a></p>

<p>毎回、ログインするたびに色々なイラストたちが有名人の格言とともに現れるので、すこし楽しい気分を味わえます。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />7位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>51</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/8cf5d1c8b3fbfcf01a5d">cd したら ls する</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-10-06 00:03:51</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>シェルを使用する上での定石のようなものかもしれません。ある程度コマンドラインに慣れた人なら、どのディレクトリに何があるかなどは覚えてくるものですが、<code>cd</code> したら <code>ls</code> するようになっていたら便利かと思います。</p>

<h1>
<span id="直接的に解決する" class="fragment"></span><a href="#%E7%9B%B4%E6%8E%A5%E7%9A%84%E3%81%AB%E8%A7%A3%E6%B1%BA%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>直接的に解決する</h1>

<p>毎回 <code>cd</code> するたびに <code>ls</code> するのは面倒くさいし時間の無駄なので、関数にして <code>cd</code> にエイリアスします。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">~/.bashrc</span></div>
<div class="highlight"><pre><span></span>cdls <span class="o">()</span>
<span class="o">{</span>
    <span class="se">\c</span>d <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> ls
<span class="o">}</span>
<span class="nb">alias</span> <span class="nv">cd</span><span class="o">=</span><span class="s2">"cdls"</span>
</pre></div>
</div>

<p>こうすることで、<code>cd</code> に成功した場合のみ <code>ls</code> することが出来ます。ディレクトリ名をタイプミスした場合などは <code>ls</code> はされません。また、どの <code>cd</code> か特定していないため、独自に作成している <code>cd</code> 関数などを妨害（上書き）することはありません。</p>

<p><code>\cd</code> としているのは、エイリアスの <code>cd</code> によるループを防ぐのに明示するためです。エイリアスの回避のためのエスケープなので、<code>cd</code> 関数がある場合、それはエスケープされないので大丈夫です。<code>\cd</code> ではなく <code>''cd</code> や <code>""cd</code> でも同じです。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">具体例</span></div>
<div class="highlight"><pre><span></span>cd<span class="o">()</span> <span class="o">{</span>
    <span class="nb">builtin</span> <span class="nb">cd</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"success"</span>
<span class="o">}</span>

cdls <span class="o">()</span>
<span class="o">{</span>
    <span class="se">\c</span>d <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> ls
<span class="o">}</span>

<span class="nb">alias</span> <span class="nv">cd</span><span class="o">=</span><span class="s2">"cdls"</span>
</pre></div>
</div>

<p>独自に作成している <code>cd</code> 関数を妨害することなく、<code>cd</code> したら <code>ls</code> するようになっています。<br>
実行するとわかりますが、移動に成功した場合のみ <code>ls</code> して、success の文字が表示されます。<br>
ちなみに、エイリアスが一番最後に来ないと、関数の方の <code>cd</code> に上書きされて、<code>ls</code> されなくなるので注意です。</p>

<h2>
<span id="別解" class="fragment"></span><a href="#%E5%88%A5%E8%A7%A3"><i class="fa fa-link"></i></a>別解</h2>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">~/.bashrc</span></div>
<div class="highlight"><pre><span></span><span class="nb">cd</span> <span class="o">()</span>
<span class="o">{</span>
    <span class="nb">builtin</span> <span class="nb">cd</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> ls
<span class="o">}</span>
</pre></div>
</div>

<p><code>cd</code> に成功した場合のみ <code>ls</code> することには変わりないですが、エイリアスではなく <code>cd</code> を関数化することで、他に作成していた場合の <code>cd</code> 関数による影響を受けなくなります。</p>

<p>また、今回は <code>builtin</code> としてやることで、関数の <code>cd</code> によるループを防いでいます。</p>

<h1>
<span id="別の手法で試みる" class="fragment"></span><a href="#%E5%88%A5%E3%81%AE%E6%89%8B%E6%B3%95%E3%81%A7%E8%A9%A6%E3%81%BF%E3%82%8B"><i class="fa fa-link"></i></a>別の手法で試みる</h1>

<p>そもそも、</p>

<p><strong><code>cd</code> に成功する　イコール　ディレクトリが変更される</strong></p>

<p>ことなんだから、コマンドを打つたびにディレクトリの変更をチェックして、コマンドを打つ前と打った後でカレントディレクトリ名が違ったら <code>ls</code> すれば解決ですよね。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">~/.bashrc</span></div>
<div class="highlight"><pre><span></span>auto_cdls<span class="o">()</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$OLDPWD</span><span class="s2">"</span> !<span class="o">=</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        ls
        <span class="nv">OLDPWD</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>
    <span class="k">fi</span>
<span class="o">}</span>
<span class="nv">PROMPT_COMMAND</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PROMPT_COMMAND</span><span class="s2">"</span><span class="s1">$'\n'</span>auto_cdls
</pre></div>
</div>

<p>解説です。まず <code>auto_cdls</code> という関数を作成し、それを <code>PROMPT_COMMAND</code> に追加しています。<br>
<code>PROMPT_COMMAND</code> とは bash で使用されている環境変数で、コマンドを打った直後に実行されます。この性質を利用することで、毎回ディレクトリの変更をチェックすることが出来ます。</p>

<p><code>auto_cdls</code> 関数はそのチェックをする関数です。前回いたディレクトリパスは <code>$OLDPWD</code> という環境変数に保存されているので、それをカレントのディレクトリパスと比較して異なっていたら <code>ls</code> しています。<br>
このままでは、他のコマンドを打った時に <code>$OLDPWD</code> と <code>$PWD</code> は異なったままなので <code>ls</code> されてしまうのを防ぐために、 <code>$OLDPWD</code> に <code>$PWD</code> を代入して同じにしています。これでまた <code>cd</code> などでディレクトリが変更されたら自動で <code>ls</code> されるというわけです。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />8位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>38</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/129f11c80aa34479b764">自作コマンドの作り方  </a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-26 00:52:02</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;">
<h1>
<span id="手順" class="fragment"></span><a href="#%E6%89%8B%E9%A0%86"><i class="fa fa-link"></i></a>手順</h1>

<ol>
<li>パスが通ったディレクトリを用意する</li>
<li>シバン<sup id="fnref1"><a href="#fn1" rel="footnote" title="シバンまたはシェバン (shebang) とはUNIXのスクリプトの#!から始まる1行目のこと。起動してスクリプトを読み込むインタプリタを指定する。 hash-bangまたはsharp-bangとも言うが、後者を縮めたshebangという呼び方が一般的かつシンプルである。">1</a></sup>を書いたスクリプトを 1.で用意したディレクトリ下に置く</li>
<li>2.で作ったスクリプトに実行属性を与える</li>
</ol>

<h2>
<span id="1-パスが通ったディレクトリ" class="fragment"></span><a href="#1-%E3%83%91%E3%82%B9%E3%81%8C%E9%80%9A%E3%81%A3%E3%81%9F%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA"><i class="fa fa-link"></i></a>1. パスが通ったディレクトリ</h2>

<p>「コマンドを実行する」にあたって必要なのは、その実行ファイルの名前をタイプすることですが、実行するとき <code>/bin/</code> や <code>/usr/bin/</code> がカレントディレクトリである必要はありません。どのディレクトリからでもコマンド名のみで実行可能です。</p>

<p>これはどういう仕組みになっているかというと、<code>/bin/</code> や <code>/usr/bin/</code> などのディレクトリに、「その中の実行ファイルを任意のディレクトリからフルパスでなく実行できる。」という許可が与えられているからです。<br>
その許可は、環境変数 <strong>PATH</strong> によって与えられます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ echo $PATH
/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
</pre></div></div>

<p>環境変数 <code>PATH</code> はコロン（：）で区切られています。実際に追加してみましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ mkdir ~/bin
$ PATH="~/bin:$PATH"
$ echo $PATH
~/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
</pre></div></div>

<p>先頭に追加されていることがわかります。これでパスが通ったディレクトリを準備出来ました。</p>

<h2>
<span id="2-シバンを書いたスクリプト" class="fragment"></span><a href="#2-%E3%82%B7%E3%83%90%E3%83%B3%E3%82%92%E6%9B%B8%E3%81%84%E3%81%9F%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88"><i class="fa fa-link"></i></a>2. シバンを書いたスクリプト</h2>

<p>シバンとは <code>#!</code> から始まる1行目のことを指します。具体的には以下。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ cat &lt;&lt;EOF &gt;firstprog.sh
&gt; #!/bin/sh
&gt; 
&gt; if [ `ls ~ | wc -l` -eq 0 ]; then
&gt;   echo "file not exist."
&gt; else
&gt;   echo "file exist."
&gt; fi
EOF

$ ls
firstprog.sh
</pre></div></div>

<p>この例は、ホームディレクトリのファイルがあるかどうかを調べるスクリプトです。<br><br>
今回は、これを 1. で用意したディレクトリ下に置きましょう。</p>

<h2>
<span id="3-実行属性を与える" class="fragment"></span><a href="#3-%E5%AE%9F%E8%A1%8C%E5%B1%9E%E6%80%A7%E3%82%92%E4%B8%8E%E3%81%88%E3%82%8B"><i class="fa fa-link"></i></a>3. 実行属性を与える</h2>

<p>これは簡単です。<br><br>
ファイル属性・所有者権限を変更するコマンド <code>chmod</code> を使用します。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ ls -l firstprog.sh
-rw-r--r-- 1 tester staff 0 Aug  9 15:27 firstprog.sh
$ chmod 755 firstprog.sh
$ ls -l firstprog.sh
-rwxr-xr-x 1 tester staff 0 Aug  9 15:27 firstprog.sh
</pre></div></div>

<p><code>x フラグ</code> が立っていることがわかります。これで実行属性が付与されました。</p>

<h1>
<span id="結果" class="fragment"></span><a href="#%E7%B5%90%E6%9E%9C"><i class="fa fa-link"></i></a>結果</h1>

<p>以上で、自作コマンドを作成できました。<br>
これにより <code>~/bin</code> 以外のどのディレクトリからでもスクリプトを実行出来ます。</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>シバンまたはシェバン (shebang) とはUNIXのスクリプトの#!から始まる1行目のこと。起動してスクリプトを読み込むインタプリタを指定する。 hash-bangまたはsharp-bangとも言うが、後者を縮めたshebangという呼び方が一般的かつシンプルである。 <a href="#fnref1">↩</a></p>
</li>

</ol>
</div>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />9位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>31</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/037377b8efb0c1e36800">コマンドラインから GUI を操作する</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-27 16:31:57</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[Bash]</b> <b>[Mac]</b> <b>[MacOSX]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;">
<h1>
<span id="mac-編" class="fragment"></span><a href="#mac-%E7%B7%A8"><i class="fa fa-link"></i></a>Mac 編</h1>

<h2>
<span id="open-と-qlmanage" class="fragment"></span><a href="#open-%E3%81%A8-qlmanage"><i class="fa fa-link"></i></a>open と qlmanage</h2>

<h3>
<span id="open-コマンド" class="fragment"></span><a href="#open-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89"><i class="fa fa-link"></i></a>open コマンド</h3>

<p>ファイル、ディレクトリ（フォルダ）、URL を GUI で開くことが出来るコマンドです。Finder でいうダブルクリック操作に相当します。</p>

<ul>
<li>オプション</li>
</ul>

<p>主なオプションを挙げておきます。他にもまだあります。</p>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">意味</th>
<th style="text-align: center">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-a <em>application</em>
</td>
<td style="text-align: center">ファイルを開くアプリケーション（パス名）を指定</td>
<td style="text-align: center">$ open -a Emacs file.txt</td>
</tr>
<tr>
<td style="text-align: center">-e <em>file</em>
</td>
<td style="text-align: center">テキストエディットで開く</td>
<td style="text-align: center">-a TextEdit.app <em>file</em> に相当</td>
</tr>
<tr>
<td style="text-align: center">-t <em>file</em>
</td>
<td style="text-align: center">標準のテキストエディタで開く</td>
<td style="text-align: center">LaunchServices で標準の変更が可能</td>
</tr>
<tr>
<td style="text-align: center">-n <em>application</em>
</td>
<td style="text-align: center">すでに開かれていれば多重起動する</td>
<td style="text-align: center">10.5 〜 10.6 のみ利用可能</td>
</tr>
</tbody>
</table>

<ul>
<li>使用例</li>
</ul>

<p>オプション無しで、<code>open</code> コマンドに引数を渡せば、それをシステムで関連付けされたアプリケーションで開くことが出来ます。ダブルクリックのコマンドラインバージョンです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ open dir
</pre></div></div>

<p>ディレクトリ <em>dir</em> を開きます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ open .
</pre></div></div>

<p>カレントディレクトリ（.）を開きます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ open exam2013.pdf
</pre></div></div>

<p>プレビュー.app で開きます。</p>

<h3>
<span id="qlmanage-コマンド" class="fragment"></span><a href="#qlmanage-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89"><i class="fa fa-link"></i></a>qlmanage コマンド</h3>

<p>さて、<code>open</code> コマンドはダブルクリック操作を行えるコマンドでした。「がっつり見たいわけじゃなく少し確認したい」。そんなことを行える Mac の操作がありましたね。<a href="http://ja.wikipedia.org/wiki/Quick_Look" rel="nofollow noopener" target="_blank">QuickLook</a> というやつです。それをコマンドライン上から扱えたら便利ですよね。</p>

<ul>
<li>オプション</li>
</ul>

<p>主なオプションを挙げておきます。他にもまだあります。</p>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-r</td>
<td style="text-align: center">Generators list を強制的にリロードする</td>
</tr>
<tr>
<td style="text-align: center">-r <em>cache</em>
</td>
<td style="text-align: center">サムネイルキャッシュの削除</td>
</tr>
<tr>
<td style="text-align: center">-p <em>file</em>
</td>
<td style="text-align: center">
<em>file</em> を QuickLook でプレビューする</td>
</tr>
</tbody>
</table>

<p>おそらく多用するのは <code>-p</code> オプションだと思います。</p>

<ul>
<li>使用例</li>
</ul>

<p>GUI でいうところのカーソルを合わせて <code>Space</code> キーを押す操作です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ qlmanage -p file.txt
</pre></div></div>

<p>実行すると QuickLook で file.txt を閲覧できます。しかし、終了するとデバッグ用の文字が出力されます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ qlmanage -p file.txt
Testing Quick Look preview with files:
    file.txt
</pre></div></div>

<p>これは、もともとこのコマンドが QuickLook プラグイン作成者がデバックや作成の補助に使用するためのようです。</p>

<h2>
<span id="使い勝手を良くする" class="fragment"></span><a href="#%E4%BD%BF%E3%81%84%E5%8B%9D%E6%89%8B%E3%82%92%E8%89%AF%E3%81%8F%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>使い勝手を良くする</h2>

<p>先にソースを載せます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">op</span></div>
<div class="highlight"><pre><span></span><span class="k">function</span> op<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        open .
    <span class="k">else</span>
        open <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
    <span class="k">fi</span>
<span class="o">}</span>
</pre></div>
</div>

<p>やっていることは非常に単純です。引数がなければカレントディレクトリを開いて、ある場合はそれを開くというものです。<br>
もうひとつ、QuickLook です。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">alias.sh</span></div>
<div class="highlight"><pre><span></span><span class="nb">alias</span> <span class="nv">ql</span><span class="o">=</span><span class="s1">'qlmanage -p "$@" &gt;&amp; /dev/null'</span>
</pre></div>
</div>

<p><code>~/.bashrc</code> に書けばいいでしょう。<code>qlmanage</code> コマンドでプレビューします。その際に出力されるデバック情報を捨てています。ガッツリ見るなら <code>op</code> 少し見るなら <code>ql</code> でコマンドライン操作が使いやすくなるでしょう。</p>

<h1>
<span id="その他の-os-編" class="fragment"></span><a href="#%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE-os-%E7%B7%A8"><i class="fa fa-link"></i></a>その他の OS 編</h1>

<h3>
<span id="display-コマンド" class="fragment"></span><a href="#display-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89"><i class="fa fa-link"></i></a>display コマンド</h3>

<p>その他の OS で使用できる GUI 操作コマンドといえば、<code>display</code> コマンドです。<a href="http://www.imagemagick.org/script/index.php" rel="nofollow noopener" target="_blank">ImageMagick</a>から入手できます。ImageMagick は X Window システムでの画像の表示や対話的な画像操作を行なうパッケージです。<br>
幸運にも Mac 系でも使用できるのですが、Mac の場合ここでダウンロード・インストールするよりも、パッケージを利用した方がいいです。<br>
<a href="http://cactuslab.com/imagemagick/" class="autolink" rel="nofollow noopener" target="_blank">http://cactuslab.com/imagemagick/</a></p>

<ul>
<li>オプション</li>
</ul>

<p>あまりにも多いので <code>display -h</code> してください。</p>

<ul>
<li>使用例</li>
</ul>

<p>これで画像表示が行えます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ display picture.jpg
</pre></div></div>

<p>=========</p>

<p>その他 OS で利用する際にディレクトリを操るコマンドがないのが痛いところです。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />10位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>22</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/10ecb7b42baacfe8a29f">ルート権限かどうか調べる</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-24 20:50:18</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;">
<h1>
<span id="王道uid0-でチェック" class="fragment"></span><a href="#%E7%8E%8B%E9%81%93uid0-%E3%81%A7%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>王道！UID=0 でチェック</h1>

<p>「ルート権限かどうか調べる」を言い換えると、superuser かどうか調べるということ。それを知る律儀な方法は <code>UID (EUID)</code> が 0 かどうかのチェックです。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">check-root</span></div>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">[</span> <span class="si">${</span><span class="nv">EUID</span><span class="k">:-</span><span class="si">${</span><span class="nv">UID</span><span class="si">}}</span> <span class="o">=</span> <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s1">'I am root.'</span>
<span class="k">fi</span>
</pre></div>
</div>

<p>POSIX sh 互換で一番無難な書き方でしょう。</p>

<h1>
<span id="他にも" class="fragment"></span><a href="#%E4%BB%96%E3%81%AB%E3%82%82"><i class="fa fa-link"></i></a>他にも</h1>

<ul>
<li>whoami で調べる</li>
</ul>

<p>思いつきやすい例です。しかし、superuser (UID=0) のユーザ名が必ずしも "root" とは限らないので、万全ではありません。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">check-root</span></div>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">[</span> <span class="sb">`</span>whoami<span class="sb">`</span> <span class="o">=</span> <span class="s1">'root'</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s1">'I am root.'</span>
<span class="k">fi</span>
</pre></div>
</div>

<ul>
<li>id で調べる</li>
</ul>

<p>管理者の方でないと使わないようなコマンドの <code>id</code> ですが、これも上記の理由と同じで、"root" とは限りません（まあほとんどが "root" でしょうが）。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">check-root</span></div>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">[</span> <span class="nv">$UID</span> <span class="o">=</span> <span class="sb">`</span>id -u root<span class="sb">`</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s1">'I am root.'</span>
<span class="k">fi</span>
</pre></div>
</div>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />11位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>12</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/7b23099ec23d2354d8ec">bash で頻繁に利用するディレクトリをブックマークする</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-21 00:38:46</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[ShellScript]</b> <b>[Bash]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>コンソール上で開発をする人はお分かりだと思いますが、頻繁に利用するディレクトリが深い位置にあるとイライラしますよね。毎回タイプするわけにもいかないし、履歴をたどるにしても <code>git</code> などを利用しながら開発をしていると、簡単に埋もれてゆきます。ホームにシンボリックリンクを貼る、またはエイリアスを登録するなど解決法はありますが、数が増えると各所が汚れていきますし、スマートとはいえません。</p>

<p>そこで、以上を解決するスクリプトを作成しました。bash で動作するディレクトリ専用のブックマーカーです。<br>
シェルプログラミングの勉強を兼ねての作成なので、バグやコードの改善などがあればぜひ教えて下さい。</p>

<p><a href="https://camo.qiitausercontent.com/bef5c41954cd9438c7b5482dc0a7206cb4cfa927/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f65326334383834642d343930362d636563622d633331392d6236386562343838623732342e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/bef5c41954cd9438c7b5482dc0a7206cb4cfa927/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f65326334383834642d343930362d636563622d633331392d6236386562343838623732342e706e67" alt="main.png" title="main.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/e2c4884d-4906-cecb-c319-b68eb488b724.png"></a></p>

<h1>
<span id="ダウンロード" class="fragment"></span><a href="#%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89"><i class="fa fa-link"></i></a>ダウンロード</h1>

<p><a href="https://github.com/b4b4r07/bashmark" rel="nofollow noopener" target="_blank">b4b4r07/bashmark · GitHub</a></p>

<h1>
<span id="インストール" class="fragment"></span><a href="#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB"><i class="fa fa-link"></i></a>インストール</h1>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ git clone https://github.com/b4b4r07/bashmark.git
$ make install
</pre></div></div>

<p>スクリプトを有効化するには、シェルを再起動するか、bashrc を再読込する必要があります。</p>

<h1>
<span id="使い方" class="fragment"></span><a href="#%E4%BD%BF%E3%81%84%E6%96%B9"><i class="fa fa-link"></i></a>使い方</h1>

<p>スクリプトの初回起動の時に、ヘルプの表示の有無が聞かれます。</p>

<p><a href="https://camo.qiitausercontent.com/9b70f55adfd027872a6cd8e62be17a9d376f51e0/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f39336432363765362d623532302d633162302d643434382d6365316333663331616535382e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/9b70f55adfd027872a6cd8e62be17a9d376f51e0/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f39336432363765362d623532302d633162302d643434382d6365316333663331616535382e706e67" alt="help.png" title="help.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/93d267e6-b520-c1b0-d448-ce1c3f31ae58.png"></a></p>

<p>必要がなければ飛ばしてください（タイムアウトは3秒です）。もし後から見たい場合は、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ bashmark
</pre></div></div>

<p>とタイプすれば読むことができます。このコマンドは以下に挙げるコマンド名のそれぞれのヘルプを一括で表示するものなので、各項目ごとに見たい場合は、<code>COMMAND -h</code> もしくは <code>COMMAND --help</code> で OK です。</p>

<p>このスクリプトを読み込むと、以下のコマンドが使用できるようになります。</p>

<ul>
<li>show - 登録ブックマークの表示</li>
<li>reg - ブックマークの登録。引数を渡せばその名前で登録し、引数が無い場合はカレントディレクトリ名で登録します</li>
<li>go - 登録された引数名のディレクトリへ移動します</li>
<li>p - 登録された引数名のディレクトリのフルパスを表示します</li>
<li>del - 登録された引数名のディレクトリを登録リストから削除します。ディレクトリ自体は消えません</li>
</ul>

<h2>
<span id="show" class="fragment"></span><a href="#show"><i class="fa fa-link"></i></a>show</h2>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">効果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-h, --help</td>
<td style="text-align: center">ヘルプを表示する</td>
</tr>
<tr>
<td style="text-align: center">-p, --plane</td>
<td style="text-align: center">色を使わずにリストを表示する</td>
</tr>
</tbody>
</table>

<p><code>show</code> コマンドでリストを表示した時、登録名が黄色の時がありますが、それは新規登録（まだ <code>go</code> コマンドによる移動をしていない）だからです。1度利用すると、赤色に変わります。</p>

<p><a href="https://camo.qiitausercontent.com/eff628032c5454d4d14982eb53b4ae7b730740f7/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34303737303337362d666631622d363031642d326639642d6465393032316265663832652e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/eff628032c5454d4d14982eb53b4ae7b730740f7/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34303737303337362d666631622d363031642d326639642d6465393032316265663832652e706e67" alt="show.png" title="show.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/40770376-ff1b-601d-2f9d-de9021bef82e.png"></a></p>

<p>=====================================================</p>

<h2>
<span id="reg" class="fragment"></span><a href="#reg"><i class="fa fa-link"></i></a>reg</h2>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">効果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-h, --help</td>
<td style="text-align: center">ヘルプを表示する</td>
</tr>
<tr>
<td style="text-align: center">-t, --temp</td>
<td style="text-align: center">一時的に登録する</td>
</tr>
</tbody>
</table>

<p>引数があれば、その名前で登録します。無い場合は、ディレクトリ名で登録します。<br>
一時登録はいっかいきりしか使わないパスの登録に有効です。<code>show</code> で表示するとき、青色で表されます。</p>

<p><a href="https://camo.qiitausercontent.com/366d378d60c6b6d1aa405e6b639796bdfca8f10f/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f61633464656263392d653064302d383934302d363161372d3030393438643531643065662e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/366d378d60c6b6d1aa405e6b639796bdfca8f10f/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f61633464656263392d653064302d383934302d363161372d3030393438643531643065662e706e67" alt="reg.png" title="reg.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/ac4debc9-e0d0-8940-61a7-00948d51d0ef.png"></a></p>

<p>=====================================================</p>

<h2>
<span id="go" class="fragment"></span><a href="#go"><i class="fa fa-link"></i></a>go</h2>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">効果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-h, --help</td>
<td style="text-align: center">ヘルプを表示する</td>
</tr>
</tbody>
</table>

<p><code>go</code>、<code>p</code>、<code>del</code> コマンドでは、タブキーによる登録パス名の補完をサポートします。</p>

<p><a href="https://camo.qiitausercontent.com/e19b2660913e53518139f27b9366335bcd66b9f7/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34653062663636352d353963302d663364612d343032632d6436633863333735386564642e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/e19b2660913e53518139f27b9366335bcd66b9f7/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34653062663636352d353963302d663364612d343032632d6436633863333735386564642e706e67" alt="go.png" title="go.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/4e0bf665-59c0-f3da-402c-d6c8c3758edd.png"></a></p>

<p>=====================================================</p>

<h2>
<span id="p" class="fragment"></span><a href="#p"><i class="fa fa-link"></i></a>p</h2>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">効果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-h, --help</td>
<td style="text-align: center">ヘルプを表示する</td>
</tr>
</tbody>
</table>

<p>登録パスを表示するコマンドです。画像にも具体例がありますが、<code>cp</code> や <code>mv</code> などを利用する際パスを短く表現できます。</p>

<p><a href="https://camo.qiitausercontent.com/c568c08dd41a2ec12e3881739516f4e658531cc1/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34323835623165352d623938302d613331322d643530642d3033366539663262626362662e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/c568c08dd41a2ec12e3881739516f4e658531cc1/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34323835623165352d623938302d613331322d643530642d3033366539663262626362662e706e67" alt="p.png" title="p.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/4285b1e5-b980-a312-d50d-036e9f2bbcbf.png"></a></p>

<p>=====================================================</p>

<h2>
<span id="del" class="fragment"></span><a href="#del"><i class="fa fa-link"></i></a>del</h2>

<table>
<thead>
<tr>
<th style="text-align: center">オプション</th>
<th style="text-align: center">効果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-h, --help</td>
<td style="text-align: center">ヘルプを表示する</td>
</tr>
</tbody>
</table>

<p>複数まとめて削除もできます。</p>

<p><a href="https://camo.qiitausercontent.com/daf371432675ab59486a760643caabe4615331b5/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f65316332373431322d616636312d386331322d663063662d3164393037633763306666392e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/daf371432675ab59486a760643caabe4615331b5/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f65316332373431322d616636312d386331322d663063662d3164393037633763306666392e706e67" alt="del.png" title="del.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/e1c27412-af61-8c12-f0cf-1d907c7c0ff9.png"></a></p>

<h1>
<span id="変更履歴" class="fragment"></span><a href="#%E5%A4%89%E6%9B%B4%E5%B1%A5%E6%AD%B4"><i class="fa fa-link"></i></a>変更履歴</h1>

<p><strong>2013-09-25</strong><br>
・zsh に対応しました<br>
<a href="https://camo.qiitausercontent.com/e1f348b2101e0228d069e4a8fa27f7896d5549d0/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f38333339336638612d633666342d323934352d303830662d3462333930306364333564342e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/e1f348b2101e0228d069e4a8fa27f7896d5549d0/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f38333339336638612d633666342d323934352d303830662d3462333930306364333564342e706e67" alt="zsh.png" title="zsh.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/83393f8a-c6f4-2945-080f-4b3900cd35d4.png"></a></p>

<p><strong>2013-10-01</strong><br>
・zsh に非対応しました</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />12位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>9</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/1c0a432c3f3394109235">Git サードパーティ</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-22 00:26:46</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[Bash]</b> <b>[Git]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>Git（ギット）は、プログラムのソースコードなどの変更履歴を記録・追跡するための分散型バージョン管理システムです。</p>

<p><a href="https://camo.qiitausercontent.com/bfa0601f9dfc04863daacbb6c7b18455e86be801/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f652f65302f4769742d6c6f676f2e737667" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/bfa0601f9dfc04863daacbb6c7b18455e86be801/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f652f65302f4769742d6c6f676f2e737667" alt="git" data-canonical-src="http://upload.wikimedia.org/wikipedia/commons/e/e0/Git-logo.svg"></a></p>

<h1>
<span id="tig" class="fragment"></span><a href="#tig"><i class="fa fa-link"></i></a>tig</h1>

<p><a href="https://camo.qiitausercontent.com/2478408bc0a2301e5540dd9f2961563ab502e571/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f66356230643031622d663231322d353135392d333661372d3361636534613330363566612e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/2478408bc0a2301e5540dd9f2961563ab502e571/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f66356230643031622d663231322d353135392d333661372d3361636534613330363566612e706e67" alt="tig.png" title="tig.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/f5b0d01b-f212-5159-36a7-3ace4a3065fa.png"></a></p>

<p>Tig とは ncurses ベースの Git 専用のテキストユーザインタフェースのリポジトリブラウザです。<br>
Git リポジトリ内の変更内容などを、Vim ライクな操作で高速に閲覧することができます。</p>

<h2>
<span id="インストール" class="fragment"></span><a href="#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB"><i class="fa fa-link"></i></a>インストール</h2>

<ul>
<li>Mac OS X</li>
</ul>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">brew</span></div>
<div class="highlight"><pre><span></span>    $ brew install tig
</pre></div>
</div>

<p>または</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">MacPorts</span></div>
<div class="highlight"><pre><span></span>    $ sudo port install tig
</pre></div>
</div>

<ul>
<li>Ubuntu</li>
</ul>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">apt-get</span></div>
<div class="highlight"><pre><span></span>    $ sudo apt-get install tig
</pre></div>
</div>

<ul>
<li>その他</li>
</ul>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">manual</span></div>
<div class="highlight"><pre><span></span>    $ wget http://jonas.nitro.dk/tig/releases/tig-1.2.tar.gz
    $ tar -xvf tig-1.2.tar.gz <span class="o">&amp;&amp;</span> <span class="nb">cd</span> tig-1.2
    $ ./configure
    $ make
    $ sudo make install
</pre></div>
</div>

<h2>
<span id="使い方" class="fragment"></span><a href="#%E4%BD%BF%E3%81%84%E6%96%B9"><i class="fa fa-link"></i></a>使い方</h2>

<p>基本的に git が管理するディレクトリに移動して <code>tig</code> とタイプするだけです。<br>
テキストベースのリポジトリブラウザが起動します。</p>

<table>
<thead>
<tr>
<th style="text-align: center">ビューの切り替え</th>
<th style="text-align: center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">h</td>
<td style="text-align: center">ヘルプを表示する</td>
</tr>
<tr>
<td style="text-align: center">m</td>
<td style="text-align: center">メイン（tig 起動時の画面）を表示する</td>
</tr>
<tr>
<td style="text-align: center">d</td>
<td style="text-align: center">diff を表示する</td>
</tr>
<tr>
<td style="text-align: center">l</td>
<td style="text-align: center">log を表示する</td>
</tr>
<tr>
<td style="text-align: center">S</td>
<td style="text-align: center">status を表示する</td>
</tr>
<tr>
<td style="text-align: center">H</td>
<td style="text-align: center">branch を表示する</td>
</tr>
<tr>
<td style="text-align: center">t</td>
<td style="text-align: center">ファイルツリーを表示する</td>
</tr>
<tr>
<td style="text-align: center">g</td>
<td style="text-align: center">グラフを表示する</td>
</tr>
<tr>
<td style="text-align: center">q</td>
<td style="text-align: center">カレントビューを終了</td>
</tr>
<tr>
<td style="text-align: center">Q</td>
<td style="text-align: center">すべてのビューを閉じ、tig を終了</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th style="text-align: center">カーソル移動</th>
<th style="text-align: center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">j</td>
<td style="text-align: center">1行下へ移動</td>
</tr>
<tr>
<td style="text-align: center">k</td>
<td style="text-align: center">1行上へ移動</td>
</tr>
<tr>
<td style="text-align: center">Spase</td>
<td style="text-align: center">1ページ下へ移動</td>
</tr>
<tr>
<td style="text-align: center">b</td>
<td style="text-align: center">1ページ上へ移動</td>
</tr>
<tr>
<td style="text-align: center">Tab</td>
<td style="text-align: center">ペインを移動</td>
</tr>
<tr>
<td style="text-align: center">Ctrl-n</td>
<td style="text-align: center">次の項目へ移動</td>
</tr>
<tr>
<td style="text-align: center">Ctrl-p</td>
<td style="text-align: center">前の項目へ移動</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th style="text-align: center">検索</th>
<th style="text-align: center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">/</td>
<td style="text-align: center">カレントビュー内で下方検索する</td>
</tr>
<tr>
<td style="text-align: center">?</td>
<td style="text-align: center">カレントビュー内で上方検索する</td>
</tr>
<tr>
<td style="text-align: center">n</td>
<td style="text-align: center">次のヒット位置へ移動</td>
</tr>
<tr>
<td style="text-align: center">N</td>
<td style="text-align: center">前のヒット位置へ移動</td>
</tr>
</tbody>
</table>

<p>ほとんど Vim 操作なので、Vimmer の方は感覚的に使用できます。<br>
詳しくは <a href="http://jonas.nitro.dk/tig/manual.html" rel="nofollow noopener" target="_blank">The Tig Manual</a></p>

<p><a href="https://camo.qiitausercontent.com/efffcbcb0e4a97cefcb26ed1139d188a7f5719c5/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f65363836646164392d626661632d336133352d346465392d3031343332303364383962332e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/efffcbcb0e4a97cefcb26ed1139d188a7f5719c5/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f65363836646164392d626661632d336133352d346465392d3031343332303364383962332e706e67" alt="tig2.png" title="tig2.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/e686dad9-bfac-3a35-4de9-0143203d89b3.png"></a></p>

<p>S をタイプし、status ビューに切り替え、C をタイプすることでコミットを行うことができます。まだ他にも <code>tig</code> 上から様々な <code>git</code> のアクションが行えるので h キーでのヘルプ表示をおすすめします。</p>

<h1>
<span id="hub" class="fragment"></span><a href="#hub"><i class="fa fa-link"></i></a>hub</h1>

<p><a href="https://camo.qiitausercontent.com/a8b8d506fae015ba5151a0d5652b2c7ce090886b/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f622f62332f4769744875622e737667" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/a8b8d506fae015ba5151a0d5652b2c7ce090886b/687474703a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f622f62332f4769744875622e737667" alt="github" data-canonical-src="http://upload.wikimedia.org/wikipedia/commons/b/b3/GitHub.svg"></a></p>

<p>Git リポジトリのホスティングサービスとして、とても有名な GitHub ですが、毎回ウェブブラウザを起動していてはパフォーマンスが低下しますよね。<br>
その名の通り hub コマンドは、Mac や Linux のターミナルから GitHub の操作をおこなうためのコマンドです。通常はブラウザを通しておこなっているような操作を CLI でおこなうことができます。</p>

<h2>
<span id="インストール-1" class="fragment"></span><a href="#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB-1"><i class="fa fa-link"></i></a>インストール</h2>

<ul>
<li>Mac OS X</li>
</ul>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">brew</span></div>
<div class="highlight"><pre><span></span>    $ brew install hub
</pre></div>
</div>

<p>または</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">MacPorts</span></div>
<div class="highlight"><pre><span></span>    $ sudo port install hub
</pre></div>
</div>

<ul>
<li>その他</li>
</ul>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">standalone</span></div>
<div class="highlight"><pre><span></span>$ curl http://hub.github.com/standalone -sLo ~/bin/hub <span class="o">&amp;&amp;</span> chmod +x ~/bin/hub
</pre></div>
</div>

<h2>
<span id="設定" class="fragment"></span><a href="#%E8%A8%AD%E5%AE%9A"><i class="fa fa-link"></i></a>設定</h2>

<p><code>hub</code> コマンドは <code>git</code> コマンドのように続けてサブコマンドを打ちながら利用しますが、一貫性を持たせるため以下の設定をすることで、<code>hub &lt;sub-command&gt;</code> を <code>git &lt;sub-command&gt;</code> で利用する事ができます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">~/.{ba,z}shrc</span></div>
<div class="highlight"><pre><span></span><span class="k">function</span> git<span class="o">(){</span>hub <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span><span class="o">}</span>    <span class="c1"># zsh</span>
<span class="nb">eval</span> <span class="s2">"</span><span class="k">$(</span>hub <span class="nb">alias</span> -s<span class="k">)</span><span class="s2">"</span>      <span class="c1"># bash</span>
</pre></div>
</div>

<h2>
<span id="使い方-1" class="fragment"></span><a href="#%E4%BD%BF%E3%81%84%E6%96%B9-1"><i class="fa fa-link"></i></a>使い方</h2>

<h3>
<span id="hub-create---リモートリポジトリの作成" class="fragment"></span><a href="#hub-create---%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%81%AE%E4%BD%9C%E6%88%90"><i class="fa fa-link"></i></a>hub create - リモートリポジトリの作成</h3>

<p>リモートリポジトリを CLI から作成する場合 git リポジトリの中からでしか作成できないため、あらかじめディレクトリを作成し <code>git init</code> で管理下に置きましょう。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">create</span></div>
<div class="highlight"><pre><span></span>tester@~$ mkdir git_dir
tester@~$ <span class="nb">cd</span> git_dir
tester@~/git_dir$ git init 
Initialized empty Git repository in /Users/tester/git_dir/.git/
tester@~/git_dir$ hub create
github.com username: b4b4r07
github.com password <span class="k">for</span> b4b4r07 <span class="o">(</span>never stored<span class="o">)</span>: 
Updating origin
Identity added: /Users/tester/.ssh/github_id_rsa <span class="o">(</span>/Users/tester/.ssh/github_id_rsa<span class="o">)</span>
created repository: b4b4r07/git_dir
tester@~/git_dir$ 
</pre></div>
</div>

<p><a href="https://camo.qiitausercontent.com/8d30cc0987e69632788485bbd6612144ae162af9/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34633533333831622d333066302d363963352d643039632d3266646365663537646434632e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/8d30cc0987e69632788485bbd6612144ae162af9/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f32393738372f34633533333831622d333066302d363963352d643039632d3266646365663537646434632e706e67" alt="git_dir.png" title="git_dir.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/29787/4c53381b-30f0-69c5-d09c-2fdcef57dd4c.png"></a></p>

<p>作成されているのがわかります。</p>

<h3>
<span id="リポジトリをブラウザで確認する" class="fragment"></span><a href="#%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%82%92%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%A7%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>リポジトリをブラウザで確認する</h3>

<p>サードパーティを駆使すれば必要なこともないですが、念の為に。。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ hub browse
</pre></div></div>

<p>この場合、カレントの git リポジトリをウェブブラウザで確認できます。リポジトリを指定する場合は</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ hub browse &lt;user/repo&gt;
</pre></div></div>

<p>で確認するできます。</p>

<h3>
<span id="クローンを作成する" class="fragment"></span><a href="#%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%B3%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>クローンを作成する</h3>

<p>ふだん使用する <code>git clone https://github.com/b4b4r07/bashmark.git</code> を <code>hub clone b4b4r07/bashmark</code> で出来ます。タイプ量が減るので単純にラクできます。</p>

<h2>
<span id="要チェック" class="fragment"></span><a href="#%E8%A6%81%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF"><i class="fa fa-link"></i></a>要チェック</h2>

<p><a href="https://github.com/github/hub/blob/master/README.md" rel="nofollow noopener" target="_blank">hub/README.md</a></p>

<h1>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h1>

<p>今回挙げたサードパーティは、</p>

<ul>
<li>tig</li>
<li>hub</li>
</ul>

<p>の2つのコマンドでした。どちらも CLI git ライフを豊かにするものなので、是非活用してください。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />13位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>8</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/9013e19ba47fd07e87b5">MacVim をコマンドラインから起動する</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-21 18:07:29</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[Vim]</b> <b>[ShellScript]</b> <b>[Bash]</b> <b>[Mac]</b> <b>[MacOSX]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>MacVim を起動するときコマンドラインから、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ open -a MacVim
</pre></div></div>

<p>と、やりますよね（おそらく）。<br><br>
このままエイリアスでもいいのですが、もう少し勝手を良くしようというのが今回の趣旨です。</p>

<h2>
<span id="gvim-関数を作成" class="fragment"></span><a href="#gvim-%E9%96%A2%E6%95%B0%E3%82%92%E4%BD%9C%E6%88%90"><i class="fa fa-link"></i></a>gvim 関数を作成</h2>

<p>エイリアスには限界があるので、関数化しましょう。環境は <code>bash</code> とします。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">gvim.sh</span></div>
<div class="highlight"><pre><span></span>    gvim<span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
            open -a MacVim
        <span class="k">else</span>
            open -a MacVim <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
        <span class="k">fi</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="o">}</span>
</pre></div>
</div>

<p>素直に、引数がなければ起動するだけ、あれば引数を渡して終了。なのですが、<code>MacVim</code> は、存在しないファイルが渡された時、CUI のように新規作成してはくれません。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ gvim myfile
The file /Users/tester/myfile does not exist.
exit 1
</pre></div></div>

<p>新規作成の機能を実装しましょう。<br><br>
複数ファイルに対応する前に、とりあえず引数は1つしか取れないとしておきます。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">gvim.sh</span></div>
<div class="highlight"><pre><span></span>     <span class="m">1</span>: gvim<span class="o">()</span> <span class="o">{</span>
     <span class="m">2</span>:     <span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
     <span class="m">3</span>:         open -a MacVim
     <span class="m">4</span>:     <span class="k">elif</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">1</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
     <span class="m">5</span>:         <span class="k">if</span> <span class="o">[</span> ! -f <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
     <span class="m">6</span>:             touch <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">||</span> <span class="k">return</span> <span class="m">1</span>
     <span class="m">7</span>:         <span class="k">fi</span>
     <span class="m">8</span>:         open -a MacVim <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
     <span class="m">9</span>:     <span class="k">else</span>
    <span class="m">10</span>:         <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">: invalid arguments"</span>
    <span class="m">11</span>:         <span class="k">return</span> <span class="m">1</span>
    <span class="m">10</span>:     <span class="k">fi</span>
    <span class="m">11</span>:     <span class="k">return</span> <span class="m">0</span>
    <span class="m">12</span>: <span class="o">}</span>
</pre></div>
</div>

<p>5-7行目です。ファイルがない場合、作成しています。<code>Permission denied</code> などで作成できなかった場合のための処理も加えました。<br><br>
これで一応は機能します。しかし、ちょっとしたバグが潜んでいます。それは、gvim に <code>myfile2</code> という新規ファイルを渡したいとき、間違って <code>myfile1</code> の新規ファイル名で渡したとします。<code>:q</code> などで　Vim を終了した時、カレントディレクトリには <code>myfile1</code> が作られたままになってしまうのです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ ls
Desktop/    Documents/
$ gvim myfile1                      # ミス。myfile2だった。vim を終了させる
$ ls
Desktop/    Documents/  myfile1     # myfile1 は存在していてほしくない
</pre></div></div>

<p>この対処をしましょう。</p>

<h2>
<span id="ファイルサイズが０ならば終了後に消す" class="fragment"></span><a href="#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%8C%EF%BC%90%E3%81%AA%E3%82%89%E3%81%B0%E7%B5%82%E4%BA%86%E5%BE%8C%E3%81%AB%E6%B6%88%E3%81%99"><i class="fa fa-link"></i></a>ファイルサイズが０ならば、終了後に消す</h2>

<p>作成したファイルに何も書き込まれず（ファイルサイズが０）終了したのなら、そのファイルはミスだったと判断していいものとしました。</p>

<div class="code-frame" data-lang="bash">
<div class="code-lang"><span class="bold">gvim.sh</span></div>
<div class="highlight"><pre><span></span>     <span class="m">1</span>: gvim<span class="o">()</span> <span class="o">{</span>
     <span class="m">2</span>:     <span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
     <span class="m">3</span>:         open -a MacVim
     <span class="m">4</span>:     <span class="k">elif</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">1</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
     <span class="m">5</span>:         <span class="k">if</span> <span class="o">[</span> ! -f <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
     <span class="m">6</span>:             touch <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">||</span> <span class="k">return</span> <span class="m">1</span>
     <span class="m">7</span>:         <span class="k">fi</span>
     <span class="m">8</span>:         touch -t <span class="k">$(</span> date -v+1S +<span class="s1">'%Y%m%d%H%M'</span> <span class="k">)</span> ~/.compare
     <span class="m">9</span>:         open -a MacVim <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="o">{</span>
    <span class="m">10</span>:             sleep <span class="m">0</span>.2
    <span class="m">11</span>:             <span class="k">if</span> <span class="o">[</span> ~/.compare -ot <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="m">12</span>:                 <span class="o">[</span> ! -s <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> rm <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
    <span class="m">13</span>:             <span class="k">fi</span>
    <span class="m">14</span>:             rm ~/.compare
    <span class="m">15</span>:         <span class="o">}</span>
    <span class="m">16</span>:     <span class="k">else</span>
    <span class="m">17</span>:         <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">: invalid arguments"</span>
    <span class="m">18</span>:         <span class="k">return</span> <span class="m">1</span>
    <span class="m">19</span>:     <span class="k">fi</span>
    <span class="m">20</span>:     <span class="k">return</span> <span class="m">0</span>
    <span class="m">21</span>: <span class="o">}</span>
</pre></div>
</div>

<p>これで実装完了です。以下解説。<br><br>
少し特殊な動きをしているのが、8行目からです。<code>touch</code> コマンドで時刻指定をし、最新のファイル <code>~/.compare</code> を作成します。そして、<code>$1</code> と比較（11行目）をし、<code>~/.compare</code> のほうが古かったら、なおかつファイルサイズが0だったら削除するというようにしました。<br><br>
なぜ、こんな回りくどい方法かというと、単純にファイルサイズ0にすると、もともとあったファイルサイズ0ファイルがこの <code>gvim</code> 関数で開いただけで、削除されるという恐ろしいことになるからです。<br><br>
それにしても周りくどいような気がします。もっとエレガントに書けるなら教えてください。</p>

<p>あとは、エイリアスをはるなり、以下のように</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ gvim myfile
</pre></div></div>

<p>実行するなりで使用できます。</p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>b4b4r07さんの<br />14位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>7</kbd>
		<a target="_blank" href="https://qiita.com/b4b4r07/items/6f0ac4c5ae3edc10ce3a">Mac の Vim (CUI) でクリップボードを有効化する</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-21 15:05:10</center>
	</td>
	<td style="width:200px;">
		@b4b4r07<br><img width="80" height="80" src="https://qiita-image-store.s3.amazonaws.com/0/29787/profile-images/1473685392">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[Vim]</b> <b>[Mac]</b> <b>[MacOSX]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>Mac (Mac OS X Mountain Lion 10.8) の Vim は標準状態ではクリップボードが有効化されていません。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ vim --version
VIM - Vi IMproved 7.3 (2010 Aug 15, compiled Oct 23 2012 13:50:52)
Compiled by root@apple.com
Normal version without GUI.  Features included (+) or not (-):
-arabic +autocmd -balloon_eval -browse +builtin_terms +byte_offset +cindent 
-clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments 
-conceal +cryptv +cscope +cursorbind +c
...
...
</pre></div></div>

<p><code>-clipboard</code> というようにマイナスが付いていては、クリップボードは使用できません。</p>

<h2>
<span id="vim-をインストールし直す" class="fragment"></span><a href="#vim-%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%97%E7%9B%B4%E3%81%99"><i class="fa fa-link"></i></a>Vim をインストールし直す</h2>

<p>とりあえずソースから、ということで。今回は homebrew を使用します。</p>

<h3>
<span id="hg-コマンドをインストール" class="fragment"></span><a href="#hg-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB"><i class="fa fa-link"></i></a>hg コマンドをインストール</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ brew install hg
</pre></div></div>

<h3>
<span id="vim-をインストール" class="fragment"></span><a href="#vim-%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB"><i class="fa fa-link"></i></a>vim をインストール</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ hg clone https://vim.googlecode.com/hg/ /tmp/vim
$ cd /tmp/vim
$ make clean
$ ./configure --prefix=/usr/local --enable-multibyte --enable-xim --enable-fontset --enable-rubyinterp --enable-perlinterp --with-features=huge --disable-selinux --enable-pythoninterp --with-python-config-dir=/usr/lib/python2.7/config
$ make
$ make install
</pre></div></div>

<p>2〜3分待てば完了するはず。<code>configure</code> に与えるものは各人が必要な物を指定してください。<br><br>
今回は <code>/usr/local</code> 以下にインストールしました。おそらくデフォルトでは、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ which vim
/usr/bin/vim
</pre></div></div>

<p>となっているので、以降PATHの順番を変えたり、いっそエイリアスなどで直接指定してやってください。</p>

<h3>
<span id="clipboard-を確認" class="fragment"></span><a href="#clipboard-%E3%82%92%E7%A2%BA%E8%AA%8D"><i class="fa fa-link"></i></a>+clipboard を確認</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$ /usr/local/bin/vim --version | grep clipboard
+clipboard       +iconv           +path_extra      -toolbar
+eval            +mouse_dec       +startuptime     -xterm_clipboard
</pre></div></div>

<p>完了です。</p>
</div>
	</td>
</tr>
</table>
<br />
	</body>
</html>
