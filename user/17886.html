<html>
	<head><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110075493-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110075493-1');
</script>
<!-- Google AdSense -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6168511236629369",
    enable_page_level_ads: true
  });
</script>

		<meta charset="UTF-8" />
		<title>Qiita Ranking (KDKTN)</title>
		<link rel="stylesheet" type="text/css" href="../qranking.css">
	</head>
	<body>
<div class="headerContainer">
<h1>Qiitaいいね数ランキング (KDKTN さんの投稿分)</h1>
</div><!--class="headerContainer"-->
<p><a href="#" onclick="javascript:window.history.back(-1);return false;">[戻る]</a></p>
<p><i><img width="16" height="16" src="../thumb-up-120px.png" /></i>が同じ値の場合は投稿日時の新しいものが上位としています。</p>
<p><i><img width="16" height="16" src="../thumb-up-120px.png" /></i>がついていない記事は表示していません。</p>
<table border="1">
<tr>
	<td rowspan="3"><center>KDKTNさんの<br />1位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>1069</kbd>
		<a target="_blank" href="https://qiita.com/KDKTN/items/4c6986049d204f0645d8">コールバック……駆逐してやる…この世から…一匹…残らず!!</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-08-16 19:12:28</center>
	</td>
	<td style="width:200px;">
		@KDKTN<br />(私立リリアン女学園高等部 所属)<br><img width="80" height="80" src="https://pbs.twimg.com/profile_images/3438615386/d591fae08d7433a2149c04ff8995ceec_normal.png">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[JavaScript]</b> <b>[Haskell]</b> <b>[jQuery]</b> <b>[TypeScript]</b> <b>[async]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。</p>

<ul>
<li>コールバック地獄</li>
<li>jQuery.Deferred</li>
<li>async.js</li>
<li>Concurrent.Thread</li>
<li>generators</li>
<li>co</li>
<li>fibers</li>
<li>Web Workers</li>
</ul>

<p>(※なぜか『進撃の巨人』の一部ネタバレが含まれるので注意してください)</p>

<h2>
<span id="それは何故人はコールバックするのかという話でしょうか" class="fragment"></span><a href="#%E3%81%9D%E3%82%8C%E3%81%AF%E4%BD%95%E6%95%85%E4%BA%BA%E3%81%AF%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B%E3%81%AE%E3%81%8B%E3%81%A8%E3%81%84%E3%81%86%E8%A9%B1%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%81%8B"><i class="fa fa-link"></i></a>それは『何故人はコールバックするのか』という話でしょうか？</h2>

<p>非同期処理って面倒ですよね。JavaScriptではいわゆる <strong>コールバック地獄</strong> というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 <code>get</code> があるとしたら、次のように書けるはずです。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>
</pre></div></div>

<p>でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 <code>fs.readFileSync</code> がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 <code>$.get</code> を使ったとしても、素直に書くと次のような悲惨なことになるわけです。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">hoge</span><span class="p">){</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">piyo</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>        
    <span class="p">});</span>
<span class="p">});</span>
</pre></div></div>

<p>もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="c1">// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">hoge</span><span class="p">){</span>    

<span class="c1">// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">piyo</span><span class="p">){</span>

<span class="c1">// どうみても var nyan = $.get("nyan.txt") ですね</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"nyan.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nyan</span><span class="p">){</span>

<span class="c1">// var myon = $.get("myon.txt") のどこにコールバックが？</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"myon.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">myon</span><span class="p">){</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span> <span class="o">+</span> <span class="nx">nyan</span> <span class="o">+</span> <span class="nx">nyan</span><span class="p">);</span>        




<span class="p">});});});});</span> <span class="c1">// ←見なかったことにしよう！(＾o＾)b</span>
</pre></div></div>

<p>JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。</p>

<h2>
<span id="有害なコールバックを駆除したたまたまjquerydeferredと恰好が似ていただけだ" class="fragment"></span><a href="#%E6%9C%89%E5%AE%B3%E3%81%AA%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%82%92%E9%A7%86%E9%99%A4%E3%81%97%E3%81%9F%E3%81%9F%E3%81%BE%E3%81%9F%E3%81%BEjquerydeferred%E3%81%A8%E6%81%B0%E5%A5%BD%E3%81%8C%E4%BC%BC%E3%81%A6%E3%81%84%E3%81%9F%E3%81%A0%E3%81%91%E3%81%A0"><i class="fa fa-link"></i></a>有害なコールバックを駆除した!!たまたまjQuery.deferredと恰好が似ていただけだ!!</h2>

<p>こうした非同期処理の煩雑さを解決するために実に数多くの手段が考えだされてきましたが、その手段は大きくわけて２つあると思います。</p>

<ul>
<li>ネストが深くならないように、コールバックの構造を変形する(jQuery.Deferred, async.js など)</li>
<li>スレッド/ファイバー/コルーチンで処理の流れを複数つくり、同期処理する(generators, fibers, Web Workers など)</li>
</ul>

<p>前者の方法はあくまで非同期処理であり、現在の JavaScript でも実現可能な方法です。現在ごく一般的に行われているコールバックを駆使する方法の延長線上にあるので比較的理解しやすいでしょう。ただし解決は部分的であることがほとんどで、同期処理ほどの読みやすいコードが実現できることは稀です。</p>

<p>それに対し、後者の方法は現在の JavaScript 環境にまったく新しい機能を追加し同期処理できるようにするというものなので、非同期処理にまつわる煩雑さはほとんど解決しますが、使える環境がまだまだ限られることがほとんどです。また、これまで同期処理ができなかった部分が同期処理できるようになったとしても、その同期処理どうしが並列に処理されるというような複雑なケースも発生しうることがあり、同期処理と非同期処理が混在していてもわかりやすくコントロールする手段はやはり必要になります。</p>

<p>本テキストでは主に前者のカテゴリの手段についてどのようなものであるかを検討していきます。ただし、後者の手段を以ってしも非同期処理の煩雑さは残されることがあり、そういった残された問題をどう解決するかも含めて包括的に検討していきます。</p>

<p>まずは前者のカテゴリの手段を幾つか見ていきましょう。JavaScript の有名なライブラリといえば jQuery はまっさきに挙げられるもののひとつですが、jQuery にもこうした非同期処理の煩雑さを解消しようとする機能、 <a href="http://api.jquery.com/category/deferred-object/" rel="nofollow noopener" target="_blank">jQuery.deferred</a> があります。ちまたで話題の jQuery.deferred を使えば、さっきみたいなネスト地獄のコードもきっとおしゃれに書けるはず……！</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span><span class="p">;</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">_hoge</span><span class="p">){</span>
        <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">_hoge</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">piyo</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>        
    <span class="p">});</span>
</pre></div></div>

<p>えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。</p>

<p>は◯ブのほうで『 jQuery.deferred の例のコードがキモいのは、お前の使い方が悪いだけじゃね？』（意訳）という声を見かけたので、もう少し詳しく検討してみます。jQuery.deferred の圧倒的実力を見せつけてやろうではないですか。</p>

<p>上記の例では、<code>$.get("hoge.txt")</code> の結果が <code>then</code> のコールバックの引数 <code>hoge</code> に渡されてくるわけなのですが、このコールバックを抜けるから <code>hoge</code> にアクセスできなくなって、いったん外の変数に退避しなければならなくなったわけでした。したがって、これを抜ける前に続けて <code>$.get("piyo.txt")</code> の結果のほうまで受け取ってしまえばいいのではないでしょうか。コードは次のようになります。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">_hoge</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">piyo</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>
        <span class="p">});;</span>
    <span class="p">});</span>
</pre></div></div>

<p>無駄な退避用の変数がなくなりました！……  <strong>って、これさっきのコールバック地獄じゃないですか</strong> 。使うファイルが増えるとどんどんネストが深くなっていきます。コールバック地獄を逃れようとして jQuery.deferred にすがったのに、これではあんまり意味がありません。</p>

<p>まだだ……まだ終わらんよ……！あの jQuery がこの程度の実力なわけがない！そうだ！最後にまとめてそれぞれの結果にアクセスしようとするのが良くないのでしょう。このように順番に処理していく場合、直前の処理から受け取れるのは基本的に１個まで。今回の目的だととにかく最終的に全部つながった文字列が得られればいいのだから、それぞれの <code>$.get</code> が終わったその時点で、それまでの文字列を積算してしまえばいいのです。つまり、あらたに次のような Deferred を作る関数 <code>accum</code> を定義しましょう。他人に与えられた deferred を使うだけなんて素人のやること、オリジナル Deferred を作ってこそ真の jQuery 使いといえます。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">accum</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">previous</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
        <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
            <span class="nx">def</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">previous</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="nx">def</span><span class="p">.</span><span class="nx">promise</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum</span><span class="p">(</span><span class="s2">"pyon.txt"</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum</span><span class="p">(</span><span class="s2">"nyan.txt"</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>

</pre></div></div>

<p>よし、これで OK! ネストも深くなっていかない！素晴らしい！……え？今度は piyo.txt のテキストだけ、全部大文字にしてくれだって？<code>accum</code> ではそんな処理はできません。じゃあまた新たにファイルを読み込んでそれを大文字にする deferred を定義して……。</p>

<p>め　ん　ど　く　さ　い。同期処理なら <code>hoge + piyo.toUpperCase() + pyon + nyan</code> で済むのに、なんでちょっと処理が変わるたびに新たな deferred を定義しなければならないのでしょうか。じゃ、じゃあ、全部配列にして送ってしまえばいい！</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">accum2</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">array</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
        <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
            <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
            <span class="nx">def</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="nx">def</span><span class="p">.</span><span class="nx">promise</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">def</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
<span class="nx">def</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum2</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum2</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum2</span><span class="p">(</span><span class="s2">"pyon.txt"</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">accum2</span><span class="p">(</span><span class="s2">"nyan.txt"</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">array</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">});</span>
<span class="nx">def</span><span class="p">.</span><span class="nx">resolve</span><span class="p">([]);</span>
</pre></div></div>

<p><strong>って配列かよ！</strong> hoge とか piyo とかの名前はどこにいったんだよ！<code>array[3]</code> とか言われてもどのファイルの中身なのかさっぱりわからんよ！ちゃんと意味のあるデータを適当に配列に突っ込んじゃいけないって、プログラミング初めて習った時に口酸っぱくいわれたよ！</p>

<p>そうか、直列に処理するからいけないんだ。<code>$.when</code> を使って並列に処理すれば……。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">),</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">)).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">hoge</span><span class="p">,</span> <span class="nx">piyo</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">});</span>
</pre></div></div>

<p>うーん。さっきよりはずっとマシになったかな。なんで結果の <code>hoge</code> と <code>piyo</code> が配列になってるの？<code>[0]</code>とかなんなん？というのはまあ目をつぶるとして、<code>$.get("hoge")</code> と <code>hoge</code> がやけに離れた位置になってしまいました。同期的に書いていた時には <code>var hoge = get("hoge");</code> みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">),</span> 
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">),</span> 
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"nyan.txt"</span><span class="p">),</span>   <span class="c1">// 増えた</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"myon.txt"</span><span class="p">),</span>   <span class="c1">// 増えた</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"pong.txt"</span><span class="p">),</span>   <span class="c1">// 増えた</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"chun.txt"</span><span class="p">)</span>    <span class="c1">// 増えた</span>
<span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span>
    <span class="nx">hoge</span><span class="p">,</span> 
    <span class="nx">piyo</span><span class="p">,</span>
    <span class="nx">nyan</span><span class="p">,</span>   <span class="c1">// 増えた</span>
    <span class="nx">pong</span><span class="p">,</span>   <span class="c1">// 増えた</span>
    <span class="nx">myon</span><span class="p">,</span>   <span class="c1">// 増えた</span>
    <span class="nx">chun</span>    <span class="c1">// 増えた</span>
<span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nyan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">pong</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">myon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">chun</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">});</span>
</pre></div></div>

<p>これだとうっかり非同期処理とその結果を代入する変数の順番を間違えるようなこともありそうです。上記のコード、実は <code>myon</code> と <code>pong</code> の変数の順序が入れ替わっています。お気付きになったでしょうか。気付くわけないですよね。</p>

<p>これが同期的だったら、次にように一行づつ編集して増やせるのに……。非同期処理とその結果を代入する変数が一行ごとにまとまっているので、jQuery.Deferred のものより遥かに読みやすく書きやすいと思います。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">nyan</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"nyan.txt"</span><span class="p">);</span>  <span class="c1">// 増えた</span>
<span class="kd">var</span> <span class="nx">pong</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"pong.txt"</span><span class="p">);</span>  <span class="c1">// 増えた</span>
<span class="kd">var</span> <span class="nx">myon</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"myon.txt"</span><span class="p">);</span>  <span class="c1">// 増えた</span>
<span class="kd">var</span> <span class="nx">chun</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"chun.txt"</span><span class="p">);</span>  <span class="c1">// 増えた</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span> <span class="o">+</span> <span class="nx">nyan</span> <span class="o">+</span> <span class="nx">pong</span> <span class="o">+</span> <span class="nx">myon</span> <span class="o">+</span> <span class="nx">chun</span><span class="p">);</span>
</pre></div></div>

<p>また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので <code>$.when</code> で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。</p>

<p>いろいろ検討してみましたが、ネストを増やさずに、しかもなるべく自然にそれぞれの非同期処理の結果にアクセスしようとすると、結局のところ外の変数に退避するのが一番手っ取り早いように思いました。もし何かもっといい方法があったら教えて下さい。自分には jQuery.deferred は使いこなせませんでした。でも俺が敗れ去っても、第二、第三の jQuery.deferred 使いが現れ、その真の実力を引き出してくれるでしょう。きっと。</p>

<h2>
<span id="asyncjsは調子に乗りすぎたいつか私が然るべき報いを" class="fragment"></span><a href="#asyncjs%E3%81%AF%E8%AA%BF%E5%AD%90%E3%81%AB%E4%B9%97%E3%82%8A%E3%81%99%E3%81%8E%E3%81%9F%E3%81%84%E3%81%A4%E3%81%8B%E7%A7%81%E3%81%8C%E7%84%B6%E3%82%8B%E3%81%B9%E3%81%8D%E5%A0%B1%E3%81%84%E3%82%92"><i class="fa fa-link"></i></a>async.jsは調子に乗りすぎた……いつか私が然るべき報いを</h2>

<p>非同期処理のフローを制御するライブラリとしては、<a href="https://github.com/caolan/async#parallel" rel="nofollow noopener" target="_blank">async.js</a> というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
        <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span> <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nx">async</span><span class="p">.</span><span class="nx">parallel</span><span class="p">({</span>
    <span class="nx">hoge</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">),</span>
    <span class="nx">piyo</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">)</span>
<span class="p">},</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">results</span><span class="p">.</span><span class="nx">piyo</span><span class="p">);</span>
<span class="p">});</span>
</pre></div></div>

<p><code>parallel</code> は <code>jQuery.when</code> と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて <code>results</code> というオブジェクトにまとめられてるのはまあ許すとして、なんといっても <code>hoge: get("hoge.txt")</code> っていうかんじで <code>hoge</code> と <code>get("hoge.txt")</code> がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">){</span>
        <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span> <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nx">async</span><span class="p">.</span><span class="nx">parallel</span><span class="p">({</span>
    <span class="nx">hoge</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">),</span>
    <span class="nx">piyo</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">),</span>
    <span class="nx">nyan</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"nyan.txt"</span><span class="p">),</span>  <span class="c1">// 増えた</span>
    <span class="nx">pong</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"pong.txt"</span><span class="p">),</span>  <span class="c1">// 増えた</span>
    <span class="nx">myon</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"myon.txt"</span><span class="p">),</span>  <span class="c1">// 増えた</span>
    <span class="nx">chun</span><span class="o">:</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"chun.txt"</span><span class="p">)</span>   <span class="c1">// 増えた</span>
<span class="p">},</span>
<span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">.</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">results</span><span class="p">.</span><span class="nx">piyo</span> <span class="o">+</span> <span class="nx">results</span><span class="p">.</span><span class="nx">nyan</span> <span class="o">+</span> <span class="nx">results</span><span class="p">.</span><span class="nx">pong</span> <span class="o">+</span> <span class="nx">results</span><span class="p">.</span><span class="nx">myon</span> <span class="o">+</span> <span class="nx">results</span><span class="p">.</span><span class="nx">chun</span><span class="p">);</span>
<span class="p">});</span>
</pre></div></div>

<p>だがちょっとまってほしい。<code>async.parallel</code> の型ってどうなっているんだろう？『 <strong>はあ!?なにいってんのおまえ!?</strong> 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は動的型の JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。JavaScriptのようなヒトならざる魔性なら、他者の辛苦を蜜の味とするのも頷けます。でも、それは罪人の魂です。罰せられるべき悪徳です。</p>

<p>じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">var</span> <span class="nx">$</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">get</span><span class="p">(</span><span class="nx">path</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">callback</span><span class="o">:</span> <span class="p">(</span><span class="nx">data</span>: <span class="kt">string</span><span class="p">)</span><span class="o">=&gt;</span><span class="k">void</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">hoge</span>: <span class="kt">string</span><span class="p">){</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">piyo</span>: <span class="kt">string</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>        
    <span class="p">});</span>
<span class="p">});</span>
</pre></div></div>

<p>ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。<code>$.when</code> に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に <code>[data, textStatus, jqXHR]</code> という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。</p>

<p>それに対して、先ほどの <code>async.parallel</code> の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。</p>

<h2>
<span id="俺にはわかるconcurrentthreadは本物の化け物だコールバックとは無関係になどんな力で押さえようともどんな檻に閉じこめようともコイツの意識を服従させることは誰にもできない" class="fragment"></span><a href="#%E4%BF%BA%E3%81%AB%E3%81%AF%E3%82%8F%E3%81%8B%E3%82%8Bconcurrentthread%E3%81%AF%E6%9C%AC%E7%89%A9%E3%81%AE%E5%8C%96%E3%81%91%E7%89%A9%E3%81%A0%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%81%A8%E3%81%AF%E7%84%A1%E9%96%A2%E4%BF%82%E3%81%AB%E3%81%AA%E3%81%A9%E3%82%93%E3%81%AA%E5%8A%9B%E3%81%A7%E6%8A%BC%E3%81%95%E3%81%88%E3%82%88%E3%81%86%E3%81%A8%E3%82%82%E3%81%A9%E3%82%93%E3%81%AA%E6%AA%BB%E3%81%AB%E9%96%89%E3%81%98%E3%81%93%E3%82%81%E3%82%88%E3%81%86%E3%81%A8%E3%82%82%E3%82%B3%E3%82%A4%E3%83%84%E3%81%AE%E6%84%8F%E8%AD%98%E3%82%92%E6%9C%8D%E5%BE%93%E3%81%95%E3%81%9B%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E8%AA%B0%E3%81%AB%E3%82%82%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>俺にはわかる、Concurrent.Threadは本物の化け物だ……『コールバック』とは無関係にな。どんな力で押さえようとも、どんな檻に閉じこめようとも、コイツの意識を服従させることは誰にもできない……！</h2>

<p><a href="http://sourceforge.net/apps/mediawiki/jsthread/index.php?title=Main_Page" rel="nofollow noopener" target="_blank">Concurrent.Thread</a> はJavaScriptで擬似的なマルチスレッドを実現するライブラリです。このライブラリでも <code>yield</code> ができるようですから、コールバック地獄の回避にも応用できそうです。どのようにして擬似的なマルチスレッドを実現しているかというと、JavaScript のソースコードをパースしてぶつ切りにし、setTimeout で適宜制御を譲りながら交互に実行することで擬似的なスレッドを構成するというもの。その発想がないわけではなかったが、まさか本当にやるとは思わなかった、という感想しかでてこない豪快な方法です。Web 上にはあまり情報がありませんが、作者自身による解説記事 <a href="http://www.infoq.com/jp/articles/js_multithread_2" rel="nofollow noopener" target="_blank">JavaScriptによるマルチスレッドの実現‐Concurrent.Threadの裏側</a> が参考になります。</p>

<p>Web 上で閲覧できるサンプルとしては<a href="http://jsdo.it/__gfx__/thread-example/" rel="nofollow noopener" target="_blank">Concurrent.Thread example</a>があります。一応Concurrent.Threadが吐き出したコードも眺めてみましたが、とてもヒトに理解できるコードではなかったので内部の理解は諦めました。なんかもうそこまでするなら、俺ならベースの言語として JavaScript じゃなくて静的型付けできる他の言語をベースに選ぶけど……。</p>

<p>環境を選ばずどこでも使えるのはメリットです。独自の形式に変換するので、デバッガがまともに使えないことが最大の欠点でしょうか。トラブルが起きた時の原因究明は絶望的です。JavaScript のパースも行うので、JavaScript の新しい機能は使えないでしょう。残念ながら、更新も止まっているようです。すごいライブラリには違いないのですが、あくまで研究用だと思っておくのがよさそうです。</p>

<h2>
<span id="私の特技はコールバックを削ぎ落とすことです必要に迫られればいつでも披露します私のgeneratorsを体験したい方がいればどうぞ一番先に近づいて来てください" class="fragment"></span><a href="#%E7%A7%81%E3%81%AE%E7%89%B9%E6%8A%80%E3%81%AF%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%82%92%E5%89%8A%E3%81%8E%E8%90%BD%E3%81%A8%E3%81%99%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E5%BF%85%E8%A6%81%E3%81%AB%E8%BF%AB%E3%82%89%E3%82%8C%E3%82%8C%E3%81%B0%E3%81%84%E3%81%A4%E3%81%A7%E3%82%82%E6%8A%AB%E9%9C%B2%E3%81%97%E3%81%BE%E3%81%99%E7%A7%81%E3%81%AEgenerators%E3%82%92%E4%BD%93%E9%A8%93%E3%81%97%E3%81%9F%E3%81%84%E6%96%B9%E3%81%8C%E3%81%84%E3%82%8C%E3%81%B0%E3%81%A9%E3%81%86%E3%81%9E%E4%B8%80%E7%95%AA%E5%85%88%E3%81%AB%E8%BF%91%E3%81%A5%E3%81%84%E3%81%A6%E6%9D%A5%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84"><i class="fa fa-link"></i></a>私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください</h2>

<p>さて、ここからは JavaScript に根本的に機能を追加して解決をはかる手段です。これらは同期的な処理を複数同時に行う、つまりマルチスレッディングを可能にしようというものですが、マルチスレッドもいくつかの種類にわけられます。</p>

<ol>
<li>メモリ空間を共有し、プリエンプティブに実行される古典的マルチスレッド</li>
<li>プリエンプティブに実行されるがメモリ空間を完全に分離する『プロセス』</li>
<li>メモリ空間を共有し、各スレッドが独自の判断で制御を譲る協調的マルチスレッド</li>
</ol>

<p>1 は効率よく実行できるので昔からよく使われてきましたが、デッドロックなどマルチスレッド特有の問題が多く発生しやすく非常に扱いが難しいので近年では直接使われることが少なくなっているように思います。Java や C# などにあるスレッドはこれで、排他制御をしそこねると非常にわかりにくいバグになります。</p>

<p>2 は安全に複数のスレッドを実行できるのでもうすぐ JavaScript にも Web Workers という形で導入されることが決まっています。Erlang などにも『プロセス』として言語に組み込まれていることで知られていますし、OS レベルで提供されるプロセス間通信もこれに近いものです。ただし、プロセス間でデータを直接共有できないので、プロセス同士のメッセージングが煩雑になったり効率が悪化しやすいです。</p>

<p>3 は generators として JavaScript にも導入される予定で、各スレッド(?)でデータを共有でき比較的安全で軽量である反面、各スレッドが独自の判断で制御を交代するのでスレッドの流れについてよく把握しておかないとうまくコードを書くことができません。</p>

<p>また、いずれの方法を取るにしろそれぞれのスレッドがまったく独立して動くわけではないので、常に同期処理と非同期処理をうまく混在させていかなくてはなりません。マルチスレッドを導入して同期処理が増えていったしても、非同期処理がなくなるわけではないのです。以下のいくつかの項ではかつて非同期に処理してきたものを同期で処理する方法を示しますが、その同期処理どうしをどのように並列して非同期に協調させるかということについてはほとんど述べられていません。そのような残された非同期処理については、先ほど触れた jQuery.deferred や async.js のようなフレームワークを利用して解決していくことになるでしょう。</p>

<p>まずは次期の JavaScript で導入される <strong><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" rel="nofollow noopener" target="_blank">generators</a></strong> という機能をみていきます。generator があれば、 <strong>yield</strong> というキーワードを使って次のように書けるようになるみたいです(<code>get</code> は generator で使えるように適当に定義されているものとします)。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">generator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>
<span class="p">})();</span>
<span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</pre></div></div>

<p>このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 <strong>それが完了したら</strong> piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">generator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="nx">yield</span><span class="p">;</span>
    <span class="nx">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">()</span> <span class="o">+</span> <span class="nx">y</span><span class="p">());</span>
<span class="p">})();</span>
<span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</pre></div></div>

<p>並列で処理した結果を受け取るためにちょっと工夫しています。<code>get</code> は関数を返すようになっていて、この関数は <code>yield</code> から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。</p>

<p>直列、並列いずれについても <code>generator</code> という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、<code>get</code> にいちいち <code>generator</code> を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。</p>

<p>他に気をつけるべき点としては、 <code>yield</code> の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く <code>yield</code> を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと <code>y()</code> が <code>undefined</code> になってしまいます。非同期処理ひとつにたいして <code>yield</code> ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。</p>

<p>かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。</p>

<h2>
<span id="我々はgeneratorsによってコールバックの侵攻を阻止するのみならずgenerators-の正体にたどり着くすべを獲得した" class="fragment"></span><a href="#%E6%88%91%E3%80%85%E3%81%AFgenerators%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%81%AE%E4%BE%B5%E6%94%BB%E3%82%92%E9%98%BB%E6%AD%A2%E3%81%99%E3%82%8B%E3%81%AE%E3%81%BF%E3%81%AA%E3%82%89%E3%81%9Agenerators-%E3%81%AE%E6%AD%A3%E4%BD%93%E3%81%AB%E3%81%9F%E3%81%A9%E3%82%8A%E7%9D%80%E3%81%8F%E3%81%99%E3%81%B9%E3%82%92%E7%8D%B2%E5%BE%97%E3%81%97%E3%81%9F"><i class="fa fa-link"></i></a>我々はgeneratorsによってコールバックの侵攻を阻止するのみならず、generators の正体にたどり着くすべを獲得した！</h2>

<p>さて、さきほどの generators の使い方についての表面的なコードを見て、なんとなく <code>yield</code>というキーワードを使えばいいことぐらいはわかったと思います。他の人が書いてくれたライブラリをありがたくダウンロードしてサンプルコードをコピペ、ちょっといじって実行してみてなんかエラーになったら詳しそうな先輩や同僚に見てもらって……っていう感じならそのくらいの理解でもいいのですが、自分でgeneratorsを使って同期的な仕組みを実装したくなる時もあるでしょう。それに、先ほどのコード、<code>yield get(...)</code> というような部分が何度かあるのが気になりませんでしたか？共通する部分があるなら、次のように関数としてまとめたくなりますよね。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">hyperGet</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">generator</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">yield</span> <span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>  <span class="c1">// 常にyieldもくっついているすごいgetだ！</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">generator</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="o">*</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">hyperGet</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">hyperGet</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>
<span class="p">})();</span>
<span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</pre></div></div>

<p>でもこのコードはうまく動きません。なぜなのでしょうか。これを理解するには、<code>yield</code> というキーワードの意味をちゃんと理解する必要があるのです。せっかくですから、generators の動作についても詳しく説明しておきます。generators は今後の非同期処理の主流になるはず。この知識はきっと無駄にならないと思いますが、面倒くさいひとは別に読まずに飛ばしてしまっていいと思います。他の手段について知りたい者は解散したまえ。……では今、ここを読んでいるものを新たな調査兵団として迎え入れます。よく恐怖に耐えてくれた。君たちは勇敢な戦士です。</p>

<p>Firefox Nightly で動く generators の完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに <code>setTimeout</code> で非同期な処理をしているつもりにしています。<code>&lt;any&gt;</code> に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。<code>yield</code> は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って <code>function*(){ ... }</code> っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、Firefox における generators の実装は現在提案されているものとは異なるということです。危なかった……もしこのアスタリスクが必要だったら、それが邪魔して TypeScript で書けなくなるところでした。このアスタリスクは正直要らない子だと俺も思います。 ポイントは <code>yield</code>、<code>next</code>、<code>send</code> です。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">yield</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="o">:</span> <span class="p">()</span><span class="o">=&gt;</span><span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">Generator</span> <span class="p">{</span>
    <span class="nx">send</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
    <span class="nx">next</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">var</span> <span class="nx">StopIteration</span>: <span class="kt">new</span><span class="p">()</span><span class="o">=&gt;</span><span class="k">void</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">path</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">generator</span>: <span class="kt">Generator</span><span class="p">)</span><span class="o">:</span> <span class="p">()</span><span class="o">=&gt;</span><span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span> 
        <span class="k">try</span><span class="p">{</span>
            <span class="nx">value</span> <span class="o">=</span> <span class="s2">"[content: "</span> <span class="o">+</span> <span class="nx">path</span> <span class="o">+</span> <span class="s2">"]"</span><span class="p">;</span>            
            <span class="nx">generator</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="nx">e</span> <span class="k">instanceof</span> <span class="nx">StopIteration</span><span class="p">))</span> <span class="k">throw</span> <span class="nx">e</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">()</span><span class="o">=&gt;</span><span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">generator</span>: <span class="kt">Generator</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span> <span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="c1">// 直列バージョン</span>
    <span class="kd">var</span> <span class="nx">x</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">yield</span><span class="p">(</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">));</span>
    <span class="kd">var</span> <span class="nx">y</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">yield</span><span class="p">(</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">));</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

    <span class="c1">// 並列バージョン</span>
    <span class="kd">var</span> <span class="nx">w</span><span class="o">:</span> <span class="p">()</span><span class="o">=&gt;</span><span class="kt">string</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">z</span><span class="o">:</span> <span class="p">()</span><span class="o">=&gt;</span><span class="kt">string</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">,</span> <span class="nx">generator</span><span class="p">);</span>
    <span class="nx">yield</span><span class="p">;</span>
    <span class="nx">yield</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">w</span><span class="p">()</span> <span class="o">+</span> <span class="nx">z</span><span class="p">());</span>
<span class="p">})();</span>
<span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
</pre></div></div>

<p>(1) まずは <code>var generator: Generator = &lt;any&gt; (()=&gt;{ ... })();</code> という無名関数の部分です。無名関数 <code>()=&gt;{ ... }</code> を直後に <code>()</code> で呼び出す<a href="http://d.hatena.ne.jp/shunsuk/20110824/1314190913" rel="nofollow noopener" target="_blank">即時関数パターン</a>になっていますが、そこは別にどうでもいいです。最初のポイントは、 <strong>この関数呼び出しで、この関数自身が呼び出されるわけじゃなくて、なぜか <code>Generator</code> オブジェクトが作成されて返ってくる</strong> ことです。これはこの無名関数の本体に <code>yield</code> が含まれているからです。なんだかよくわかりませんがそういうものです。</p>

<p>(2) その <code>Generator</code> オブジェクトが変数 <code>generator</code> に代入されます。 <strong>ここで <code>generator.next</code> を呼び出していますが、このときさっきの無名関数が呼び出されます</strong> 。意味がわかりませんが、そういうものです。</p>

<p>(3) この無名関数の一行目は <code>var x: string = yield(get("hoge.txt", generator));</code> となっています。ここで generatos で導入された新しいキーワード <code>yield</code>が出てきますが、ひとまずそのまま素直に <code>yield</code> の隣の式を実行します。<code>get("hoge.txt", generator)</code> という式なので、<code>get</code> 関数の定義に飛びます。<code>generator</code> を引数で渡していることにも注目です。</p>

<p>(4) <code>get</code> 関数の中身は <code>setTimeout</code> の呼び出しだけです。これが非同期処理の開始にあたります。非同期処理を開始しただけで今はとくに何もしません。500 ミリ秒後にタイマーをセットして終了です。この関数の返り値は並列処理するときに非同期処理の結果を受け取るためのトリックなので気にしないでください。<code>get</code> 関数を脱出します。</p>

<p>(5) さて、無名関数に戻ってくると、<code>get</code> 関数の返り値がまるで <code>yield</code> という関数に渡されているように見えます。でもこの <code>yield</code> が曲者です。 <strong>ここを実行しようとすると、なぜかさっきの (2) での <code>generator.next</code> の呼び出しが終了し、そこに戻ります。</strong> 実はまたココにあとで戻ってきます。<code>return</code> で抜けだしたらそこで終了なのに対して、 <code>yield</code> で逃げ出したらいつかまたそこに戻ってくるのです。</p>

<p>(6) なぜか (2) の <code>generator.next</code> の呼び出しが終了しました。さて、ここでスクリプトの最後に到達したので、一旦実行は終了です。</p>

<p>(7) ブラウザが一休みしているところで、さっき仕掛けた <code>setTimeout</code> 時限爆弾がついに起動します！これはつまり非同期処理の終了です。<code>setTimeout</code> で渡した方の無名関数に飛びます。</p>

<p>(8) try/catch とその次の代入式はひとまず無視して、 <strong>次にあるのは <code>generator.send(value)</code> です。これが実行されると、先ほど戻ってくると宣言した <code>yield</code> の位置に戻ります。<code>yield</code> で抜けだしたら、次の <code>next</code> や <code>send</code> で戻ってくるというのがポイントです。しかも、戻ってくるときに <code>send</code> に渡した引数を持ち帰って <code>yield</code> に戻ってきます。</strong> このサンプルコードでは、ファイルの中身を模して <code>"[content: hoge.txt]"</code> という文字列を返すようにしています。</p>

<p>(9) <strong><code>yield</code> に戻ってきたら、<code>yield(...)</code> という式の値が先ほど <code>send</code> に渡した値になります。</strong> そのため、この値が <code>hoge</code> に代入されるのです。<code>get</code> がファイルを取ってくる非同期処理だったら、<code>x</code> に hoge.txt の中身が代入されることになります。</p>

<p>(10) ここまでの (3) ～ (9) が  <code>var x: string = yield(get("hoge.txt", generator));</code> という行が引き起こす結果です。この次もほぼ同じような <code>var y: string = yield(get("piyo.txt", generator));</code> という式ですから、(3) ～ (9) のような処理がもう一回行われます。その結果、<code>y</code> にも piyo.txt の中身が読み込まれます。</p>

<p>(11) 最後に <code>console.log(x + y);</code> でふたつのファイルの中身が結合されて出力されます。</p>

<p>(12) この無名関数の終端まで到達すると、さきほどの <code>send</code> の呼び出しに戻ります。戻ると言っても、<code>send</code> で <code>StopIteration</code> という例外が起こったという形で戻ってきます。そのため、try/catch でこの例外を補足します。これは異常な状態というよりは、generators では generator の実行の通常の終了を示す例外なので、そのままもみ消してしまって構いません。それ以外の種類の例外はもみ消しては困るので、<code>instanceof</code> で判別して投げ直します。</p>

<p>generators の動作がつかめてきたでしょうか。ポイントをまとめると、次のようになります。</p>

<ul>
<li>yield が含まれた関数を呼び出すと、<code>Generator</code> オブジェクトが作成される</li>
<li>その <code>Generator</code> オブジェクトの <code>next</code> を呼び出すと、さっきの関数が実行が開始される</li>
<li>
<code>yield</code> に到達すると、直前に呼んだ <code>next</code> や <code>send</code> が終了する</li>
<li>
<code>next</code> や <code>send</code> を呼び出すと、最後に到達した <code>yield</code> に戻ってくる</li>
<li>関数の終端まで到達すると StopIteration が発生する</li>
</ul>

<p>こうやって通常の実行のコンテキストと generator のコンテキストを行き来して、マルチスレッドのような動作を実現しているのです。こんな奇妙な動作は従来の JavaScript ではどうやっても不可能です。これが generators の魔術なのです。</p>

<p>generators の用途は非同期処理だけではありません。このテキストでは触れませんが、調べてみるともっと面白い使い方がほかにもたくさん見つかると思います。</p>

<h2>
<span id="彼の持つcoとgeneratorsが組み合わさればこの街の奪還も不可能ではありません-人類の栄光を願いこれから死に行くせめてもの間にcoの戦術的価値を説きます" class="fragment"></span><a href="#%E5%BD%BC%E3%81%AE%E6%8C%81%E3%81%A4co%E3%81%A8generators%E3%81%8C%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%95%E3%82%8C%E3%81%B0%E3%81%93%E3%81%AE%E8%A1%97%E3%81%AE%E5%A5%AA%E9%82%84%E3%82%82%E4%B8%8D%E5%8F%AF%E8%83%BD%E3%81%A7%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%9B%E3%82%93-%E4%BA%BA%E9%A1%9E%E3%81%AE%E6%A0%84%E5%85%89%E3%82%92%E9%A1%98%E3%81%84%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E6%AD%BB%E3%81%AB%E8%A1%8C%E3%81%8F%E3%81%9B%E3%82%81%E3%81%A6%E3%82%82%E3%81%AE%E9%96%93%E3%81%ABco%E3%81%AE%E6%88%A6%E8%A1%93%E7%9A%84%E4%BE%A1%E5%80%A4%E3%82%92%E8%AA%AC%E3%81%8D%E3%81%BE%E3%81%99"><i class="fa fa-link"></i></a>彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!</h2>

<p>generator を利用したもっと格好いいライブラリには <a href="https://github.com/visionmedia/co" rel="nofollow noopener" target="_blank">co</a> というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">co</span><span class="p">(</span><span class="kd">function</span> <span class="o">*</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">get</span><span class="p">(</span><span class="s1">'http://google.com'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">get</span><span class="p">(</span><span class="s1">'http://yahoo.com'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">get</span><span class="p">(</span><span class="s1">'http://cloudup.com'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
<span class="p">})</span>

<span class="nx">co</span><span class="p">(</span><span class="kd">function</span> <span class="o">*</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s1">'http://google.com'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s1">'http://yahoo.com'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s1">'http://cloudup.com'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">];</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">})</span>
</pre></div></div>

<p>なんと！これまであった問題点がだいたい解決しています。co を知ってしまった今では、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は <code>get</code> にも Generator を渡す必要があると思っていたのですが、うまいことやると <code>get("hoge.txt")</code> みたいなコードだけで実現できるようです。<code>yield [a, b, c]</code> というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうですが……？どうなっているのかはまだよくわかりませんが、とにかく凄そうです。将来の非同期処理の大本命と言っていいでしょう。</p>

<h2>
<span id="fibersです調理場に丁度頃合のものがあったのでつい" class="fragment"></span><a href="#fibers%E3%81%A7%E3%81%99%E8%AA%BF%E7%90%86%E5%A0%B4%E3%81%AB%E4%B8%81%E5%BA%A6%E9%A0%83%E5%90%88%E3%81%AE%E3%82%82%E3%81%AE%E3%81%8C%E3%81%82%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%A7%E3%81%A4%E3%81%84"><i class="fa fa-link"></i></a>fibersです！調理場に丁度頃合のものがあったので！つい！</h2>

<p>Node 環境に限っては、<a href="https://github.com/laverdet/node-fibers" rel="nofollow noopener" target="_blank">fibers</a> を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fibers を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">Fiber</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'wait... '</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
    <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'ok... '</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">run</span><span class="p">();</span>
</pre></div></div>

<p>構文としては申し分なく、generators と並んでこれまで見てきた中ではもっとも扱いやすいもののひとつといえるでしょう。でも現実は非情で、もちろんブラウザではまったく使えません……。それに generatos が正式に導入されたら fibers はお払い箱になってしまう可能性が高いと思います。</p>

<h2>
<span id="あのぅみなさん上官の食糧庫からweb-workers盗ってきました後でみなさんで分けましょうスライスしてパンに挟んでむふふ" class="fragment"></span><a href="#%E3%81%82%E3%81%AE%E3%81%85%E3%81%BF%E3%81%AA%E3%81%95%E3%82%93%E4%B8%8A%E5%AE%98%E3%81%AE%E9%A3%9F%E7%B3%A7%E5%BA%AB%E3%81%8B%E3%82%89web-workers%E7%9B%97%E3%81%A3%E3%81%A6%E3%81%8D%E3%81%BE%E3%81%97%E3%81%9F%E5%BE%8C%E3%81%A7%E3%81%BF%E3%81%AA%E3%81%95%E3%82%93%E3%81%A7%E5%88%86%E3%81%91%E3%81%BE%E3%81%97%E3%82%87%E3%81%86%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9%E3%81%97%E3%81%A6%E3%83%91%E3%83%B3%E3%81%AB%E6%8C%9F%E3%82%93%E3%81%A7%E3%82%80%E3%81%B5%E3%81%B5"><i class="fa fa-link"></i></a>あのぅ、みなさん……。上官の食糧庫から、Web Workers盗ってきました……。後でみなさんで分けましょう。スライスしてパンに挟んで…むふふ…。</h2>

<p>Web Workers はブラウザのような環境でマルチスレッドを実現する API です。これは fiber のような協調的マルチスレッドではなくて本当のマルチスレッドなので、 yield で時々処理を譲るということも必要ありません。まだ Working Draft の段階の仕様ですが最近の PC のブラウザなら大抵実装されていますし、Node 環境でも Web Worker の API を実装したものもあるようです。</p>

<p><a href="http://www.w3.org/TR/FileAPI/" rel="nofollow noopener" target="_blank">File API</a> には非同期 API のほかに同期API があって、Worker スレッド内で<code>FileReaderSync</code> を使えばブラウザのスレッドをブロックすることなく同期的にファイル操作をすることができます。Web Workers はマルチスレッドといっても、Web Workers の空間とブラウザの空間は完全に分離されていて、Worker とブラウザのスレッドの間はやはり非同期の API でやりとりすることになります。Worker スレッド側では <code>window</code> や <code>console</code> オブジェクトすらないので、Worker スレッドで処理した結果を出力するには <code>postMessage</code> でブラウザ側に結果を送り返し、ブラウザ側で <code>console.log</code> を呼び出します。Worker スレッド内で完結する処理であればとてもきれいに書けますが、頻繁にブラウザと Worker の間でやりとりがある場合は結局のところ非同期処理が多くなり、コールバックも増えてきます。ブラウザ側の処理と Worker 側の処理をどれだけうまく分離できるかが鍵になるでしょう。</p>

<p>Worker 内では XMLHttpRequest も使えます。ファイルをふたつ読み取り、結合して出力するサンプルは次のようになります。</p>

<div class="code-frame" data-lang="js">
<div class="code-lang"><span class="bold">app.js</span></div>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s2">"worker.js"</span><span class="p">);</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>

<div class="code-frame" data-lang="js">
<div class="code-lang"><span class="bold">worker.js</span></div>
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"GET"</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="nx">postMessage</span><span class="p">(</span><span class="nx">hoge</span> <span class="o">+</span> <span class="nx">piyo</span><span class="p">);</span>
</pre></div>
</div>

<p>worker.js 側の処理は同期で書けてとてもきれいです。Web Workers は並列処理のためのフレームワークを提供するものではありませんから、例えばふたつのファイルを並行して読み込んで両方の完了を待つ場合はなにか別のライブラリを使うことになるでしょう。また、Web Workers が登場したのは比較的最近で、時間のかかる処理はそれまで非同期処理が基本でしたから、同期と非同期両方が用意してある API はそれほど多くありません。同期 API が用意されていない場合は、Web Workers では解決できませんから、また別の手段を考慮する必要があります。</p>

<p>また、どうしても気になるのはやはり静的型付け(いやまあ、そんなこと気にしてるのは俺だけですけど)。Worker 内ではもちろんきれいに型付けできますが、メッセージングに関しては <code>postMessage</code> というたった一本のパイプであらゆるデータをやりとりするわけで、もちろんここには静的型付けなんて望むべくもありません。<code>onmessage</code> で飛んでくるデータはいったい何なのかはさっぱりわからないので、やはりメッセージングの回数をどこまで減らせるかがポイントでしょう。</p>

<p>あと現時点の実際上の問題として、ブラウザでは Worker スレッドのデバッグができないというものがあります。代わりに <a href="https://code.google.com/p/fakeworker-js/" rel="nofollow noopener" target="_blank">fakeworker.js</a> で WebWorkers をシミュレートしてデバッグする方法はあります。</p>

<h2>
<span id="調査兵団に入ってとにかくコールバックをぶっ殺したいです" class="fragment"></span><a href="#%E8%AA%BF%E6%9F%BB%E5%85%B5%E5%9B%A3%E3%81%AB%E5%85%A5%E3%81%A3%E3%81%A6%E3%81%A8%E3%81%AB%E3%81%8B%E3%81%8F%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF%E3%82%92%E3%81%B6%E3%81%A3%E6%AE%BA%E3%81%97%E3%81%9F%E3%81%84%E3%81%A7%E3%81%99"><i class="fa fa-link"></i></a>調査兵団に入って……とにかくコールバックをぶっ殺したいです……！</h2>

<p>いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>       <span class="c1">// get でファイルを ajax で持ってくる</span>
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">hoge</span><span class="p">,</span> <span class="nx">piyo</span><span class="p">));</span>      <span class="c1">// concat で結合、log で出力</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">main</span><span class="p">);</span>                                     <span class="c1">// run で実際に実行される</span>
</pre></div></div>

<p>こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span> 
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span>
    <span class="nx">hoge</span><span class="p">,</span>
    <span class="nx">piyo</span><span class="p">,</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">hoge</span><span class="p">,</span> <span class="nx">piyo</span><span class="p">))</span>
<span class="p">);</span>
</pre></div></div>

<p><code>masync.run</code> は引数に与えた処理を直列に順番に実行していく関数です。<code>hoge</code> は式のなかに２回出てきますが、この時本当に２回非同期処理を行うのか、それとも先に出現した方だけ実行し２回目の評価では結果だけ再利用するかをオプションで選択できます。<del>式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。</del>変数の宣言と初期化の位置が離れてしまう問題は多分解決しました。 でも『AをBより先に実行したい』という場合は『Bを実行するためにAの結果が必要』という場合が多いので、直列な操作を直接記述することはさほど多くはないでしょう。このライブラリで自然に書いていけば、直列に処理しなければならない部分は直列に、そうでない部分は並列に自動的に処理してくれます。</p>

<p>少々不思議なのは、<code>masync.get</code> を呼び出しても、その非同期な処理の結果が実際に使われることがないのなら、その非同期処理は行われないということです。たとえば、</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hoge</span><span class="p">);</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">main</span><span class="p">);</span>
</pre></div></div>

<p>とすると <code>masync.log</code> で実際に出力しているのは hoge.txt の中身だけなので、piyo.txt への get は実際には行われません。『不要な操作は省略』というのも自動的にやってくれるのです。</p>

<p>同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">nyan</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">hoge</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">hoge</span><span class="p">,</span> <span class="nx">nyan</span><span class="p">));</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">main</span><span class="p">);</span>
</pre></div></div>

<p>これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。</p>

<p>先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すればすぐに次の処理に進む、という処理を実現する関数 <code>sooner</code> もあります。以下のコードで、piyo.txt より hoge.txt のほうがずっと大きいファイルなら、 piyo.txt の読み込みのほうが早く終わるので piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"piyo.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">sooner</span><span class="p">(</span><span class="nx">hoge</span><span class="p">,</span> <span class="nx">piyo</span><span class="p">));</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">main</span><span class="p">);</span>
</pre></div></div>

<p>とはいえ、直列、並列(全部完了まで待つ)、並列(ひとつ終わるまで待つ)といった柔軟なコントロールフローが自在に記述できるのが便利だと思います。たとえば、あるファイルを読み込んでそれをすぐに出力する、という処理を行う関数 <code>getAndLog</code> を次のように簡単に定義できます。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">getAndLog</span> <span class="o">=</span> <span class="nx">path</span> <span class="o">=&gt;</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span>
</pre></div></div>

<p><code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> をそれぞれ  a.txt、b.txt、c.txt、d.txt を非同期に読み込んで出力する処理だとしましょう。<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> は <code>getAndLog</code> を使って次のように定義できます。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">getAndLog</span><span class="p">(</span><span class="s2">"a.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">getAndLog</span><span class="p">(</span><span class="s2">"b.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">getAndLog</span><span class="p">(</span><span class="s2">"c.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">getAndLog</span><span class="p">(</span><span class="s2">"d.txt"</span><span class="p">);</span>
</pre></div></div>

<p>そして、<code>a</code> と並行して、<code>b</code> と <code>c</code> を直列にしたものを行い、そのあとで <code>d</code> を行う、というかなり複雑なコントロールをしたいという場合でも、次のようにとても自然に書けます。<code>masync.seq</code> および <code>masync.parallel</code> はそれぞれ直列処理、並列処理を明示的に行うときに使う関数です。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">parallel</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">seq</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)),</span>
    <span class="nx">d</span>
<span class="p">);</span>
</pre></div></div>

<p>シーケンス図で描けば、例えばこんな処理になります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>  =====================================&gt; 時間
a ---------&gt;
b ----------------&gt;
c                  ---&gt;
d                      ------------&gt;
</pre></div></div>

<p>ファイルの get だけでなく、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず <code>"hoge"</code> と出力し、1秒待機してから、そのあと <code>"piyo"</code> と出力します。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"hoge"</span><span class="p">),</span>    <span class="c1">// "hoge" と出力</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">wait</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>     <span class="c1">// 1秒待機</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"piyo"</span><span class="p">)</span>     <span class="c1">// "piyo" と出力</span>
<span class="p">);</span>
</pre></div></div>

<p>jQuery.deferred と相互にデータを交換する機能もつけときました。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
        <span class="nx">masync</span><span class="p">.</span><span class="nx">strcat</span><span class="p">(</span>
            <span class="c1">//  fromPromise で Promise を masync のデータ型に変換</span>
            <span class="nx">masync</span><span class="p">.</span><span class="nx">fromPromise</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"a.txt"</span><span class="p">)),</span>   
            <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"d.txt"</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="c1">// masync.log のような一部の関数は Promise を直接受け取って処理できる</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"a.txt"</span><span class="p">)));</span>

<span class="c1">// toPromise で masync のデータ型を Promise に変換</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">toPromise</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"b.txt"</span><span class="p">)).</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">));</span>
</pre></div></div>

<p>ついでに Node の <code>fs.readFile</code> にもアクセスできるようにしときました。同期的に処理してるっぽくみえますが、同期 API のほうの <code>fs.readFileSync</code> ではなく、あくまで非同期版の <code>fs.readFile</code> をラップしています。ちなみに、引数の最後にコールバックを渡すという例の Node の非同期処理の規約に従った関数を masync の非同期処理に変換する関数も定義してありますので、それを使えば比較的簡単にほかの Node の API もラップできるはずです。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s2">"a.txt"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s2">"b.txt"</span><span class="p">);</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">masync</span><span class="p">.</span><span class="nx">strcat</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)));</span>
</pre></div></div>

<p>エラー処理も簡単です。一番簡単には、非同期処理の失敗時に別の値を返すようにする <code>recover</code> 関数を使うことができます。以下のコードで、<code>findFile</code> は指定したパスのファイルを <code>get</code> しますが、ファイルが取得できない場合は "Error: No such file: notexistsfile.txt" のようなメッセージを代わりに返します。ついでにいうと、こんなふうに非同期処理を関数としてまとめることもまったく問題ありません。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">findFile</span><span class="p">(</span><span class="nx">path</span>: <span class="kt">string</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">recover</span><span class="p">(</span><span class="s2">"Error: No such file: "</span> <span class="o">+</span> <span class="nx">path</span><span class="p">,</span>
        <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">findFile</span><span class="p">(</span><span class="s2">"a.txt"</span><span class="p">)),</span>                <span class="c1">// a.txt のファイルの中身が出力される</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">findFile</span><span class="p">(</span><span class="s2">"noexistfile.txt"</span><span class="p">))</span>   <span class="c1">// "Error: No such file: notexistsfile.txt" と出力される</span>
<span class="p">);</span>
</pre></div></div>

<p>ある程度の簡単な処理ならコールバックを使わずに書けるのですが、もっと複雑な処理を行いたければ非同期で取得したデータに直接アクセスする必要も出てくるでしょう。そのための方法は幾つかあるのですが、比較的に直感的に理解しやすい方法として <code>eject</code> という関数を用意してあります。この関数の最初の引数に <code>get</code> などの返り値、第2引数に直接のデータを受け取る関数を渡すと、その関数に直接のデータが渡されます。このライブラリでも、生のデータにアクセスしようとするとついにコールバックが露呈します。</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="nx">masync</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"hoge.txt"</span><span class="p">);</span> <span class="c1">// hoge は string ではない</span>
<span class="nx">masync</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span>
    <span class="nx">masync</span><span class="p">.</span><span class="nx">eject</span><span class="p">(</span><span class="nx">hoge</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="p">})</span> <span class="c1">// data は hoge.txt の中身。typeof data == "string"</span>
<span class="p">);</span>
</pre></div></div>

<p>このライブラリの特徴としては、以下のようなことが挙げられます。</p>

<ul>
<li>簡単な処理であればコールバックを完全に排除できる</li>
<li>同期処理っぽい見た目で書ける</li>
<li>TypeScript でガッチガチに静的型付けされていてる</li>
<li>どんな環境でも動く</li>
<li>非同期なデータの操作を簡単に定義できる</li>
</ul>

<p>特に、静的型付けされていることは大きなメリットで、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。こんなやたら長い記事をここまで読んできた方ならうっすら気付いていると思いますが、自分の静的型付けに関するこだわりは伊達や酔狂ではありません。このライブラリでも静的型付けについては徹底されていて、いわゆるダウンキャストのようなものが必要になる場面はいっさいなくなるように設計しています。あの子達の羨望の眼差しも、俺の潔癖すぎる性格を知れば幻滅するだろうね！</p>

<p>また、先程から何度も使っている <code>masync.log</code> は <code>console.log</code> の非同期操作バージョンなのですが、<code>masync.log</code> は <code>masync.lift</code> という関数を使って <code>masync.lift(console.log.bind(console))</code> と表すことができます。つまり、 <code>lift</code> は同期操作バージョンの関数を非同期操作バージョンの関数に変えてくれる関数なのです。<code>this</code> の扱いの関係で <code>bind</code> の呼び出しが必要になっていますが、<code>this</code> に依存しない関数、例えば <code>Math.abs</code> なら <code>masync.lift(Math.abs)</code> だけで非同期バージョンの <code>abs</code> になるのです。これは jQuery.deferred でいえば独自の Deferred を定義することに相当しますが、Deferred を定義するよりはるかに簡単です。</p>

<p>それに対し、欠点としては次のようなものが挙げられます。</p>

<ul>
<li>
<code>masync.run</code> で書ける直列な非同期処理の制限が一度に 26 個まで</li>
<li>同期的に処理しているように見えても、そこにデバッガのブレークポイントが仕掛けられるわけではない</li>
<li>
<del>変数の宣言と、実際に代入するソースコード上の位置が離れてしまう場合がある</del>多分解決しました</li>
</ul>

<p><code>masync.run</code>の引数が26個までという謎制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず26個あれば十分かなと思うのでこうなっています。<code>masync.seq</code> という関数を入れ子にすることでも回避できます。</p>

<p>デバッガのブレークポイントを仕掛けにくいのもつらいですが、どうしてもブレークポイントを仕掛けたければ、さきほど示したような <code>eject</code> のコールバック関数内にならブレークポイントを仕掛けることができます。</p>

<h2>
<span id="まるで化け物を見るような俺がそうだというのか" class="fragment"></span><a href="#%E3%81%BE%E3%82%8B%E3%81%A7%E5%8C%96%E3%81%91%E7%89%A9%E3%82%92%E8%A6%8B%E3%82%8B%E3%82%88%E3%81%86%E3%81%AA%E4%BF%BA%E3%81%8C%E3%81%9D%E3%81%86%E3%81%A0%E3%81%A8%E3%81%84%E3%81%86%E3%81%AE%E3%81%8B"><i class="fa fa-link"></i></a>まるで化け物を見るような...俺がそうだというのか…!?</h2>

<p>これらのコードにはコールバックは無いように見えますが、このライブラリが面倒なコールバックをほぼすべて覆い隠してくれるのです。実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます。というか、上記のコードはコールバックに見えないだけで、このライブラリは『コールバックがない』どころかむしろ <strong>これらのコードはすべてコールバックでできているといっても過言ではない</strong> レベルだったりします。 <strong>『すべてのコールバックを駆逐してやる！』と決意して兵士になったら、実は自分がコールバックだった</strong> とか、なんかどこかで聞いたことがあるような話ですね。なにそれこわい。ここでいわゆるタイトル回収です。</p>

<p>なんじゃそりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです。例えば、先ほど挙げた <code>lift</code> は Haskell に存在する <a href="http://www.haskell.org/haskellwiki/Lifting" rel="nofollow noopener" target="_blank">lift</a> に対応する関数なのです。ほかにも、このライブラリで最初に定義されている関数は <code>fmap</code> という関数なのですが、よく訓練された Haskeller ならこの名前を見ただけで何の関数なのか一発で理解しますし、実装は見なくてもだいたい想像がつきます。ちなみに定義は</p>

<div class="code-frame" data-lang="ts"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">fmap</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span><span class="nx">S</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">t</span>: <span class="kt">T</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">S</span><span class="p">,</span> <span class="nx">x</span>: <span class="kt">Async</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Async</span><span class="o">&lt;</span><span class="nx">S</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">ap</span><span class="p">(</span><span class="nx">pure</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<p>となっていますが、これを見た Haskeller は『ああ、やっぱりね』みたいに言い出します。このライブラリの実装の詳細について理解したければ、Haskell を学ぶのが最も早道だと思います。このライブラリの関数の実装はそれぞれ長くて 10数行なので一見簡単そうですが、とても抽象的な操作ばかりなので、Haskell を知らない人は処理の流れを追えば追うほどわけがわからなくなるので注意してください。 </p>

<p>（　Haskellを知っている人向けに説明すると、このライブラリは <strong>非同期処理モナドライブラリ</strong> なのです。また、いわゆる<a href="http://ja.wikipedia.org/wiki/%E7%B6%99%E7%B6%9A%E6%B8%A1%E3%81%97%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB" rel="nofollow noopener" target="_blank">継続渡し</a> の応用で、成功と失敗の２系統の継続を管理するためのフレームワークを提供するものでもあります。　）</p>

<p>このへんの小難しい話にはみんな興味なさそうだし、もう疲れたのでこれ以上このライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。</p>

<p>この謎のライブラリのソースコードはこちら: <a href="https://github.com/kontan/masync" rel="nofollow noopener" target="_blank">kontan/masync</a> 直角三角形とかも見れます。readme に API リファレンスやほんのちょっとだけライブラリ内部の解説も書いておきましたので、知りたいヒトはどうぞ。あと、readme はネタ無しでとても真面目に書いていますので、ネタ混じりの文章にうんざりしたひとにもお勧めです。</p>

<h2>
<span id="まとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとめ</h2>

<ul>
<li><strong>generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ</strong></li>
<li>Haskell ってすごい</li>
<li>俺のmasyncは並列と直列が両方そなわり最強に見える</li>
</ul>

<h2>
<span id="あのおなか痛いんで負傷者にしてもらっていいですか" class="fragment"></span><a href="#%E3%81%82%E3%81%AE%E3%81%8A%E3%81%AA%E3%81%8B%E7%97%9B%E3%81%84%E3%82%93%E3%81%A7%E8%B2%A0%E5%82%B7%E8%80%85%E3%81%AB%E3%81%97%E3%81%A6%E3%82%82%E3%82%89%E3%81%A3%E3%81%A6%E3%81%84%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B"><i class="fa fa-link"></i></a>あの…おなか痛いんで…負傷者に…してもらって…いいですか!?</h2>

<p>このテキストはあくまで『非同期処理を使わざるをえないときに、どのようにコールバックのネストの多重化を防ぐか』を検討するもので、『ふたつのファイルを読み込んでつなげて出力』というのは問題を把握しやすくするための例題に過ぎませんでした。しかし途中から『手段に関わらずこの例題をどう処理するか』の話とごっちゃになってます。 同期処理が使えるなら同期で処理すればいいです。本来の論旨は『同期処理が使えないとき』であって、fibers や同期版 XHR、FileReaderSync の話はよく考えたら微妙に別件でした。つまり、Web Workers を例に挙げると、ファイルの読み込みについてはWeb Wokers で同期的に可能なのでその部分は本テキストの話題の対象ではなく、Web Workers での Worker スレッドとブラウザのスレッド間のメッセージングについては非同期処理を使わざるをえないがこれをどうするか、というのが本来このテキストで検討したかった対象です。でも関連性はある話題ですし有用ではありそうなので、これらの微妙に主旨からズレた部分の話題に関してもそのまま残しておきます。このテキストの主旨に関して混乱したかたがいたらごめんなさい。</p>

<h2>
<span id="さいごに" class="fragment"></span><a href="#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB"><i class="fa fa-link"></i></a>さいごに</h2>

<blockquote>
<p>InfoQ: そのライブラリを改善できるような、例えば、もっと簡潔にできるなど、JavaScript言語に対する新たな機能や変更というのはありますか？</p>

<p>Isaac氏 (slide-flow-control): いいえ。私のフローコントロールがベストです。だれも改善なんてできません。これがベストなのは私自身に直接かかわっているからです。だから、外部の影響というのは私にとってはマイナスで、ベストではなくなるのです。もし私と同じ経験をしたいなら、フローコントロールライブラリを書くことをおすすめします。自分で書けばすぐにそれがベストだとわかるでしょう。もし他のライブラリの方がよさそうに見えたなら、大急ぎでエディターに戻って、恥を隠して、すぐに彼らのアイデアを自分自身の少し違ったやり方で再発明しましょう。そうすれば、今やそれがベストなのだと実感できるでしょう。</p>
</blockquote>

<p>――<a href="http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript" rel="nofollow noopener" target="_blank">仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法</a></p>

<h2>
<span id="参考文献" class="fragment"></span><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><i class="fa fa-link"></i></a>参考文献</h2>

<ul>
<li><a href="http://techblog.yahoo.co.jp/programming/js_callback/" rel="nofollow noopener" target="_blank">JavaScriptとコールバック地獄</a></li>
<li><a href="http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa" id="reference-72e5b29553dc4300af1a">
jQuery.Deferredを使って楽しい非同期生活を送る方法</a></li>
<li><a href="http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23" id="reference-21c1fb4375ab7f5d60dd">結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話</a></li>
<li><a href="http://techblog.yahoo.co.jp/programming/jquery-deferred/" rel="nofollow noopener" target="_blank">爆速でわかるjQuery.Deferred超入門</a></li>
<li><a href="http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript" rel="nofollow noopener" target="_blank">仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法</a></li>
<li><a href="http://shingekikyojin.net/archives/28229454.html" rel="nofollow noopener" target="_blank">進撃の巨人の名言・迷言をまとめようぜｗｗ</a></li>
<li><a href="http://shingekiword.blogspot.jp/" rel="nofollow noopener" target="_blank">進撃の巨人　名言　セリフ集</a></li>
<li><a href="http://www.geocities.jp/burontosan/" rel="nofollow noopener" target="_blank">ブロントさん名言集</a></li>
<li><a href="http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9" rel="nofollow noopener" target="_blank">ボブ・ロス</a></li>
<li><a href="http://nobuhusa.blog118.fc2.com/blog-entry-630.html" rel="nofollow noopener" target="_blank">はぁ！？なにいってんのおまえ！？</a></li>
<li><a href="http://wiki.cre.jp/typemoon/%E8%A8%80%E5%B3%B0%E7%B6%BA%E7%A4%BC" rel="nofollow noopener" target="_blank">言峰綺礼</a></li>
<li><a href="http://www.yuyushiki.net/" rel="nofollow noopener" target="_blank">ゆゆ式</a></li>
</ul>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>KDKTNさんの<br />2位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>631</kbd>
		<a target="_blank" href="https://qiita.com/KDKTN/items/6a27c0e8efa66b1f7799">食べられないほうのカリー化入門</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-04-30 21:39:45</center>
	</td>
	<td style="width:200px;">
		@KDKTN<br />(私立リリアン女学園高等部 所属)<br><img width="80" height="80" src="https://pbs.twimg.com/profile_images/3438615386/d591fae08d7433a2149c04ff8995ceec_normal.png">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[JavaScript]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>『カリー化』(Currying) という概念をご存知でしょうか。"Curry" は食べ物のカレー(Curry)と同じスペルですが、ここでいう Curry はそれとは別のもので、多くのプログラミング言語に応用できるかもしれない、とても便利かもしれない概念です。</p>

<h2>
<span id="では教えてくれカリー化とはなんのことだ" class="fragment"></span><a href="#%E3%81%A7%E3%81%AF%E6%95%99%E3%81%88%E3%81%A6%E3%81%8F%E3%82%8C%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96%E3%81%A8%E3%81%AF%E3%81%AA%E3%82%93%E3%81%AE%E3%81%93%E3%81%A8%E3%81%A0"><i class="fa fa-link"></i></a>では教えてくれ。”カリー化”とはなんのことだ？</h2>

<p>『ふたつの引数のうち、大きい方の数を返す』という機能を持った関数 <code>max</code> を実装したいとしましょう。そのようなとき、大抵は次のように定義すると思います。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">max</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">y</span> <span class="o">?</span> <span class="nx">x</span> <span class="o">:</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div>

<p>しかしながら、次のように定義した別の関数 <code>_max</code> でも同じような機能を実現することができます。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">_max</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">y</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">y</span> <span class="o">?</span> <span class="nx">x</span> <span class="o">:</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div>

<p>この関数 <code>_max</code> も『大きい方の数を返す』という機能を持っていますが、<code>_max</code> は <code>max</code> とは呼び出し方が少し異なります。たとえば、<code>_max</code> で 1 と　2　のうち大きい方を求めるには、 <code>_max(1)(2)</code> のように書きます。</p>

<p><code>_max</code> が通常の <code>max</code> と異なるところは、関数を呼び出すときに引数をひとつづつ渡すようになっているところです。引数をひとつ渡すと、『引数をもう一つわたすと、最初に渡した引数と今渡された引数のうち大きいほうを返す関数』を返すようになっているのです。括弧が増えるぶんソースコードはいくらか長くなりますが、呼び出し方が異なるだけで目的とする機能が実現できていることには違いはありません。このように、『2引数以上の関数を、1引数の関数の定義だけで同じ機能を持つように定義を書き換えること』を <strong>カリー化</strong> といいます。もちろん２引数に限らず、引数の数がそれ以上であってもカリー化することは可能です。</p>

<h2>
<span id="カレーがシャッキリポンとコード上で踊るわ" class="fragment"></span><a href="#%E3%82%AB%E3%83%AC%E3%83%BC%E3%81%8C%E3%82%B7%E3%83%A3%E3%83%83%E3%82%AD%E3%83%AA%E3%83%9D%E3%83%B3%E3%81%A8%E3%82%B3%E3%83%BC%E3%83%89%E4%B8%8A%E3%81%A7%E8%B8%8A%E3%82%8B%E3%82%8F"><i class="fa fa-link"></i></a>カレーがシャッキリポンとコード上で踊るわ！</h2>

<p>さて、わざわざこんな妙な関数の定義をして、いったい何が嬉しいんでしょうか？プログラミングにおけるカリー化のメリットのひとつとして、 <strong>カリー化された関数に引数を渡すだけで、べつの機能を持つ関数を簡単に作り出せる</strong> 、というものがあります。</p>

<p>たとえば、配列 brightness に画像の各ピクセルの明るさが格納されていて、いくつかの画像処理の結果、要素に負の数の要素が現れるようになったとしましょう。明るさは 0.0～1.0 の範囲で、明るさが 0 より小さくなってはまずいので 0より小さい値は 0 に変えたいとします。配列のすべての要素に関数を適用する関数 <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="nofollow noopener" target="_blank">Array.prototype.map</a> を利用して実装することにすると、<code>map</code> に『0より小さい値は 0 に変える』というような関数を渡せばいいでしょう。 でもそのような関数はないので、無名関数を使って次のように定義することになると思います。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">brightness</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span>
<span class="nx">brightness</span> <span class="o">=</span> <span class="nx">brightness</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span> <span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">});</span>
</pre></div></div>

<p>上のコードの <code>function(x){ return max(0, x) }</code> という式は、『引数をもう一つわたすと、0 と今渡された引数のうち大きいほうを返す関数』という関数を表しています。そういえば、先ほど定義した <code>_max</code> は、引数を渡すと『引数をもう一つわたすと、最初に渡した引数と今渡された引数のうち大きいほうを返す関数』を作ってくれる関数でした。それなら、<code>_max(0)</code>　は『引数をもう一つわたすと、0 と今渡された引数のうち大きいほうを返す関数』を返してくれるはずです。つまり、無名関数を使わずとも <code>_max</code> を使うと次のように書きなおせることがわかります。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">brightness</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span>
<span class="nx">brightness</span> <span class="o">=</span> <span class="nx">brightness</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">_max</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/TvqcF/" rel="nofollow noopener" target="_blank">JSFiddle で見る</a></p>

<p>function 式もなくなって、とてもシンプルになりました！このように、関数リテラルで <code>function(x){ return max(0, x) }</code> のような面倒な記述をしなくても、カリー化された関数なら引数を渡すだけで別の関数を簡単に作り出せるのです。</p>

<h2>
<span id="なるべく手をかけず簡単にこれが美味しいカレーを作るこつです" class="fragment"></span><a href="#%E3%81%AA%E3%82%8B%E3%81%B9%E3%81%8F%E6%89%8B%E3%82%92%E3%81%8B%E3%81%91%E3%81%9A%E7%B0%A1%E5%8D%98%E3%81%AB%E3%81%93%E3%82%8C%E3%81%8C%E7%BE%8E%E5%91%B3%E3%81%97%E3%81%84%E3%82%AB%E3%83%AC%E3%83%BC%E3%82%92%E4%BD%9C%E3%82%8B%E3%81%93%E3%81%A4%E3%81%A7%E3%81%99"><i class="fa fa-link"></i></a>なるべく手をかけず簡単に。これが美味しいカレーを作るこつです</h2>

<p>さて、先程は <code>max</code> を手作業でカリー化された形式 <code>_max</code> を定義しなおしたわけですが、いくらカリー化された関数にメリットがあるとしても、関数を定義するたびに先ほどのように function 式を入れ子にして書くのはなかなか面倒です。なんとか関数を簡単にカリー化できないものかと、カリー化を行う関数 <code>curry</code> を次のように定義してみました。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">f</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">_curry</span><span class="p">(</span><span class="nx">xs</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){</span> <span class="k">return</span> <span class="nx">_curry</span><span class="p">(</span><span class="nx">xs</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="nx">x</span><span class="p">]));</span> <span class="p">}</span> <span class="o">:</span> <span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="nx">xs</span><span class="p">);</span>
    <span class="p">}([]);</span>
<span class="p">}</span>
</pre></div></div>

<p>この関数 <code>curry</code> を使えば、さきほどの <code>max</code> のような関数や、一部の標準ライブラリ関数などを簡単にカリー化することができます。たとえば、次のように標準ライブラリの <code>Math.max</code> をカリー化することで <code>_max</code> を定義できます。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">_max</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">);</span>
</pre></div></div>

<p>したがって、先ほどの画像処理のプログラムも、<code>curry</code> を使えば次のように書くことができます。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">brightness</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span>
<span class="nx">brightness</span> <span class="o">=</span> <span class="nx">brightness</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">curry</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">)(</span><span class="mi">0</span><span class="p">));</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/HC4Lc/" rel="nofollow noopener" target="_blank">JSFiddle で見る</a></p>

<h2>
<span id="このカレーはできそこないだ食べられないよ" class="fragment"></span><a href="#%E3%81%93%E3%81%AE%E3%82%AB%E3%83%AC%E3%83%BC%E3%81%AF%E3%81%A7%E3%81%8D%E3%81%9D%E3%81%93%E3%81%AA%E3%81%84%E3%81%A0%E9%A3%9F%E3%81%B9%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84%E3%82%88"><i class="fa fa-link"></i></a>このカレーはできそこないだ。食べられないよ</h2>

<p>さて、カリー化されていない関数でも <code>curry</code> に通すだけで簡単にカリー化できるようにはなりましたが……果たしてコレ、役に立つんでしょうか？既存の関数はもちろんカリー化されていないので、map や filter のような関数にはいちいち curry を呼び出してから渡す必要があります。記述は多少短くなったものの、<code>curry</code> を呼ぶ手間に関してはどうしようもありません。また、場合によっては <code>curry</code> の呼び出しやカリー化された関数の呼び出しのオーバーヘッドも無視できません。カリー化のメリットが最も発揮されるのは、</p>

<ol>
<li>通常の方法で定義された関数は、すべてカリー化されている</li>
<li>関数適用の構文がシンプル</li>
<li>高階関数を多用する API が用意されている</li>
</ol>

<p>という条件が揃った時だと思います。言語そのものにカリー化の機能があればとても便利ですが、そうでない言語において <code>curry</code> のような関数を持ち込んでも、結局のところ <code>curry</code> の呼び出し自体を取り除くことはできませんし、あまり標準的なコーディングでない方法を持ち込むことで他の人にコードが読みにくいと言われるかもしれません。多少コードが冗長になったとしても、カリー化しないで標準的な function 式を使うコーディングを使ったほうがいいかもしれません。</p>

<p>じゃあカリー化がちゃんと活躍している言語にはどんなものがあるかというと、Haskell や OCaml が挙げられます。Haskell では先程の画像処理のプログラムを次のように書くことができます。</p>

<div class="code-frame" data-lang="hs"><div class="highlight"><pre><span></span><span class="nf">brightness</span> <span class="ow">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]</span>
<span class="nf">brightness'</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">max</span> <span class="mi">0</span><span class="p">)</span> <span class="n">brightness</span> 
</pre></div></div>

<p>このとき、</p>

<ol>
<li>
<code>max</code> は Haskell 組み込みの関数で、最初からカリー化された形式で定義されています。関数を普通に定義すると、それは自動的にカリー化された関数になります。</li>
<li>関数適用の構文は、<code>max 0 1</code> のように関数の後ろに空白で区切って引数を書くだけなので、普通に呼び出しても括弧だらけになったりしません</li>
<li>リストの各要素に関数を適用して別のリストに写す <code>map</code> を始め、このような高階関数(関数を引数にとったり関数を返す関数)がごく当たり前の手法として用いられています。for 文などは最初から存在しません。</li>
</ol>

<p>これを考えると、JavaScript にカリー化を持ち込んで味わえる旨味というのは、Haskell で味わえる旨味には及ばないと言わざるを得ないのです。残念……。</p>

<h2>
<span id="このカレーを作ったのは誰だあっ" class="fragment"></span><a href="#%E3%81%93%E3%81%AE%E3%82%AB%E3%83%AC%E3%83%BC%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF%E8%AA%B0%E3%81%A0%E3%81%82%E3%81%A3"><i class="fa fa-link"></i></a>このカレーを作ったのは誰だあっ！！</h2>

<p>カリー化(Currying) の "Curry" は食べ物のカレーとスペルがまったく同じですが、カリー化は食べ物とは関係なくて、この辺りの分野に大きな業績のある論理学者・数学者のハスケル・カリー(Haskell Curry)さんの名前に由来します（そうです、Haskell もこのひとの名前に由来しています）。でもWikipedia によれば、最初にカリー化の概念を示したのは Moses Schönfinkel さんとゴットロープ・フレーゲさんだそうな。自分は Schönfinkel さんは失礼ながらご存じあげないのですが、フレーゲさんは論理学者としてとても有名な方ですよね。カリー化はプログラミング特有の概念というわけではなく、もともと数学で関数の振る舞いを調べるときに便利なように考案されたものみたいです。</p>

<h2>
<span id="やれやれこんな部分適用をカリー化と言っているようじゃほんとに理解しているのか怪しいもんだ" class="fragment"></span><a href="#%E3%82%84%E3%82%8C%E3%82%84%E3%82%8C%E3%81%93%E3%82%93%E3%81%AA%E9%83%A8%E5%88%86%E9%81%A9%E7%94%A8%E3%82%92%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96%E3%81%A8%E8%A8%80%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%82%88%E3%81%86%E3%81%98%E3%82%83%E3%81%BB%E3%82%93%E3%81%A8%E3%81%AB%E7%90%86%E8%A7%A3%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B%E6%80%AA%E3%81%97%E3%81%84%E3%82%82%E3%82%93%E3%81%A0"><i class="fa fa-link"></i></a>やれやれ。こんな部分適用をカリー化と言っているようじゃ、ほんとに理解しているのか怪しいもんだ</h2>

<p>複数の引数をもつ関数に、一部だけ引数を渡して呼び出すことを関数の <strong>部分適用</strong> といいますが、カリー化は関数の部分適用とよく混同されるようです。一部の言語において実際には部分適用を行う関数に何故か <code>curry</code> という名前を付けてしまったものが存在し、それがさらに混乱を招いているということもあるようです。確かにカリー化と部分適用は非常に近しい関係にありますが、あくまで両者は似て非なるものです。せっかくですので、カリー化と部分適用の違いについて正確に理解しておきましょう。</p>

<p>自然言語でいろいろと説明を尽くすのも大事なことですが、正確な理解のためには形式的な定義に勝るものはありません。カリー化を形式的にいうと、次のようになります。簡単のためここでは２引数の関数についてのみ述べますが、３引数以上の関数でも同じように議論できます。（ <strong>数式を読むのが面倒臭いひとは、結論だけ読んでください</strong> ）</p>

<p><a href="https://camo.qiitausercontent.com/5cc7d68b58f9104c6c9761577554300213d5feb0/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f32623238326632322d663665612d323439622d333533362d3830646133653663613237322e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/5cc7d68b58f9104c6c9761577554300213d5feb0/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f32623238326632322d663665612d323439622d333533362d3830646133653663613237322e706e67" alt="def.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/17886/2b282f22-f6ea-249b-3536-80da3e6ca272.png"></a></p>

<p>また、</p>

<p><a href="https://camo.qiitausercontent.com/316b0fa9dd87545e78932f3de5a9ff5358c55f44/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f34613332303262332d656239632d613238382d633865322d6464376166366166313331612e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/316b0fa9dd87545e78932f3de5a9ff5358c55f44/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f34613332303262332d656239632d613238382d633865322d6464376166366166313331612e706e67" alt="curry.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/17886/4a3202b3-eb9c-a288-c8e2-dd7af6af131a.png"></a></p>

<p>関数 <code>f</code> を <code>curry</code> に適用するだけでカリー化された関数 <code>g</code> に変えてくれるわけですね。</p>

<p>それに対し、部分適用はというと、</p>

<p><a href="https://camo.qiitausercontent.com/5c958052646df3bed41d3d78834e8b214ab4d845/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f33343164316261342d306266622d313561362d663238352d3566373264333062666538632e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/5c958052646df3bed41d3d78834e8b214ab4d845/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f33343164316261342d306266622d313561362d663238352d3566373264333062666538632e706e67" alt="partial.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/17886/341d1ba4-0bfb-15a6-f285-5f72d30bfe8c.png"></a></p>

<p>この操作 <code>partial(f, x)</code> を関数の <strong>部分適用</strong> といいます。関数 f に x を部分適用した式 <code>partial(f, x)</code> は、残りの引数を渡すと普通に <code>f</code> にすべての引数を渡したのと同じように計算してくれます。あくまで <code>f</code> は２引数の関数ですが、そのうち最初の 1 つの引数だけを適用しているようになっているので『部分』適用と呼ぶわけです。</p>

<p>最後に、カリー化関数 <code>curry</code> と部分適用関数 <code>partial</code> の関係を形式的に表してみましょう。</p>

<p><a href="https://camo.qiitausercontent.com/699b85b7717408fb0041fc002316288b3e7898a4/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f30376662363336662d373263612d643863372d623361622d6636336165346638356561612e706e67" target="_blank" rel="nofollow noopener"><img src="https://camo.qiitausercontent.com/699b85b7717408fb0041fc002316288b3e7898a4/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f31373838362f30376662363336662d373263612d643863372d623361622d6636336165346638356561612e706e67" alt="proof.png" data-canonical-src="https://qiita-image-store.s3.amazonaws.com/0/17886/07fb636f-72ca-d8c7-b3ab-f63ae4f85eaa.png"></a></p>

<p>『f に x を部分適用する』というのは、『 f をカリー化してから x を適用する』のとおなじだ、というわけです。したがって、『f に x を部分適用する』というのは、『 f をカリー化する』のとは異なります。これで部分適用 <code>partial(f, x)</code> とカリー化 <code>curry(f)</code> の違いがおわかり頂けたのではないでしょうか。</p>

<h2>
<span id="参考" class="fragment"></span><a href="#%E5%8F%82%E8%80%83"><i class="fa fa-link"></i></a>参考</h2>

<ul>
<li><a href="http://qiita.com/items/e099910c11c4be5cd651">JavaScript でカリー化 - Qiita</a></li>
<li><a href="http://d.hatena.ne.jp/m-hiyama/20051213/1134446855" rel="nofollow noopener" target="_blank">JavaScriptでカリー化 - 檜山正幸のキマイラ飼育記</a></li>
<li><a href="http://nanto.asablo.jp/blog/2008/02/14/2626240" rel="nofollow noopener" target="_blank">JavaScriptでカリー化、再び - Days on the Moon</a></li>
<li><a href="http://d.hatena.ne.jp/kmizushima/20091216/1260969166" rel="nofollow noopener" target="_blank">カリー化 != 部分適用</a></li>
<li><a href="http://www.page.sannet.ne.jp/d-rigel/oisinbomatome2.htm" rel="nofollow noopener" target="_blank">美味しんぼ－名言集－</a></li>
</ul>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>KDKTNさんの<br />3位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>377</kbd>
		<a target="_blank" href="https://qiita.com/KDKTN/items/0b468a07410d757ac609">じゃあ this の抜き打ちテストやるぞー</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-04-17 18:14:13</center>
	</td>
	<td style="width:200px;">
		@KDKTN<br />(私立リリアン女学園高等部 所属)<br><img width="80" height="80" src="https://pbs.twimg.com/profile_images/3438615386/d591fae08d7433a2149c04ff8995ceec_normal.png">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[JavaScript]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p><a href="http://qiita.com/items/74005adacc0e8e2a3cab">JavaScriptのthisの覚え方</a> や <a href="http://qiita.com/items/9935ce476a17d6258e27">JavaScriptの「this」は「４つ」だけ！</a>の授業でやったから、this はみんなばっちりだよな。じゃあ今から抜き打ちテストするぞー。まだ読んでないひとは先に上の記事を読んどくといいと思うけど、腕に自信のある人はすぐに回答を始めても構わないぞ。赤点とった奴は、今日の放課後<a href="http://qiita.com/items/d249a2f2f13532748324">補習</a>だからなー。</p>

<p><strong>【注意】 問題 18 ～20 について、<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Comma_Operator" rel="nofollow noopener" target="_blank">カンマ演算子</a> を知らないから解けなかった、という人が結構いるみたいです。本問はカンマ演算子の知識を問うものではなく、あくまで this の振る舞いについての理解を試すものなので、本来の題意を損なわないように当該の問題は改題しました。改題後も正答とその根拠は変わりません。</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">得点</th>
<th style="text-align: left">評価</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">0 ～  5</td>
<td style="text-align: left">テスト中に寝るんじゃない</td>
</tr>
<tr>
<td style="text-align: left">6 ～ 11</td>
<td style="text-align: left">鉛筆転がしのほうがマシ</td>
</tr>
<tr>
<td style="text-align: left">12 ～ 15</td>
<td style="text-align: left">平凡な一般市民</td>
</tr>
<tr>
<td style="text-align: left">16 ～ 19</td>
<td style="text-align: left">10 人に一人の逸材</td>
</tr>
<tr>
<td style="text-align: left">20 ～ 21</td>
<td style="text-align: left">this の世界的権威</td>
</tr>
<tr>
<td style="text-align: left">22</td>
<td style="text-align: left">あなたが神か</td>
</tr>
</tbody>
</table>

<h1>
<span id="問-以下の-javascript-プログラムをウェブブラウザ上で実行したときtrue-が出力されるものには--そうでないものには--をつけよ各１点" class="fragment"></span><a href="#%E5%95%8F-%E4%BB%A5%E4%B8%8B%E3%81%AE-javascript-%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%82%92%E3%82%A6%E3%82%A7%E3%83%96%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E4%B8%8A%E3%81%A7%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%9F%E3%81%A8%E3%81%8Dtrue-%E3%81%8C%E5%87%BA%E5%8A%9B%E3%81%95%E3%82%8C%E3%82%8B%E3%82%82%E3%81%AE%E3%81%AB%E3%81%AF--%E3%81%9D%E3%81%86%E3%81%A7%E3%81%AA%E3%81%84%E3%82%82%E3%81%AE%E3%81%AB%E3%81%AF--%E3%82%92%E3%81%A4%E3%81%91%E3%82%88%E5%90%84%EF%BC%91%E7%82%B9"><i class="fa fa-link"></i></a>問 以下の JavaScript プログラムをウェブブラウザ上で実行したとき、<code>true</code> が出力されるものには ○ 、そうでないものには × をつけよ。（各１点）</h1>

<h2>
<span id="1" class="fragment"></span><a href="#1"><i class="fa fa-link"></i></a>1</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/7xFnS/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="2" class="fragment"></span><a href="#2"><i class="fa fa-link"></i></a>2</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/V2h8K/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="3" class="fragment"></span><a href="#3"><i class="fa fa-link"></i></a>3</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">hoge</span><span class="p">();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/mEneJ/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="4" class="fragment"></span><a href="#4"><i class="fa fa-link"></i></a>4</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">piyo</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="nx">hoge</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
    <span class="p">}</span> 
<span class="p">};</span>

<span class="nx">piyo</span><span class="p">.</span><span class="nx">hoge</span><span class="p">();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/rPtQ2/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="5" class="fragment"></span><a href="#5"><i class="fa fa-link"></i></a>5</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">Hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>    

<span class="k">new</span> <span class="nx">Hoge</span><span class="p">();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/6Lyaw/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="6" class="fragment"></span><a href="#6"><i class="fa fa-link"></i></a>6</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">hoge</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">Hoge</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
    <span class="p">}</span>    
<span class="p">};</span>

<span class="k">new</span> <span class="nx">hoge</span><span class="p">.</span><span class="nx">Hoge</span><span class="p">();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/Xfq2a/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="7" class="fragment"></span><a href="#7"><i class="fa fa-link"></i></a>7</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">})()</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/hdeFK/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="8" class="fragment"></span><a href="#8"><i class="fa fa-link"></i></a>8</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">})()</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/aSWMj/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="9" class="fragment"></span><a href="#9"><i class="fa fa-link"></i></a>9</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">hoge</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/4DemV/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="10" class="fragment"></span><a href="#10"><i class="fa fa-link"></i></a>10</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">hoge</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/8bGRk/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="11" class="fragment"></span><a href="#11"><i class="fa fa-link"></i></a>11</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">hoge</span><span class="p">.</span><span class="nx">apply</span><span class="p">();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/yZqGK/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="12" class="fragment"></span><a href="#12"><i class="fa fa-link"></i></a>12</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">hoge</span><span class="p">.</span><span class="nx">apply</span><span class="p">();</span>    
</pre></div></div>

<p><a href="http://jsfiddle.net/Af5F5/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="13" class="fragment"></span><a href="#13"><i class="fa fa-link"></i></a>13</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">hoge</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">hoge</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="p">[]);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/vGCW8/1/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="14" class="fragment"></span><a href="#14"><i class="fa fa-link"></i></a>14</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/sMCfJ/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="15" class="fragment"></span><a href="#15"><i class="fa fa-link"></i></a>15</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/aH5He/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="16" class="fragment"></span><a href="#16"><i class="fa fa-link"></i></a>16</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">})();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/53yN7/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="17" class="fragment"></span><a href="#17"><i class="fa fa-link"></i></a>17</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
<span class="p">})();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/ydUAS/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="18" class="fragment"></span><a href="#18"><i class="fa fa-link"></i></a>18</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">_eval</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/H74Ns/1/" rel="nofollow noopener" target="_blank">答え</a> ( <a href="http://jsfiddle.net/H74Ns/" rel="nofollow noopener" target="_blank">改題前の問題と答え</a> )</p>

<h2>
<span id="19" class="fragment"></span><a href="#19"><i class="fa fa-link"></i></a>19</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">_eval</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span> 
</pre></div></div>

<p><a href="http://jsfiddle.net/xzEk8/1/" rel="nofollow noopener" target="_blank">答え</a> ( <a href="http://jsfiddle.net/xzEk8/" rel="nofollow noopener" target="_blank">改題前の問題と答え</a> )</p>

<h2>
<span id="20" class="fragment"></span><a href="#20"><i class="fa fa-link"></i></a>20</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">_eval</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_eval</span><span class="p">(</span><span class="s1">'this'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span> 
<span class="p">})();</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/AukpQ/1/" rel="nofollow noopener" target="_blank">答え</a> ( <a href="http://jsfiddle.net/AukpQ/" rel="nofollow noopener" target="_blank">改題前の問題と答え</a> )</p>

<h2>
<span id="21" class="fragment"></span><a href="#21"><i class="fa fa-link"></i></a>21</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="s1">'return this'</span><span class="p">)()</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>
</pre></div></div>

<p><a href="http://jsfiddle.net/ByBRj/" rel="nofollow noopener" target="_blank">答え</a></p>

<h2>
<span id="22" class="fragment"></span><a href="#22"><i class="fa fa-link"></i></a>22</h2>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="s1">'use strict'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="s1">'return this'</span><span class="p">)()</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span>    
</pre></div></div>

<p><a href="http://jsfiddle.net/nnnfD/" rel="nofollow noopener" target="_blank">答え</a></p>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>KDKTNさんの<br />4位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>262</kbd>
		<a target="_blank" href="https://qiita.com/KDKTN/items/a151d8d003a62c7b2ca3">100行で書く俺様プログラミング言語コンパイラAltJS編</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-21 22:37:57</center>
	</td>
	<td style="width:200px;">
		@KDKTN<br />(私立リリアン女学園高等部 所属)<br><img width="80" height="80" src="https://pbs.twimg.com/profile_images/3438615386/d591fae08d7433a2149c04ff8995ceec_normal.png">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[JavaScript]</b> <b>[TypeScript]</b> <b>[構文解析]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>プログラミングをしたことがあるひとなら、誰でも１度くらい自分の理想の言語を作ってみたいと思うのではないでしょうか。このテキストは、オリジナルのプログラミング言語のコンパイラ作成を通して、パーサコンビネータの使い方を紹介していくものです。</p>

<h2>
<span id="2分でわかる俺の俺による俺のためのプログラミング言語を作る大まかな手順" class="fragment"></span><a href="#2%E5%88%86%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8B%E4%BF%BA%E3%81%AE%E4%BF%BA%E3%81%AB%E3%82%88%E3%82%8B%E4%BF%BA%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E%E3%82%92%E4%BD%9C%E3%82%8B%E5%A4%A7%E3%81%BE%E3%81%8B%E3%81%AA%E6%89%8B%E9%A0%86"><i class="fa fa-link"></i></a>2分でわかる、俺の俺による俺のためのプログラミング言語を作る大まかな手順</h2>

<p>自分のオリジナルなプログラミング言語を作るには、典型的には次のような手順を踏みます。</p>

<ol>
<li>既存のプログラミング言語を使ってみる</li>
<li>その既存の言語の気に入らないところを徹底的になじる（ただし心のなかで）</li>
<li>己の内に秘める中二力を卍解し、最強プログラミング言語の仕様を妄想する</li>
<li>コンパイラを作る</li>
<li>その言語を教典とする宗教団体を設立し、慈悲深き終身の独裁者を名乗る</li>
<li>自分の言語が思ったよりしょぼいことに気付く</li>
<li>桶屋が儲かる</li>
</ol>

<p>このテキストではこのうち手順 4 だけ、特にコンパイラのパーサ部分を解説します。</p>

<ul>
<li><p>このテキストを読むにあたって、構文解析についての知識はとくに不要です。正規表現を知っていると理解の助けになるかもしれません。</p></li>
<li><p>このテキストで作ってみるプログラミング言語は、最近のお茶っぽいネーミングの流行に乗っかって BanchaScript と名づけました。あまり変な言語を作っても参考にならないので、言語仕様は C/Java/JavaScript の系統の比較的オーソドックスなものを採用しています。</p></li>
<li><p>コーディングには JavaScript/TypeScript を使い、パーサを作成するのに Parsect というライブラリを利用します。これは Haskell の Parsec という構文解析を行うためのライブラリを筆者が JavaScript/TypeScript へといい加減に移植したりしなかったりしたもので、このテキストはそれの紹介も兼ねています。本文中のソースコードのほとんどは、JavaScriptとTypeScriptのどちらでも有効なコードで書かれています。</p></li>
</ul>

<h2>
<span id="まずは3分でわかるコンパイラの構造" class="fragment"></span><a href="#%E3%81%BE%E3%81%9A%E3%81%AF3%E5%88%86%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E6%A7%8B%E9%80%A0"><i class="fa fa-link"></i></a>まずは3分でわかるコンパイラの構造</h2>

<p>コンパイラの工程は、典型的には次のような段階を踏みます。らしいです。</p>

<ol>
<li>字句解析</li>
<li>構文解析</li>
<li>中間コード生成</li>
<li>最適化</li>
<li>コード生成</li>
</ol>

<p>筆者は大変な面倒くさがり屋なので、今回作るコンパイラではこれらの工程を大きく簡略化します。最適化については面倒くさいので省略します。最終的に出力するコードはJavaScriptのソースコードとします。このようなコンパイル形態をもつ言語は <a href="http://altjs.org/" rel="nofollow noopener" target="_blank">AltJS</a> などと呼ばれていて、実行に関するあらゆる機能をJavaScriptエンジンに丸投げできるので、パーサさえうまくできればコンパイラを作るのがとても簡単になります。また、このような手法を採用することから中間的なデータ構造を作らなくても済むので、構文解析と同時に直接最終的なコードを出力していきます。コード生成部分に関しては、ほぼ等価なJavaScriptソースコードを文字列として生成しているだけなので、特に説明する内容はありません。</p>

<h2>
<span id="というわけで4分くらいでわかる字句解析器と構文解析器とはなにか" class="fragment"></span><a href="#%E3%81%A8%E3%81%84%E3%81%86%E3%82%8F%E3%81%91%E3%81%A74%E5%88%86%E3%81%8F%E3%82%89%E3%81%84%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8B%E5%AD%97%E5%8F%A5%E8%A7%A3%E6%9E%90%E5%99%A8%E3%81%A8%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90%E5%99%A8%E3%81%A8%E3%81%AF%E3%81%AA%E3%81%AB%E3%81%8B"><i class="fa fa-link"></i></a>というわけで、4分くらいでわかる字句解析器と構文解析器とはなにか</h2>

<p>今回作るコンパイラでは、工程としては字句解析器と構文解析器に分類はしますが、実はコード上では両者に区別はありません。字句解析器も構文解析器も、どちらも一種の関数とみなすことができます。どちらの解析器でも、入力する情報は次のふたつだけです。</p>

<ul>
<li>構文解析の対象としている文字列</li>
<li>現在何文字目まで読み終えているか</li>
</ul>

<p>また、解析器は入力に応じて次の情報を返してきます。</p>

<ul>
<li>読み取りが成功したかどうか</li>
<li>成功した場合は、何文字目まで読み終えたかと、読み取った内容</li>
<li>失敗した場合は、何文字目まで読み終えたかと、期待していた内容</li>
</ul>

<p>基本的にはたったこれだけです。コンパイルする対象の文字列の最小単位である『識別子』『演算子』などのトークンを読み取るのが字句解析器で、『関数の定義』『if文』など複数のトークンが組み合わさったものを読み取るのが構文解析器なのです。まずはトークンを読み取る字句解析器を作り、それらの字句解析器を組み合わせて構文解析器を作成していくことになります。ここでは、字句解析器も構文解析器をまとめて『パーサ』や『解析器』などと呼ぶことがあります。それぞれの解析器は基本的には状態を持ちません。入力に応じて決まった出力を行う、単なる関数です。</p>

<h2>
<span id="概念は5分くらいでわかるけど実際に作るのには何時間もかかるんじゃないかと思えてくる字句解析器" class="fragment"></span><a href="#%E6%A6%82%E5%BF%B5%E3%81%AF5%E5%88%86%E3%81%8F%E3%82%89%E3%81%84%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8B%E3%81%91%E3%81%A9%E5%AE%9F%E9%9A%9B%E3%81%AB%E4%BD%9C%E3%82%8B%E3%81%AE%E3%81%AB%E3%81%AF%E4%BD%95%E6%99%82%E9%96%93%E3%82%82%E3%81%8B%E3%81%8B%E3%82%8B%E3%82%93%E3%81%98%E3%82%83%E3%81%AA%E3%81%84%E3%81%8B%E3%81%A8%E6%80%9D%E3%81%88%E3%81%A6%E3%81%8F%E3%82%8B%E5%AD%97%E5%8F%A5%E8%A7%A3%E6%9E%90%E5%99%A8"><i class="fa fa-link"></i></a>概念は5分くらいでわかるけど、実際に作るのには何時間もかかるんじゃないかと思えてくる字句解析器</h2>

<p><strong>字句解析器</strong> (Lexer, Scanner, Token Parserなどともいいます)は、その言語の最小単位である『識別子』『リテラル』『予約語』などのトークンごとの読み取りを行うパーサです。注意しなければならないのは、トークンとトークンの間には空白文字やコメント文があるときもありますし、そのような区切りがなくて直後にいきなり次のトークンが現れるときもあることです。字句解析器はひとつトークンを読んだら、つねに次のトークンの直前まで読まなくてはならないものとします。たとえば、次のようなソースコードを解析しているものとします。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var hoge /* この変数はほげ */ = 42;
</pre></div></div>

<p>ここで、現在の読み取り位置は 4、つまり <code>hoge</code> の直前で、ここから識別子をひとつ読み取るパーサを作りたいとします。識別子の <code>hoge</code> の直後にはブロックコメントがありますが、コメントはトークンにはならないので、一度の読み取りでこれらのブロックコメントも含めて読み飛ばして <code>=</code> の直前まで来なければなりません。つまり、識別子の字句解析器は</p>

<ul>
<li>入力文字列: <code>var hoge /* この変数はほげ */ = 42;</code>
</li>
<li>現在の位置: 4</li>
</ul>

<p>という入力から、</p>

<ul>
<li>成功</li>
<li>現在の位置: 23</li>
<li>読み取った情報: <code>"hoge"</code>
</li>
</ul>

<p>というような結果を返すようプログラムされていなければなりません。また、次のように識別子と次のトークンに空白などの区切りがないときもあります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var hoge=42;
</pre></div></div>

<p>このような場合でも、識別子の字句解析パーサは次のトークンである <code>=</code> の直前まで読み取り、以下のような結果を返さなければなりません。</p>

<ul>
<li>成功</li>
<li>現在の位置: 8</li>
<li>読み取った情報: <code>"hoge"</code>
</li>
</ul>

<p>また、現在の位置に識別子が存在しない場合もあります。先ほどと同じ <code>var hoge=42;</code> というソースコードの9文字目、<code>42</code>の直前の位置で識別子の字句解析器を使ったなら、そこには識別子は存在しないので、次のような結果を返さなければなりません。</p>

<ul>
<li>失敗</li>
<li>現在の位置: 9</li>
<li>期待していたもの: a-z, A-Z, _, $ のいずれかひとつ</li>
</ul>

<p>こういった機能をもつ字句解析パーサを、『識別子を読み取るパーサ』『数値リテラルを読み取るパーサ』『文字列リテラルを読み取るパーサ』『予約語を読み取るパーサ』『括弧を読み取るパーサ』などと、その言語のソースコードに出現しうるすべてのトークンの種類ごとに定義しなければなりません。それほど難しくはなさそうですが、これでは作業量としてはかなりのの量になりそうです。やれやれ。</p>

<h2>
<span id="実際には10数行で書ける字句解析器" class="fragment"></span><a href="#%E5%AE%9F%E9%9A%9B%E3%81%AB%E3%81%AF10%E6%95%B0%E8%A1%8C%E3%81%A7%E6%9B%B8%E3%81%91%E3%82%8B%E5%AD%97%E5%8F%A5%E8%A7%A3%E6%9E%90%E5%99%A8"><i class="fa fa-link"></i></a>実際には10数行で書ける字句解析器</h2>

<p>というわけで字句解析器を構成するのはとても大変なので、ライブラリに付属している <strong>字句解析器を自動で構成してくれる機能</strong> を使います。関数 <code>makeTokenParser</code> は『コメントを開始する記号/終了する記号』『予約語』などの情報をオブジェクトのプロパティとして定義して渡すだけで自動で字句解析器を構成してくれます。ほとんどのプログラミング言語の字句解析はこの機能で十分構成できます。BanchaScriptの場合は次のようになっています。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var lexer = Parsect.makeTokenParser({
    commentStart:       '/*',   // ブロックコメントの開始記号
    commentEnd:         '*/',   // ブロックコメントの終了記号
    commentLine:        '//',   // 行コメントの開始記号
    nestedComments:     true,   // ネストされたブロックコメントを許可するかどうか
    identStart:         /[_$a-zA-Z]/,   // 識別子の最初の文字
    identLetter:        /[_$a-zA-Z0-9]/,    // 識別子の2文字目以降
    opStart:            /[+\-*\/=!$%&amp;\^~@?_&gt;&lt;:|\\.]/,   // 演算子の最初の文字
    opLetter:           /[+\-*\/=!$%&amp;\^~@?_&gt;&lt;:|\\.]/,   // 演算子の２文字目以降
    reservedNames:      ["def", "return", "operator", "infix", "infixl", "infixr", "prefix", "postfix", "var"],　// 予約語
    reservedOpNames:    [],     // 予約された演算子 
    caseSensitive:      true    // 大文字小文字を区別するかどうか
});
</pre></div></div>

<p>これだけでBanchaScriptの字句解析器は <strong>完成</strong> です。この一覧表をいじれば、プログラミング言語の見た目を自由に調節できます。たとえば行コメントの開始を <code>#</code> にしたければ、<code>commentLine</code> プロパティの値を <code>#</code>　に変えるだけです。</p>

<p><code>makeTokenParser</code> が返してくるオブジェクト <code>lexer</code>はいろいろな字句解析パーサをプロパティとして持っています。たとえば、<code>lexer.identifier</code> は識別子の字句解析を行ってくれるパーサです。たとえば、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var hoge /* この変数はほげ */ = 42;
</pre></div></div>

<p>というソースコードの4文字目まで読み終わった状態から　<code>lexer.identifier</code> を実際に使ってみましょう。この字句解析器を実際に使うには、<code>parse</code> という関数を使います。<code>parse</code> はパーサと入力となる <code>State</code> オブジェクトを渡すと、そのパーサの解析の結果を <code>Reply</code> オブジェクトとして返してくれます。ソースコードは次のようになります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var state = new Parsect.State("var hoge /* この変数はほげ */ = 42;", 4);   // state は現在の状態
var reply = Parsect.parse(lexer.identifier, state);                     // reply は解析の結果
console.log("成功したかどうか: " + reply.success);
console.log("現在の位置: "    + reply.state.position);
console.log("読み取った情報: " + reply.value);
</pre></div></div>

<p>これを実行すると、次のような出力を得られます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>成功したかどうか: true
現在の位置: 23
読み取った情報: hoge
</pre></div></div>

<p>さきほどコメントして <code>/*</code> から  <code>*/</code> までの間をコメントにするように指定しましたが、識別子 <code>hoge</code> を読み取ったあと、このコメント部分もちゃんと読み飛ばし、次のトークン <code>=</code> の直前で停止したことがおわかりになると思います。他にも数値リテラルを字句解析する <code>lexer.naturalOrFloat</code> や、文字列リテラルを読み取る <code>lexer.stringLiteral</code> 、予約語を読み取る <code>lexer.reserved</code> や任意の単純なパーサをこの言語における字句解析パーサに変換する <code>lexer.lexeme</code> などが自動的に作成されます。便利便利。これじゃあ全然構文解析の勉強になりませんが、とにかく楽なのでよしとしましょう。カレーを作るのにジャガイモの育て方から知る必要はない、みたいなのと同じです。</p>

<h2>
<span id="8行で書ける変数宣言の構文解析" class="fragment"></span><a href="#8%E8%A1%8C%E3%81%A7%E6%9B%B8%E3%81%91%E3%82%8B%E5%A4%89%E6%95%B0%E5%AE%A3%E8%A8%80%E3%81%AE%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90"><i class="fa fa-link"></i></a>8行で書ける変数宣言の構文解析</h2>

<p>字句解析器ができたので、手始めに次のような変数の宣言の文を構文解析してみましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var hoge = 42;
</pre></div></div>

<p>この式を読み取って、読み取った情報を <code>var hoge=42;</code> というようなJavaScriptのソースコードとして返すようなパーサを構成してみます（BanchaScriptの変数宣言とJavaScriptの変数宣言はほぼ同じなので、ほぼ同じコードにコンパイルされます）。このような文を字句解析器で構文解析するには、『予約語varを読み取るパーサ』『識別子を読み取るパーサ』『<code>=</code>を読み取るパーサ』などの各種のパーサを <code>lexer</code> から呼び出して、順番に適用していきます。このようにいろんなパーサを順番に使用するときは、Parsect では <code>Parsect.seq</code> という関数を使うと次のように直感的に書くことができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var varStatement = Parsect.seq(function(s){       // 変数の宣言とは
                s( lexer.reserved("var") );         // まず予約語 var があって、
    var name =  s( lexer.identifier      );         // 変数名となる識別子があり(その識別子をnameとする)、
                s( lexer.reservedOp("=") );         // 代入を示す = の記号、
    var value = s( lexer.naturalOrFloat  );         // 代入する値(その値をvalueとする)、
                s( lexer.semi            );         // 最後にセミコロン。
    return "var " + name + "=" + value + ";";       // return で結果の値を返す
});
</pre></div></div>

<p><code>seq</code>から受け取った <code>s</code> という関数に順に実行したいパーサを渡すのがポイントです。このとき、変数 <code>name</code> には <code>lexer.identifier</code> で読み取った文字列が代入されます。これは先ほど <code>parse</code> 関数を使って返ってきた <code>Reply</code> オブジェクトの <code>reply.value</code> の値と同じもので、<code>seq</code>が内部で適当に<code>parse</code>を呼び出してくれているのです。また、<code>value</code> には <code>lexer.naturalOrFloat</code> で読み取った数値が代入されます。あとは <code>return</code> でこのパーサ <code>varStatement</code> で返したいオブジェクトを返せば OK です。この新たなパーサ <code>varStatement</code> は次のように使うことができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var state = new Parsect.State("var hoge = 42;", 0);
var reply = Parsect.parse(varStatement, state); 
console.log("成功したかどうか: " + reply.success);          // true
console.log("現在の位置: "    + reply.state.position);   // 14 
console.log("読み取った情報: " + reply.value);             // "var hoge=42;""
</pre></div></div>

<p>（seqが渡してくる <code>s</code> という謎の関数オブジェクトは、パーサを実行しつつ値を取り出すための Parsect 特有の仕組みです。本家 Parsec だと Haskell 特有の言語機能(do記法)を使ってすっきりと書くことができるのですが、この言語機能は他の言語には存在しないので、このあたりは移植版それぞれで違う書き方になっています。Parsect では Parsec での書き方に似せるためにこの <code>seq</code> 関数を導入していますし、Java版 jparsec やRuby版 rparsec はまた違った方法で書くようになっています。Parsectと同じく JavaScript版の jsparsec も Parsec に似せようとはしてるようですが、Parsect とはまったく違う設計になっています。</p>

<p>この <code>seq</code> 関数を使うパースですが、このコールバック関数内にブレークポイントを仕掛けると、その時点でパースを一時停止することができたりします。このとき、<code>name</code>や<code>arg</code>に代入されている値を調べたり、<code>s</code>関数の <code>s.suceess</code> で現在パースが成功しているかどうか、<code>s.peek</code>で現在読み取ろうとしている文字列部分の情報を取得してデバッグに使うことができます。<code>s.peek</code> をウォッチしながらステップ実行していくと、入力が少しづつ読まれている様子が確認できます。）</p>

<h2>
<span id="何日かかっても書けそうにない演算子式の解析" class="fragment"></span><a href="#%E4%BD%95%E6%97%A5%E3%81%8B%E3%81%8B%E3%81%A3%E3%81%A6%E3%82%82%E6%9B%B8%E3%81%91%E3%81%9D%E3%81%86%E3%81%AB%E3%81%AA%E3%81%84%E6%BC%94%E7%AE%97%E5%AD%90%E5%BC%8F%E3%81%AE%E8%A7%A3%E6%9E%90"><i class="fa fa-link"></i></a>何日かかっても書けそうにない、演算子式の解析</h2>

<p>（ここの節は意味がわからなくていいです。演算子式の構文解析はやたらと難しいということだけわかってください。なるほど、まったくわからん、となるのが目標です）</p>

<p>プログラミング言語というからには、計算ができてなんぼのものでしょう。こんどは加算や減算などの演算子が組み合わさった式をどのように処理するかを見ていきます。まずはもっとも単純に、加算と数値しかない演算子式を考えます。『式』とはどんなものかというと、数値は『式』ですし、『式』と『式』を <code>+</code> でつないだものもやはり『式』です。このとき、数値を <code>NUMBER</code>、『ふたつのうちどちらか』というのを <code>|</code> という記号で表すとすると、式 <code>expr</code> は次のように表現することができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>expr = NUMBER | expr + expr
</pre></div></div>

<p>『式は、数値か、式と式を + で結んだもの』ということです。これを対応するソースコードにすればいいのでしょうか？この形のパーサで <code>1 + 2</code> という式を解析しようとすると、まず <code>1</code> というトークンが <code>NUMBER</code> と <code>expr + expr</code> のどちらかに一致するかを調べますが、この定義では <code>NUMBER</code> のほうが左側にあるのでこっちを先に試します。すると <code>1</code>　は <code>NUMBER</code> に一致するので <code>1</code> が式だということがわかり、めでたく解析は成功……といいたいところですが、実はまだ <code>+ 2</code> という部分が残っています。これでは <code>1 + 2</code> という式を読み取ったことになりません。ここで解析が終わってしまってはまずいのです。</p>

<p>先程は <code>expr + expr</code> より先に <code>NUMBER</code> であるかどうかを調べてしまったのが失敗でした。では、今度は <code>NUMBER</code> と <code>expr + expr</code> を入れ替えて、次のような定義で解析してみてはどうでしょうか。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>expr = expr + expr | NUMBER
</pre></div></div>

<p>この場合は、<code>NUMBER</code> より先に　<code>expr + expr</code> にトークン <code>1</code> が一致するかを調べます。この <code>expr</code> は <code>expr + expr | NUMBER</code> のことですから、<code>1</code> が <code>expr + expr</code> に一致するかどうかを調べるには、<code>|</code> の左側の <code>expr + expr</code> に一致するかを調べないといけないわけで、その <code>expr + expr</code> に一致するかを調べるにはその　<code>expr</code> が何かを調べなければならないわけで……</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>expr = expr + expr
     = (expr + expr) + expr
     = ((expr + expr) + expr) + expr
     ...
</pre></div></div>

<p>というように、<code>1</code> が <code>expr</code> に一致するかを調べていこうとしてもひたすら展開を繰り返してしまうばかりで、<code>1</code> が <code>expr</code> に一致するのかどうかは一向にわかりません。このように無限に再帰し続けてしまうような形式を <strong>左再帰</strong> といいます。本テキストで採用している『再帰下降構文解析』では加算のような単純な式でも、『式 + 式』という直感的な文法では構成できないのです。そのため、このような左再帰を含む文法をどうやって含まない文法に変形するか、というのが再帰下降構文解析では必須の話題になります。演算子式の構成が難しいのは再帰下降構文解析最大の欠点だとも言えるかもしれません。他の解析法だと左再帰を含んでも処理できる場合があるのですが、それはそれでまた別に面倒なアルゴリズムが必要になります。</p>

<p>さらに、<code>*</code> は <code>+</code> よりも優先順位が高いので、優先して結合するように処理しなくてはなりません。また、同じ順位でも結合の方向によって結合のしかたが変わってきます。さらに、演算子は中置演算子だけじゃなくて前置演算子や後置演算子もあります。さらには三項演算子や関数呼び出しのような構文、キャストの構文も入り混じり、とにかくもう複雑で、構成するのがひたすらに難しくて面倒くさいのが、この演算子式なのです。もはや何が面倒くさいのかを説明するのすら面倒くさいというレベル。思いつきでパーサを書き始めた人は、 <strong>だいたいここで挫折</strong> します。</p>

<h2>
<span id="実際は10行にも満たない演算子式の解析器" class="fragment"></span><a href="#%E5%AE%9F%E9%9A%9B%E3%81%AF10%E8%A1%8C%E3%81%AB%E3%82%82%E6%BA%80%E3%81%9F%E3%81%AA%E3%81%84%E6%BC%94%E7%AE%97%E5%AD%90%E5%BC%8F%E3%81%AE%E8%A7%A3%E6%9E%90%E5%99%A8"><i class="fa fa-link"></i></a>実際は10行にも満たない、演算子式の解析器</h2>

<p>というわけで式の解析はとても大変なので、ライブラリに付属している <strong>演算子式のパーサを自動的に構成してくれる機能</strong> を使います。使い方は簡単で、演算子の一覧表と作るのと、式の木構造における末端の項を解析するパーサを用意するだけです。まずは演算子の表をどのように定義するかを見てみます。字句解析器で作った <code>lexer</code> の <code>lexer.prefix</code>、<code>lexer.postfix</code>、<code>lexer.binary</code> は、それぞれ前置演算子、後置演算子、中置演算子を表すオブジェクトを作成する関数です。最初の引数には演算子の記号を文字列で、ふたつめの引数は、その演算子の両辺の式の値（両辺の位置の式をパーサで解析したときの値）を受け取ってその演算子式の値を返す関数です(紙幅の都合で、無名関数リテラルの代わりに <code>=&gt;</code> というアロー関数式を使って書いています。)<br>
。中置演算子はさらに３つ目の引数として結合方向を表す引数もとります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var opTable = [                                                                                         
    [lexer.prefix("-", x=&gt;"-"+x), lexer.prefix("+", x=&gt;x)],                                             
    [lexer.binary("*",  (x,y)=&gt;x+"*"+y,  Parsect.Assoc.Left), lexer.binary("/",  (x,y)=&gt;x+"/"+y,  Parsect.Assoc.Left)], 
    [lexer.binary("+",  (x,y)=&gt;x+"+"+y,  Parsect.Assoc.Left), lexer.binary("-",  (x,y)=&gt;x+"-"+y,  Parsect.Assoc.Left)], 
    [lexer.binary("&lt;",  (x,y)=&gt;x+"&lt;"+y,  Parsect.Assoc.Left), lexer.binary("&gt;",  (x,y)=&gt;x+"&gt;"+y,  Parsect.Assoc.Left)],
    [lexer.binary("==", (x,y)=&gt;x+"=="+y, Parsect.Assoc.Left), lexer.binary("!=", (x,y)=&gt;x+"!="+y, Parsect.Assoc.Left)]
];
</pre></div></div>

<p>この演算子の一覧表 <code>opTable</code> のうち、先頭の方の配列に含まれる演算子ほど優先順位が高くなります。上記の表の場合、単項の <code>+</code>, <code>-</code> がもっとも優先順位が高く、次に <code>*</code>, <code>/</code> 、その次に <code>+</code>, <code>-</code> という順序になることがわかります。演算子を追加したければ、この表にさらに追加すればいくらでも演算子を増やすことができます。この実装では、それぞれの演算子式は単に同じ意味の文字列を作って返すようになっています。</p>

<p>次に、各演算の末端の項となるパーサを用意します。ここでは簡単のために数値と識別子のみが項となるとしましょう。あるふたつのパーサのうちどちらかということを表すには、<code>Parsect.or</code> を使います。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var term = Parsect.or(
    lexer.naturalOrFloat,                           // 数値リテラルか、
    lexer.identifier                                // 識別子
);
</pre></div></div>

<p>ここでは説明のためにかなり簡略化していますが、他にもこの <code>term</code> を他の種類の項に対応させれば、文字列リテラルや括弧で囲まれた式、関数呼び出しの式なども項として書けるように拡張できます。詳しくはあとで紹介する実際のソースコードを見てください。</p>

<p>最後に、関数 <code>buildExpressionParser</code> に演算子の表と項のパーサを渡すだけです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var expr = Parsect.buildExpressionParser(opTable, term);
</pre></div></div>

<p>これで任意の演算子式を解析できるパーサ <code>expr</code> が完成しました。先ほどの変数宣言のパーサにこれを組み込み、変数を初期化するときに任意の式を書けるようにしてしまいましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var varStatement = Parsect.seq(function(s){ 
                s( lexer.reserved("var") ); 
    var name =  s( lexer.identifier      ); 
                s( lexer.reservedOp("=") );  
    var value = s( expr                  );       // NEW!
                s( lexer.semi            );  
    return "var " + name + "=" + value + ";";     
});
</pre></div></div>

<p>これで四則演算などの式でも変数を初期化することができるようになりました。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var state = new Parsect.State("var hoge = 1 + 2 * 42;", 0);
var reply = Parsect.parse(varStatement, state); 
console.log("成功したかどうか: " + reply.success);          // true
console.log("現在の位置: "    + reply.state.position);   // 22
console.log("読み取った情報: " + reply.value);             // var hoge=1+2*42;
</pre></div></div>

<p>やっぱり全然構文解析の勉強にはなりませんが、とりあえず簡単なのはいいことです。左再帰の除去が必要になる言語仕様は普通はこの演算子式くらいなので、ここさえ凌げばあとの構文解析は素直に書いていくだけでなんとかなります。これでパーサ最大の山は越えました。<code>buildExpressionParser</code> という抜け穴で回避しただけですけど。</p>

<h2>
<span id="5分でわかるパーサコンビネータ" class="fragment"></span><a href="#5%E5%88%86%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8B%E3%83%91%E3%83%BC%E3%82%B5%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF"><i class="fa fa-link"></i></a>5分でわかるパーサコンビネータ</h2>

<p>BanchaScriptでは、先ほどの変数宣言の文を次のように何度でも繰り返すことができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var hoge = 42;
var piyo = 10;
var foo = 256;
</pre></div></div>

<p>このようなある構文の繰り返しというのは <code>many</code> という関数にパーサを渡すことで構成する事ができます。例えば、さきほどの <code>varStatement</code> が任意の個数繰り返すことができるなら、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var statements = Parsect.many(varStatement);
</pre></div></div>

<p>とするだけで、その変数宣言が任意の個数繰り返されるテキストを解析するパーサを作れるのです。正規表現の <code>*</code> 量化子みたいなものです。このとき、パーサ全体が読み取った値は、<code>varStatement</code> が読み取った値の配列になります。このように、他のパーサを受け取って別のパーサを作り出す関数を <strong>パーサコンビネータ</strong> といいます。先ほど出てきた <code>seq</code> や <code>or</code> もコンビネータですが、他にもコンビネータは次のようにたくさんあります。</p>

<ul>
<li>
<code>many(p)</code> pの0回以上の繰り返し(正規表現の <code>p*</code> に相当)</li>
<li>
<code>many1(p)</code> 1回以上の繰り返し(正規表現の <code>p+</code> に相当)</li>
<li>
<code>optional(p)</code> 0回か1回 (正規表現の <code>p?</code> に相当)</li>
<li>
<code>or(p, q, r)</code> p, q, r のうちどれかひとつ (正規表現の <code>p|q|r</code> に相当)</li>
<li>
<code>lookAhead(p)</code> 肯定先読み(正規表現の <code>(?=p)</code> に相当)</li>
<li>
<code>notFollowedBy(p)</code> 否定先読み(正規表現の <code>(?!p)</code> に相当)</li>
<li>
<code>repeat(n,m,p)</code> pのn回以上m回以下の繰り返し(正規表現の <code>p{n,m}</code> に相当、Parsecにはない)</li>
</ul>

<p>これらは正規表現にも見られるようなものばかりです。さらに、</p>

<ul>
<li>
<code>sepBy(p, q)</code> qで区切られたp。 <code>sepBy("p", ",")</code> なら <code>p,p,p,p</code> などにマッチ</li>
<li>
<code>between(p, q, r)</code> p,q,rで順番に読み取るが、真ん中のqの値だけ返す (Parsecと引数の順序が異なる)</li>
</ul>

<p>などなどの各種のコンビネータがあります。</p>

<p>パーサコンビネータは Haskell や OCaml のような関数型言語の界隈でよく使われてきましたが、けっして関数型言語の専売特許というわけではありません。メジャーな手続き型言語でももちろん使うことができますし、正規表現で手におえないような複雑な構文解析をするときにはとても役に立つものです。また、昔から構文解析に使われてきた yacc/lex (bison/flex) や ANTLR のようなパーサジェネレータよりずっと柔軟でお手軽です。なにしろただのライブラリなので、構文定義専用の特別な DSL を覚えたり、事前にツールを実行してパーサのソースコードを生成したりという手順が必要ないからです。</p>

<h2>
<span id="100行ちょっとで書けるbanchascriptコンパイラの完成" class="fragment"></span><a href="#100%E8%A1%8C%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%81%A7%E6%9B%B8%E3%81%91%E3%82%8Bbanchascript%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E5%AE%8C%E6%88%90"><i class="fa fa-link"></i></a>100行ちょっとで書けるBanchaScriptコンパイラの完成</h2>

<p>ここまでで変数の宣言の式や演算子式を構文解析できるようになりました。あとは、基本的には同じ調子で関数定義やら何やらの文のパーサを定義して、<code>Parsect.or</code> や <code>Parsect.many</code> のコンビネータでつなぎ合わせるだけです。BanchaScript の関数定義はつぎのようなものです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>def hoge(k){
    var x = k * 2;
    return x;
}
</pre></div></div>

<p>これを読み取る関数定義のパーサも、先ほどの変数宣言と同じように <code>seq</code> を使ってトークンや式が出現する順番でひとつづつパーサを適用して読み取っていくだけです。まず<code>def</code>という予約語があって、識別子（関数名）、括弧で囲まれてカンマで区切られた識別子（引数）の列、中括弧で囲まれた文の列。これを <code>seq</code> で順番に読んでいきます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>// 関数の定義
var func = p.seq(s=&gt;{                       
    // 最初に予約語 def があって、
    s( lexer.reserved("def") );  

    // 関数名
    var name = s( lexer.identifier );       

    // コンマで区切られた識別子が、括弧で囲まれたものがあって（これが引数 args）
    var args = s( lexer.parens(p.sepBy(lexer.identifier, lexer.comma)) );   

    // 複数の文が中括弧で囲まれたものがある
    var body = s( lexer.braces(p.many(p.or(func, returnStatement, varStatement, exprStatement))) );     

    // 対応するJavaScriptコードを返す
    return s.success &amp;&amp; ["function ", name, "(", args.join(','), "){", body.join(""), "}"].join('');    
});
</pre></div></div>

<p>筆者が BanchaScript のためにこれまでに実装したコードは 100行強ですが、以下の様な機能が実現できました。</p>

<ul>
<li>関数の定義</li>
<li>関数の呼び出し</li>
<li>変数の定義</li>
<li>if文</li>
<li>四則演算</li>
<li>ネストできるコメント</li>
</ul>

<p>まだ for 文などの制御文すらありませんが、ひとまず四則演算はできますし、関数だけあればあとはなんとかなる気がしないでもないので、ひとまずこれだけの言語仕様に留めておきます。</p>

<h2>
<span id="10分くらいでわかるbanchascriptのユーザ定義演算子" class="fragment"></span><a href="#10%E5%88%86%E3%81%8F%E3%82%89%E3%81%84%E3%81%A7%E3%82%8F%E3%81%8B%E3%82%8Bbanchascript%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B6%E5%AE%9A%E7%BE%A9%E6%BC%94%E7%AE%97%E5%AD%90"><i class="fa fa-link"></i></a>10分くらいでわかるBanchaScriptのユーザ定義演算子</h2>

<p>せっかくなのでBanchaScriptにはあまり他の AltJS 系の言語では見られない珍しい機能をつけようと思い、 <strong>演算子のユーザ定義</strong> を盛り込むことにしました。これは C++ や C# にあるような『演算子オーバーロード』ではなくて、優先順位と結合方向を指定した演算子をユーザが任意に記号を組み合わせて定義できるというものです。HaskellやSML、OCaml、Scalaあたりにはこの機能があります。BanchaScriptでは前置、後置、中置や優先順位、結合方向をすべて指定できますが、ここまでできる言語はかなり稀だと思います。たとえば、BanchaScriptでは次のような文でベクトルの加算を行う新たな演算子 <code>=+=</code> を定義することができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>operator =+= infixl 2 = addVectors;
</pre></div></div>

<p><code>infixl 2</code> というのは新たな演算子 <code>=+=</code> が優先順位が2で左結合の中置演算子であることを示します。このとき、関数 <code>addVectors</code> の別名として <code>=+=</code> が定義され、 <code>a =+= b</code> という式は <code>addVectors(a, b)</code> という式へとコンパイルされます。BanchaScriptでのユーザ演算子は単なる他の関数の別名です。ベクトル演算をするときはかなり複雑な計算式になることが多く、これを関数呼び出しやメソッド呼び出しで書こうとすると括弧だらけになってとてもつらいのです。</p>

<p>BanchaScriptではもっとフリーダムな演算子も定義できます。次の前置演算子 <code>|^_^|&lt;</code> は標準出力する関数 <code>log</code> の別名です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>// 演算子の定義
operator |^_^|&lt; prefix 5 = log; 

// こうやってつかいます
|^_^|&lt; "わたしです";
</pre></div></div>

<p>ユーザ定義演算子があるということは事前に構文を書き下すことができないので、この機能がある言語は構文解析がかなり難しくなってしまいます。特に、事前にパーサを生成してしまうパーサジェネレータの類でこれを実現するのは困難です。BanchaScriptコンパイラでは、演算子の定義を見つけると、それと同時にパーサの一部をその場で書き換えて次の行から新しいパーサで構文解析を継続することで、１パスで構文解析を済ませるようになっています。BanchaScriptコンパイラには、次のような <code>topLevelStatement</code> という変数があり、現在の演算子テーブルからパーサを構成する <code>buildStatementParser</code>　という関数を呼び出すことで初期化されています。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var topLevelStatement = buildStatementParser();
</pre></div></div>

<p>パーサ全体はトップレベルのステートメントをパースしようとするたびに適宜この変数を参照し、この変数に代入されているパーサのオブジェクトを呼び出しながらながらパースを行っています。関数 <code>buildStatementParser</code> は現在の演算子テーブルをもとにパーサを構成しますが、そのパーサは演算子の定義を見つけると次のように演算子テーブルに演算子を追加し、新たなパーサを再構築して先ほどの <code>topLevelStatement</code> に代入しています。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>opTable[precedence].push(newOperator);
topLevelStatement = buildStatementParser();
</pre></div></div>

<p>パーサを動的に書き換えるといっても、単に変数をひとつ書き換えているだけで難しいことは何もしていません。パーサコンビネータでは動的にパーサの構成を変化させることができるので、このような無茶な言語仕様でも簡単に構文解析できるのです。</p>

<h2>
<span id="ソースコード" class="fragment"></span><a href="#%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89"><i class="fa fa-link"></i></a>ソースコード</h2>

<p>BanchaScriptコンパイラは <a href="https://github.com/kontan/Parsect/blob/master/example/bancha/bancha.ts" rel="nofollow noopener" target="_blank">Parsect のサンプル</a>　として一緒に github で公開してますので、覗いてみたい方はどうぞ。Parsectにはまだあまりちゃんとマニュアルが書かれていないので、同梱されているサンプルコードを参考にしたり、本家 Parsec の解説を参考にしてみるといいかもしれません。かなり古くなっていますが、readmeも多少は参考になります。</p>

<p><a href="https://github.com/kontan/Parsect" rel="nofollow noopener" target="_blank">kontan/Parsect</a></p>

<p>おまけですが、BanchaScriptのコンパイルと実行をブラウザで試せる Playground を作ってみました。でも機能が足りなさすぎてアレです。</p>

<p><a href="http://phyzkit.net/banchascript/bancha.html" rel="nofollow noopener" target="_blank">BanchaScript Playground</a></p>

<h2>
<span id="その他のパーサコンビネータ実装" class="fragment"></span><a href="#%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE%E3%83%91%E3%83%BC%E3%82%B5%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E5%AE%9F%E8%A3%85"><i class="fa fa-link"></i></a>その他のパーサコンビネータ実装</h2>

<p>先程も簡単に触れましたが、パーサコンビネータの実装は案外たくさんあります。</p>

<ul>
<li>Haskell, <a href="http://hackage.haskell.org/package/parsec-3.1.3" rel="nofollow noopener" target="_blank">Parsec</a>
</li>
<li>Java, <a href="http://jparsec.codehaus.org/" rel="nofollow noopener" target="_blank">jparsec</a>
</li>
<li>Python, <a href="http://pyparsing.wikispaces.com/" rel="nofollow noopener" target="_blank">pyparsing</a>
</li>
<li>Ruby, <a href="http://docs.codehaus.org/display/JPARSEC/Ruby+Parsec" rel="nofollow noopener" target="_blank">rparsec</a>
</li>
<li>Perl, <a href="http://search.cpan.org/%7Edconway/Parse-RecDescent-1.94/lib/Parse/RecDescent.pod" rel="nofollow noopener" target="_blank">Parse::RecDescent</a>
</li>
<li>JavaScript, <a href="https://code.google.com/p/jshaskell/" rel="nofollow noopener" target="_blank">jsparsec(jshaskell)</a>
</li>
<li>C++, <a href="http://www.boost.org/doc/libs/1_54_0/libs/spirit/doc/html/index.html" rel="nofollow noopener" target="_blank">boost Spirit</a>
</li>
<li>Objective-C, <a href="https://github.com/brotchie/Parcoa" rel="nofollow noopener" target="_blank">Parcoa</a>
</li>
<li>Scala, <a href="http://www.scala-lang.org/api/current/index.html#scala.util.parsing.combinator.Parsers" rel="nofollow noopener" target="_blank">scala.util.parsing.combinator</a>
</li>
<li>C#, <a href="http://jparsec.codehaus.org/NParsec+Tutorial" rel="nofollow noopener" target="_blank">NParsec</a>, <a href="http://www.nuget.org/packages/Parseq/" rel="nofollow noopener" target="_blank">Parseq</a>
</li>
<li>PHP, <a href="http://qntm.org/loco" rel="nofollow noopener" target="_blank">Loco</a>
</li>
<li>Clojure, <a href="https://github.com/joshua-choi/fnparse" rel="nofollow noopener" target="_blank">fnparse</a>
</li>
</ul>

<p>探せばどの言語でもひとつくらいは見つかりそうです。Perl使いやRuby使いは正規表現(？)で何でも構文解析してそうですけど、パーサコンビネータも意外とあるものです。自分のよく使う言語のものを探して使ってみると良いのではないでしょうか。<code>makeTokenParser</code> や <code>buildExpressionParser</code>相当の機能があるライブラリは特に便利です。筆者のおすすめはやはり遅延評価やdo記法があるHaskellのParsecです。切れ味が違います。</p>

<h2>
<span id="まとまっていないまとめ" class="fragment"></span><a href="#%E3%81%BE%E3%81%A8%E3%81%BE%E3%81%A3%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%BE%E3%81%A8%E3%82%81"><i class="fa fa-link"></i></a>まとまっていないまとめ</h2>

<ul>
<li>自分の理想の言語を作る → 楽しい三(^q^)三</li>
<li>パーサコンビネータを使えば複雑な構文解析も楽勝</li>
<li>よく訓練されたParsec使いは<a href="http://d.hatena.ne.jp/kazu-yamamoto/20090309/1236590230" rel="nofollow noopener" target="_blank">Perl6の完全なパーサを15分で書ける</a>らしい。なにそれこわい</li>
</ul>

<h2>
<span id="関連資料" class="fragment"></span><a href="#%E9%96%A2%E9%80%A3%E8%B3%87%E6%96%99"><i class="fa fa-link"></i></a>関連資料</h2>

<ul>
<li>
<a href="http://kmaebashi.com/programmer/devlang/" rel="nofollow noopener" target="_blank">プログラミング言語を作る</a> 昔ながらの yacc/lex による手法</li>
<li><a href="http://www.atmarkit.co.jp/news/200708/07/ll3.html" rel="nofollow noopener" target="_blank">「なぜ作ったのか？」、オレ様言語作った人々</a></li>
<li><a href="http://www.gadgety.net/shin/tips/unix/compiler.html" rel="nofollow noopener" target="_blank">コンパイラの構造を解説</a></li>
</ul>
</div>
	</td>
</tr>
</table>
<br />
<table border="1">
<tr>
	<td rowspan="3"><center>KDKTNさんの<br />5位</center></td>
	<td colspan="3">
		<kbd><i><img alt="いいね" width="16" height="16" src="../thumb-up-120px.png" /></i>120</kbd>
		<a target="_blank" href="https://qiita.com/KDKTN/items/5fb1563ac2790d0ac265">関数こそ、数値、オブジェクト、配列……そういうあらゆる垣根を乗り越え語り合える、共通の言語なのだ！</a>
	</td>
</tr>
<tr>
	<td style="width:100px;"><center>投稿日時</center></td>
	<td style="width:200px;"><center>投稿者</center></td>
	<td style="width:150px;"><center>タグ</center></td>
	<td style="width:350px;"><center>本文</center></td>
</tr>
<tr>
	<td style="width:100px;">
		<!--投稿日時--><center>2013-09-06 07:22:37</center>
	</td>
	<td style="width:200px;">
		@KDKTN<br />(私立リリアン女学園高等部 所属)<br><img width="80" height="80" src="https://pbs.twimg.com/profile_images/3438615386/d591fae08d7433a2149c04ff8995ceec_normal.png">
	</td>
	<td style="width:150px;">
		<!--タグ-->
		<center><b>[JavaScript]</b> <b>[TypeScript]</b> <b>[ラムダ計算]</b> </center>
	</td>
	<td style="width:350px;">
		<!--本文-->
		<div style="width:350px;height:150px;overflow-x:hidden;overflow-y:scroll;"><p>本テキストはJavaScriptで<code>number</code>も<code>string</code>も<code>new</code>も<code>if</code>も<code>for</code>も配列もプロパティへのアクセスもまったく使わず、ただ1引数の関数の定義と呼び出しを自在に組み合わせることで真偽値をはじめ数値やリストといったあらゆるデータ型を作り出し、それらの値を使って計算を行う手法を紹介するものです。紹介するソースコードは<a href="http://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%A0%E3%83%80%E8%A8%88%E7%AE%97" rel="nofollow noopener" target="_blank">ラムダ計算</a>やチャーチエンコーディングと呼ばれているものをJavaScript/TypeScriptで実装したもので、計算の結果を人間に読みやすいよう入出力するためだけに限って関数以外の機能も使いますが、入出力以外のソースコードはすべて関数定義および関数適用のみからできています。まさに純粋のなかの純粋な関数プログラミング、究極のシンプルプログラミングとでも言えるものです。</p>

<p>本テキストでは説明にJavaScript/TypeScriptを使って説明はしていますが、特にこれらの言語に馴染みがなくても理解のためには問題ないと思います。オブジェクト指向言語とはいってもクラスやオブジェクトといった概念はほとんど登場しないので、オブジェクト指向が苦手な皆様にも大変お勧めの記事となっています。ただし、本テキストで解説されている知識はほぼ純粋に理論的背景に対する関心に基づくものであり、残念ながら <strong>実用性はほとんどゼロ</strong> であることをご了承の上で閲覧頂くようお願い申し上げます（でも<code>Tuple</code>や<code>Either</code>なんかはたぶん実用上もそれなりに役に立つと思いますよ！）。</p>

<h5>
<span id="お勧めの読者層" class="fragment"></span><a href="#%E3%81%8A%E5%8B%A7%E3%82%81%E3%81%AE%E8%AA%AD%E8%80%85%E5%B1%A4"><i class="fa fa-link"></i></a>お勧めの読者層</h5>

<ul>
<li>『関数』っていうのを聞いたことある人</li>
<li>順次、反復、分岐の３要素がプログラミング言語の言語仕様には必要だと信じている人</li>
<li>プログラミング言語の言語仕様はシンプルなほど美しいと思ってる人</li>
<li>staticおじさん</li>
</ul>

<h5>
<span id="そもそもなぜjavascriptで" class="fragment"></span><a href="#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82%E3%81%AA%E3%81%9Cjavascript%E3%81%A7"><i class="fa fa-link"></i></a>そもそもなぜJavaScriptで？</h5>

<p>本テキストで扱う『ラムダ計算』は紙の上でやってもいいのですが、手計算すると非常に間違えやすく面倒です。ラムダ計算はある種のプログラミング言語であるとも理解できますので、専用のコンパイラやインタプリタなら幾つかありますが、JavaScriptならブラウザで誰でもすぐに実行を試せますし、必要ならデバッガで処理の途中の状態を覗き見ることができます。JavaScriptは関数を第一級の対象として比較的扱いやすい言語であるという理由もあります。さらに、TypeScriptを使うと静的な型注釈を書けるので、説明をしやすいのです。</p>

<p>また、単純なラムダ計算の記法はとても可読性が低く、それによる学習効率の低下があまりに大きいのではないかと思います。既存のプログラミング言語のフレームワーク上で適切な関数名や適切な型注釈を用いることで、とても理解しやすい形でラムダ計算を学ぶことができるのではないかと考えています。</p>

<h2>
<span id="オブジェクトなんかなくていいっリテラルもいらないっ関数っ書かせてくれよっごく普通の定義適用" class="fragment"></span><a href="#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AA%E3%82%93%E3%81%8B%E3%81%AA%E3%81%8F%E3%81%A6%E3%81%84%E3%81%84%E3%81%A3%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%E3%82%82%E3%81%84%E3%82%89%E3%81%AA%E3%81%84%E3%81%A3%E9%96%A2%E6%95%B0%E3%81%A3%E6%9B%B8%E3%81%8B%E3%81%9B%E3%81%A6%E3%81%8F%E3%82%8C%E3%82%88%E3%81%A3%E3%81%94%E3%81%8F%E6%99%AE%E9%80%9A%E3%81%AE%E5%AE%9A%E7%BE%A9%E9%81%A9%E7%94%A8"><i class="fa fa-link"></i></a>オブジェクトなんか、なくていいっ……！リテラルもいらないっ……！関数っ……！書かせてくれよっ……！ごく普通の定義……適用……！</h2>

<p>はじめに今回使う材料について説明しておきます。使うものは基本的に次の３種類です。</p>

<h3>
<span id="関数の定義" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E3%81%AE%E5%AE%9A%E7%BE%A9"><i class="fa fa-link"></i></a>関数の定義</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function NAME ( ARG ){ return EXPR ; }
</pre></div></div>

<p>この定義は <code>NAME(ARG)</code> を式 <code>EXPR</code> に置き換えることを示します。関数名の <code>NAME</code> は省略されることもあり、その場合は無名関数となります。いくつか簡単なルールを決めておきます。</p>

<ul>
<li>かならず１引数の関数とします。</li>
<li>返り値も<code>void</code>ではなく必ず何かあるものとします。</li>
<li>ひとつの関数内にステートメントはひとつだけです。セミコロンで区切って複数書くことは必要ないのでしません。</li>
<li>
<code>function</code> や <code>return</code> というキーワードが冗長なので、代わりに <code>ARG =&gt; EXPR</code> という TypeScript のシンタックスシュガー（アロー関数式）を使うこともあります。<code>ARG =&gt; EXPR</code> もコンパイル後は <code>function(ARG){ return EXPR; }</code> という形式になるので意味はまったく同じです。</li>
</ul>

<h3>
<span id="関数適用" class="fragment"></span><a href="#%E9%96%A2%E6%95%B0%E9%81%A9%E7%94%A8"><i class="fa fa-link"></i></a>関数適用</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>FUNC(EXPR)
</pre></div></div>

<p>関数のあとに括弧と、その括弧のなかに任意の式を書けば関数の適用です。<code>FUNC</code> や <code>EXPR</code>は関数名や引数のときもありますし、関数適用の式やfunction式であることもあります。</p>

<h3>
<span id="優先順位の括弧" class="fragment"></span><a href="#%E5%84%AA%E5%85%88%E9%A0%86%E4%BD%8D%E3%81%AE%E6%8B%AC%E5%BC%A7"><i class="fa fa-link"></i></a>優先順位の括弧</h3>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>( EXPR )
</pre></div></div>

<p>関数適用の優先順位を示すための括弧も使うときがあります。関数適用の括弧と非常に紛らわしいので、心の目を鍛えてください。とくに、アロー関数式と一緒によく使います。次のアロー関数式、</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>x =&gt; y(z)
</pre></div></div>

<p>は『引数 <code>x</code> をとり、<code>y(z)</code> を返す無名関数』を意味しており、あえて優先順位を示す括弧を付け加えると</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>x =&gt; (y(z))
</pre></div></div>

<p>となります。次のような</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>(x =&gt; y)(z)
</pre></div></div>

<p>という『引数 <code>x</code> をとり <code>y</code> を返す無名関数に、<code>z</code> を適用する』という意味ではないことに注意してください。言い換えれば、前者の式の場合は優先順位の括弧を省略できますが、後者の式の場合は明示的な優先順位の括弧が必要になります。他にも、長めの式の途中で改行したいときに全体を優先順位の括弧で囲むことで、ひとつの大きな式であることを示すためにも使います。</p>

<p>これで必要なものは揃いました。あとはコメントや型注釈くらいは自由に使いますが、プログラムの振る舞いに関するものはこれですべてです。最初に述べたとおり、<code>boolean</code>も<code>number</code>も<code>string</code>も一切使わず、全部自力で定義していきます。でもこれから記述していくコードはすべてJavaScript/TypeScriptのサブセットなので、ブラウザなどで実際に実行して試すことができます。</p>

<h2>
<span id="さあいけっもう一度漕ぎ出せっ勝負の大海へっ" class="fragment"></span><a href="#%E3%81%95%E3%81%82%E3%81%84%E3%81%91%E3%81%A3%E3%82%82%E3%81%86%E4%B8%80%E5%BA%A6%E6%BC%95%E3%81%8E%E5%87%BA%E3%81%9B%E3%81%A3%E5%8B%9D%E8%B2%A0%E3%81%AE%E5%A4%A7%E6%B5%B7%E3%81%B8%E3%81%A3"><i class="fa fa-link"></i></a>さあ、いけっ……！もう一度漕ぎ出せっ……！勝負の大海へっ……！</h2>

<p>さて、いよいよ関数だけからなる青き清浄なる世界の構築を始めるときがきましたが、まず何をしたらいいでしょうか。関数以外の既存のあらゆるデータ型、あらゆるオブジェクトは存在しません（使用禁止）ので、まだ文字列はおろか整数や真偽値もありません。関数は使えますが、まだひとつも関数が定義されていないので呼び出せる関数もありません。となれば、なんでもいいのでまず何か新たな関数を定義してみるのが良さそうです。仮に <code>f</code> という名前でひとつ関数を定義してみましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f(x){
    return ????? ;
}
</pre></div></div>

<p>さて、return文に何か式を書かないと関数の定義は完成しませんが、いったい何を書いたらいいでしょうか？おそらく真っ先に思いつくのは、たった今受け取ったばかりの引数 <code>x</code> をそのまま返すことでしょう。そうすると、この関数は値を同じ値に移す <strong><a href="http://ja.wikipedia.org/wiki/%E6%81%92%E7%AD%89%E5%86%99%E5%83%8F" rel="nofollow noopener" target="_blank">恒等関数</a></strong> となります。値をそのまま返すだけではあまり役に立ちそうにないと思うかもしれませんが、実はこの関数もとても大事な関数です。世界で最もシンプルな関数、関数の中の関数とでもいえるようなすごい関数です。<code>f</code>なんていういい加減な名前ではあまりにかわいそうなので、もう少し良い名前を付けてあげましょう。ここではこの関数を<code>unit</code>と呼ぶことにします(恒等関数はふつうidentity functionですけど、ここでいうunitとは<a href="http://ja.wikipedia.org/wiki/%E5%8D%98%E9%9B%86%E5%90%88" rel="nofollow noopener" target="_blank">単位集合</a>の意味だと考えるといいと思います)。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function unit(x){
    return x ;
}
</pre></div></div>

<p>つまり、<code>unit(x)</code> というような式があったら、 <code>x</code> へと書き換えることができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>unit(x) = x
</pre></div></div>

<p>ちなみに、この関数に型注釈をつけるとどうなるでしょうか。引数の型や返り値の型は？まだ何も型は定義されていませんから、具体的な型を指定することはできません。型変数を導入して<code>x</code>の型を示すとよいでしょう。TypeScriptでは次のように関数名のあとに <code>&lt;T&gt;</code> とすると、型変数 <code>T</code> を新たに導入することができます。<code>unit</code> は引数をそのまま返しますから、返り値も <code>T</code> になります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function unit&lt;T&gt;(x: T): T {
    return x ;
}
</pre></div></div>

<p>型変数の実際の型は、その関数が使われたときに決定されます。たとえば、<code>unit(10)</code> という式における <code>unit</code> の型は <code>unit(x: number): number</code> ですし、<code>unit("a")</code> なら <code>unit(x: string): string</code> と引数の値によって自動的に選択されることになります。もし<code>number</code> や <code>string</code> があれば、の話ですが。我々の世界にはまだそれすらありません。</p>

<p>ソースコードを理解しやすくするために、今後はなるべく型注釈もつけることにしましょう。こうした定義や計算を行っていると、この式の値は何を表しているのかわからなくなってくることがよくあります。なにしろすべて関数ですから、<code>instanceof</code>で調べるだとかいうこともまったく不可能です（ポジティブに考えれば、<code>instanceof</code>で型を調べる必要がまったくないともいえます）。TypeScript形式で型注釈をつけていきますが、とりあえず関数の型注釈の書き方だけわかれば、その他のTypeScriptについての知識はなくても大丈夫です。なにしろ関数しか出てきませんからね。</p>

<h2>
<span id="値は返す値は返すがまだその時の指定まではしていないそのことをどうか諸君らも思い出していただきたいつまりbottomがその気になれば値の受け渡しは年後ということも可能だろうということ" class="fragment"></span><a href="#%E5%80%A4%E3%81%AF%E8%BF%94%E3%81%99%E5%80%A4%E3%81%AF%E8%BF%94%E3%81%99%E3%81%8C%E3%81%BE%E3%81%A0%E3%81%9D%E3%81%AE%E6%99%82%E3%81%AE%E6%8C%87%E5%AE%9A%E3%81%BE%E3%81%A7%E3%81%AF%E3%81%97%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%9D%E3%81%AE%E3%81%93%E3%81%A8%E3%82%92%E3%81%A9%E3%81%86%E3%81%8B%E8%AB%B8%E5%90%9B%E3%82%89%E3%82%82%E6%80%9D%E3%81%84%E5%87%BA%E3%81%97%E3%81%A6%E3%81%84%E3%81%9F%E3%81%A0%E3%81%8D%E3%81%9F%E3%81%84%E3%81%A4%E3%81%BE%E3%82%8Abottom%E3%81%8C%E3%81%9D%E3%81%AE%E6%B0%97%E3%81%AB%E3%81%AA%E3%82%8C%E3%81%B0%E5%80%A4%E3%81%AE%E5%8F%97%E3%81%91%E6%B8%A1%E3%81%97%E3%81%AF%E5%B9%B4%E5%BE%8C%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%82%82%E5%8F%AF%E8%83%BD%E3%81%A0%E3%82%8D%E3%81%86%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8"><i class="fa fa-link"></i></a>値は返す……！値は返すが……まだその時の指定まではしていない。そのことをどうか諸君らも思い出していただきたい……！つまり……bottomがその気になれば、値の受け渡しは∞年後ということも可能だろう……ということ……！</h2>

<p>これで最初の関数 <code>unit</code> が手に入りました。でも、この関数はそのまま値を帰すだけですから、これだけではなにか役に立つ計算はできそうにありません。何かほかに関数の定義はできないでしょうか。先ほどのように <code>f</code> を考えます。<code>f</code>が定義され、<code>x</code> があるのですから、<code>f(x)</code> というように適用することができます。これを<code>f</code>の返り値として返したらどうなるでしょうか。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f(x) {
    return f(x) ;
}
</pre></div></div>

<p>この関数はいつも自分自身を呼び出しているので、<code>f(x)</code> はそのまま <code>f(x)</code> に書き換わります。つまり、決して関数呼び出しが終わることはありません。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>f(x) = f(x) = f(x) = f(x) = f(x) = ...
</pre></div></div>

<p>このコードを実際に実行すると、現実にはリソースは有限ですからスタックオーバーフローでエラーになるでしょう。絶対にエラーになる関数なんて定義して何の役にたつのかと思うでしょうけれど、ひとまず型注釈を付けてその正体を探ってみましょう。</p>

<p>引数は適当に型変数 <code>T</code> を導入して表すとして、問題はこの関数の返り値です。<code>f(x)</code> を返すのですから、その<code>f</code>の返り値の型を知らなければなりません。そしてその<code>f</code>は<code>f(x)</code>を返すのですから……と考えていくと、ひたすら巡回していくばかりで、いつまでたっても<code>f(x)</code>が何を返すのかさっぱりわかりません。こういう場合は『もし仮に〇〇だったら』と考えるといいです。たとえば、<code>f(x)</code>は引数の型と同じ<code>T</code>を返すとしたらどうでしょうか。仮に <code>f(x)</code> は <code>T</code> としたら、 <code>f</code> の返り値は <code>T</code> なんですから、<code>f(x)</code> が <code>T</code> になるという仮定と矛盾しません。なので、次のように型注釈をつけることができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f&lt;T&gt;(x: T): T {
    return f(x) ;
}
</pre></div></div>

<p>でも、実は新たにもうひとつの型変数 <code>S</code> を導入して考えてみると、また別の側面が見えてきます。もし <code>f(x)</code> が <code>T</code> だとは限らず、<code>S</code> を返すとしたらどうでしょうか。<code>f(x)</code>が<code>S</code>だと仮定すると、<code>f</code>の返り値は<code>S</code>ですから、<code>f(x)</code>が<code>S</code>だという仮定に矛盾しません。したがって、次のようにも型注釈をつけることができるのです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f&lt;T,S&gt;(x: T): S {
    return f(x) ;
}
</pre></div></div>

<p>どこからも<code>S</code>型の値は受け取っていないのに、なぜかつじつまがあってしまいました。<code>S</code>なんて持っていないくせに、この関数<code>f</code>はもし呼び出されたらどこから<code>S</code>を持ってきて返すつもり気なのでしょうか。でも大丈夫です。この関数の呼び出しは決して終わらないので、<code>S</code>を返す期限は決して訪れないのです。<code>T</code> でも <code>S</code>でもどちらでもつじつまはあいますが、<code>S</code>としておいたほうが柔軟なのでそうしておきます。</p>

<p>この関数は呼び出すとかならずエラーになってしまいますが、見かたを変えれば意図的にエラーを起こすことに使えるといえます。なにしろ <code>throw</code> すら使用禁止ですから、プログラムを途中で止めたいときに何かエラーをわざと起こす方法があったほうがいいのです。この関数を <code>bottom</code> と呼ぶことにしましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function bottom&lt;T,S&gt;(x: T): S {
    return bottom(x);
}
</pre></div></div>

<p>この関数は呼び出すと絶対にエラーになるというのも変ですが、一番奇妙なところは、どんな型の値でもコード上は作り出せてコンパイルが通ってしまうということでしょう。たとえはあるクラスのコンストラクタがプライベートになっていて絶対にインスタンスを作成する方法がなかったとしても、この関数を使えばコード上はそのクラスの型の引数などに返り値を代入することができてしまうのです。『どんな型の値にもなれる』『参照するとエラーになる』ということからわかるかもしれませんが、この関数の値は要するに<code>undefined</code>に相当していると考えることができます。</p>

<h2>
<span id="変でいい変でなきゃダメだ狂ってなきゃ逸脱してなきゃオブジェクトは殺せない" class="fragment"></span><a href="#%E5%A4%89%E3%81%A7%E3%81%84%E3%81%84%E5%A4%89%E3%81%A7%E3%81%AA%E3%81%8D%E3%82%83%E3%83%80%E3%83%A1%E3%81%A0%E7%8B%82%E3%81%A3%E3%81%A6%E3%81%AA%E3%81%8D%E3%82%83%E9%80%B8%E8%84%B1%E3%81%97%E3%81%A6%E3%81%AA%E3%81%8D%E3%82%83%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AF%E6%AE%BA%E3%81%9B%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>変でいい、変でなきゃダメだ……狂ってなきゃ、逸脱してなきゃオブジェクトは殺せない……！</h2>

<p>さらに別の <code>f</code> の定義を考えてみましょう。<code>f</code>を定義しようとすると、そのときにすでに<code>f</code>を使うことができるので、こんな定義も可能なのではないでしょうか。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f&lt;T&gt;(x: T): ?????? {
    return f;
}
</pre></div></div>

<p>この関数は何を適用してもその関数がまた返ってきますから、たとえば <code>x</code> という値があったとすると、次のように何回でも連続して適用し続けることができます。まるで可変長引数の関数のようです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>f(x)(x)(x)(x)(x)(x)(x)(x)(x)(x)(x)(x).....
</pre></div></div>

<p>ということはこの関数の型は限りなく長くなってしまうので、そのままではうまく型注釈をつけることができません。でも、次のように型の別名を使って再帰的に定義すれば型注釈をつけることはできます。<code>interface</code> は型に別名をつけるもので、 『 <code>F&lt;T&gt;</code> は <code>(x: T): F&lt;T&gt;</code> の別名だ』というように読みます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>interface F&lt;T&gt; {
    (x: T): F&lt;T&gt;;
}

function f&lt;T&gt;(x: T) : F&lt;T&gt; {
    return f;
}
</pre></div></div>

<p>この関数は何か使い道があるのかどうか、自分もよくわかりません。値を返すことができない以上、<code>f</code>がなんらかの副作用を持っていなければ意味がなさそうにも思います。何かいい使い道が思いついたら、何かもっと適切な名前をつけてあげようと思います。⇒『<a href="http://ssl.ohmsha.co.jp/cgi-bin/menu.cgi?ISBN=978-4-274-06911-6" rel="nofollow noopener" target="_blank">型システム入門</a>』では『空腹関数』(Hungry function)という名前で呼ばれていました。</p>

<p>もうひとつ奇妙な関数をみつけました。引数<code>x</code>をとり、<code>x</code>に<code>x</code>を適用するというものです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function g(x) {
    return x(x);
}
</pre></div></div>

<p>この関数の型はどうなるでしょうか？というか、この引数<code>x</code>が関数なのかどうかもわかりませんから、本当に関数適用しちゃっていいのでしょうか？でもこの世界には関数しかないから、やっぱり<code>x</code>は関数のはずで……？とにかく型注釈を付けてみます。少々頭を捻ると、次のような型注釈ができることがわかります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>interface W {
    &lt;S&gt;(x: W): S;
}

function g&lt;S&gt;(x: W): S {
    return x(x);
}
</pre></div></div>

<p>この関数の型もまた再帰していて、相当に奇妙に思えます。ちょっとびっくりですが、この関数については使い道をみつけました。というか、いろんな関数を実装していて、ある関数の定義の一部にこの変な関数が現れることに気付きました。大人の自乗で詳しい説明は省きますが、たぶん何か名前が付いている関数だと思います。不勉強でまだ良くわからないのですが、もしこの関数が何なのか知っているひとがいたら教えてください。⇒奴の身元が割れました！こいつは <strong>U Combinator</strong> っていうそうです。alucky0707 さんありがとうございます。⇒もう一個表現見つけました。<a href="http://ja.wikipedia.org/wiki/SKI%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E8%A8%88%E7%AE%97" rel="nofollow noopener" target="_blank">SKIコンビネータ計算</a>でいう SII がコレと同じようです。</p>

<h2>
<span id="trueじゃなきゃfalseこの仕組みはこの世の姿そのもの基本も基本大原則だっ" class="fragment"></span><a href="#true%E3%81%98%E3%82%83%E3%81%AA%E3%81%8D%E3%82%83false%E3%81%93%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%AF%E3%81%93%E3%81%AE%E4%B8%96%E3%81%AE%E5%A7%BF%E3%81%9D%E3%81%AE%E3%82%82%E3%81%AE%E5%9F%BA%E6%9C%AC%E3%82%82%E5%9F%BA%E6%9C%AC%E5%A4%A7%E5%8E%9F%E5%89%87%E3%81%A0%E3%81%A3"><i class="fa fa-link"></i></a>trueじゃなきゃfalse……この仕組みはこの世の姿そのもの……。基本も基本、大原則だっ……！</h2>

<p>さて、ここまで幾つか関数を定義してみましたが、どうにも何か計算したりデータ型を定義できそうな要素は見えてこないと思います。でもさっきまでの作業は純粋な関数の世界に慣れるためのほんのウォーミングアップに過ぎません。一番簡単なものから練習していかないと、すぐ躓いてしまいますからね。これでウォーミングアップは終わりましたので、ここから遂に我々が普段毎日のようにお世話になっているものを我々の純粋な世界にも作り出します。</p>

<p>ウォーミングアップは終わりましたが、これまでと同じように <code>f</code> にどんな定義ができそうなのかを考えていきます。そういえば <code>unit</code>を定義したので、<code>unit</code>を返す関数を定義してみたらどうでしょうか。<code>f</code>の引数の型と<code>unit</code>の引数の型は同じでなければダメということはないので、新たに<code>S</code>を導入して型注釈も付け加えておきましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f&lt;T,S&gt;(x: T): (y: S)=&gt;S {
    return unit;
}
</pre></div></div>

<p>ここで、<code>(y: S)=&gt;S</code> というのは <code>S</code> をとって <code>S</code>を返す関数の型です。したがって、この関数は、 <code>T</code>をとって、<code>S</code>をとって<code>S</code>を返す関数、というように型注釈を読むことができます。<code>unit</code>の定義をこの関数のなかに展開してみたらどうなるでしょうか。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function f&lt;T,S&gt;(x: T): (y: S)=&gt;S {
    return function(y: S): S {
        return y ;
    };
}
</pre></div></div>

<p>この関数で、return文のところでは<code>x</code>と<code>y</code>というふたつの引数を参照できることがわかると思います。これはつまり <strong>２引数の関数</strong> であると考えればいいでしょう。この定義では、そのうち<code>y</code>の方をそのまま返しているというわけです。これで新たな突破口が見えてきたことだと思います。もし <code>f</code> を呼び出す側から見れば、次のようにふたつ引数をとり２番めに渡したほうの引数を返す関数のようにも見えます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>f(x)(y) = y
</pre></div></div>

<p>ここでもうひとつ別の定義に気がつくかもしれません。ふたつ引数をとって、最初の引数のほうを返すような定義もできるのではないでしょうか。この関数を<code>g</code>として定義してみます。最初の方の引数の型は <code>T</code> ですので、<code>g</code>全体は <code>S</code> ではなく <code>T</code> を返すことにも注意して型注釈を付け加えます。 </p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function g&lt;T,S&gt;(x: T): (y: S)=&gt;T {
    return function(y: S): T {
        return x;
    };
}
</pre></div></div>

<p>こんどの関数<code>g</code>は、次のように最初の方の引数を返すわけです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>g(x)(y) = x
</pre></div></div>

<p>さてここで、ある関数 <code>c</code> が実は <code>f</code> または <code>g</code> のどちらかであるとしましょう。どちらであるかはわかりません。<code>f</code> も <code>g</code> も２引数と考えますから、 <code>c</code>も同じように2引数だと考えられます。<code>c</code> に<code>x</code>と<code>y</code>を与えた式 <code>c(x)(y)</code> はどんな値を返すのでしょうか？もし <code>c</code> が <code>f</code> なら</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>c(x)(y) = x
</pre></div></div>

<p>となりますし、<code>c</code> が <code>g</code> なら</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>c(x)(y) = y
</pre></div></div>

<p>となります。これってまさに <strong>条件分岐</strong> そのものではないですか！<code>c(x)(y)</code> を見かけたら、<code>c ? x : y</code> とか <code>if(c){ x }else{ y }</code> だと思えばいいのです。つまり、<code>c</code>は<code>boolean</code>型の値であり、この<code>f</code> や <code>g</code> は <code>false</code> や <code>true</code> に相当するモノなのです！</p>

<p>こんな素晴らしい物を見つけたのに <code>f</code> や <code>g</code> なんていう名前じゃかわいそうですから、もっと良い名前を付けてあげましょう。でも<code>true</code>や<code>false</code>はJavaScriptの予約語で衝突してしまいますから、仕方ないので<code>$true</code> と <code>$false</code>と呼ぶことにします。funcion式をネストすると見づらくなるので、代わりにラムダ式を使っています。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function $true&lt;T,S&gt;(t: T): (f: S) =&gt; T {
    return f =&gt; t;
}
function $false&lt;T,S&gt;(t: T): (f: S) =&gt; S {
    return f =&gt; f;
}
</pre></div></div>

<p>もちろんこの <code>$true</code> や <code>$false</code> は普通の<code>number</code>の値なんかに対しても使えます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>var c = $false;

console.log(c(10)(20)); // c ? 10 : 20 と考える。20が出力される
</pre></div></div>

<p>なんと、<code>boolean</code>型やif文や三項演算子がもとから存在しなくても、条件分岐はできるのです。</p>

<p>この<code>$true</code>や<code>$false</code>はデータ型としても扱えますから、関数の引数として渡したり、返り値として返したりすることももちろんできます。たとえば、<code>$true</code>を<code>$false</code>に、<code>$false</code>を<code>$true</code>に入れ替えるような関数<code>not</code>は次のように定義できるのです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function not&lt;T&gt;(x: (t: (t: T) =&gt; (f: T) =&gt; T) =&gt; (f: (t: T) =&gt; (f: T) =&gt; T) =&gt; (t: T) =&gt; (f: T) =&gt; T): (t: T) =&gt; (f: T) =&gt; T {
    return x($false)($true);
}
</pre></div></div>

<p>なんだか型注釈がとんでもない長さになってしまいましたが、これは型のエイリアスを用意すれば次のように定義できるので安心してください。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>interface Bool {
    &lt;T&gt;(t: T): (f: T) =&gt; T;
}

function not(x: Bool): Bool {
    return x($false)($true);
}
</pre></div></div>

<p>この関数を使うと、以下の様な式の展開ができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>not($true) = $false
not($false) = $true
</pre></div></div>

<p>これはまさに <code>$true</code>、<code>$false</code> という値をもつようなデータ型 <code>Bool</code> を定義したことにほかなりません。これで、我々が普段使っているようなプリミティブ型も、関数さえあればまったくの無の世界から作り出せることがおわかりになったことだと思います。</p>

<h5>
<span id="練習試合" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92%E8%A9%A6%E5%90%88"><i class="fa fa-link"></i></a>練習試合</h5>

<ul>
<li>ifというキーワードがあったほうがやっぱり読みやすい、というひともいるかもしれません。そんなひとのために <code>$if(c)(x)(y)</code> と書けるような関数<code>$if</code>を定義してみましょう。</li>
<li>論理和 <code>or</code>、論理積 <code>and</code> も定義してみましょう。</li>
</ul>

<h2>
<span id="オブジェクトコンストラクタプロパティに頼るプログラミングはやめだそういうノータリンな振る舞いはもうやめ自分の頭で考え定義するべくして定義する" class="fragment"></span><a href="#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E3%81%AB%E9%A0%BC%E3%82%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E3%82%84%E3%82%81%E3%81%A0%E3%81%9D%E3%81%86%E3%81%84%E3%81%86%E3%83%8E%E3%83%BC%E3%82%BF%E3%83%AA%E3%83%B3%E3%81%AA%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%81%AF%E3%82%82%E3%81%86%E3%82%84%E3%82%81%E8%87%AA%E5%88%86%E3%81%AE%E9%A0%AD%E3%81%A7%E8%80%83%E3%81%88%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B%E3%81%B9%E3%81%8F%E3%81%97%E3%81%A6%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B"><i class="fa fa-link"></i></a>オブジェクト、コンストラクタ、プロパティに頼るプログラミングはやめだ……そういうノータリンな振る舞いはもうやめ……。自分の頭で考え、定義するべくして定義する……！</h2>

<p>真偽値をうまく定義できて、ようやく少しプログラミングらしくなってきました。これまではボトムアップ方式で、なんか作ってみた⇒できたのは〇〇だった！という感じでしたが、今度は考え方を変えて、トップダウン式に〇〇を作りたい⇒こういう関数を定義すれば実現できる！というように考えて行きたいと思います。次は、複数の値を組み合わせたデータ型を考えてみましょう。これは構造体だとかに似たもので、複数の値をまとめてひとつの値のように扱えるようにするデータ型です。これを <strong>タプル</strong> と呼ぶことにしましょう。タプルはリストとはちょっと違います。リストは可変長で要素がすべて同じ型ですが、タプルは固定長なのと引き換えにそれぞれの要素が異なる型を取ることができます。</p>

<p>一番簡単なタプルは、ふたつの何かの値を組にしたものです。これを定義することが今回の目標ですが、でもいったい何ができればタプルを定義できたことになるのでしょうか？タプルとして最低限必要な操作は次のふたつです。</p>

<ul>
<li>ふたつの値からタプルを作る操作</li>
<li>タプルからふたつの値を取り出す操作</li>
</ul>

<p>ふたつの値からタプルを作る操作は、引数をふたつとってタプルを返すような関数でいいでしょうが、タプルからふたつの値を取り出す操作はどうしましょうか？関数の返り値で、ふたつの値を返すことはできません。このようなときは、いわゆるコールバック関数を使えばいいでしょう。そのコールバック関数がふたつの値を受け取るようにすればいいのです。もっとも簡単には、タプル自体がコールバック関数を受け取る関数で、タプルにコールバック関数を渡すとそこにふたつのタプルの要素を渡してきてくれるように定義する方法があります。たとえば <code>tuple(x)(y)</code> というようにタプルを作り、ここからふたつの値を取り出してそれぞれ引数<code>a</code>と引数<code>b</code>して受け取り、関数 <code>f</code> に<code>a</code>を（つまり<code>x</code>を）渡したいとします。次のようなコードを書ける関数 <code>tuple</code> を定義したいのです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>tuple(x)(y)(a =&gt; b =&gt; f(a) )
            ^
            このaがxと同じ、bがyと同じ
</pre></div></div>

<p>この関数の型は次のようになります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function tuple&lt;T,S,U&gt;(x: T): (y: S) =&gt; (h: (a: T)=&gt;(b: S)=&gt;U) =&gt; U {
    return ????? ;
}
</pre></div></div>

<p>またもややけにいかめしい型注釈になってしまいましたが、またあとで別名を付けて読みやすく整理しましょう。<code>h: (a: T)=&gt;(b: S)=&gt;U</code> がコールバック関数の型です。つまり、<code>tuple</code> は最初の値、ふたつめの値、コールバック関数の３つの引数を与えると、最初の値とふたつめの値をコールバック関数に渡してきてくれる関数です。この関数は全部で３つ引数をとるのですから、ひとまずアロー関数式で受け取る関数を書きます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function tuple&lt;T,S,U&gt;(x: T): (y: S) =&gt; (h: (a: T)=&gt;(b: S)=&gt;U) =&gt; U {
    return y =&gt; h =&gt; ????? ;
}
</pre></div></div>

<p>これで、最初の引数 <code>x</code>、ふたつめの引数 <code>y</code> 、コールバック関数 <code>h</code> が参照できるようになりました。あとはコールバック関数<code>h</code>に <code>x</code>と<code>y</code>を渡すように書けば完成です。また、型注釈の <code>(h: (a: T)=&gt;(b: S)=&gt;U) =&gt; U</code> という部分はまさにタプルそのものの型を意味していますから、これに <code>Tuple</code> という別名を付けてあげましょう。コードは次のようになります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>interface Tuple&lt;T,S&gt; {
    &lt;U&gt;(h: (a: T)=&gt;(b: S)=&gt;U): U;    
}

function tuple&lt;T,S&gt;(x: T): (y: S) =&gt; Tuple&lt;T,S&gt; {
    return y =&gt; h =&gt; h(x)(y);
}
</pre></div></div>

<p>型注釈もこれでだいぶ読みやすくをなりました。<code>(x: T): (y: S) =&gt; Tuple&lt;S,T&gt;</code> という部分は、<code>x: T</code> と <code>y: S</code> という引数を取ると タプル <code>Tuple&lt;S,T&gt;</code> を返す、と読むことができます。</p>

<h5>
<span id="fst-と-snd" class="fragment"></span><a href="#fst-%E3%81%A8-snd"><i class="fa fa-link"></i></a>fst と snd</h5>

<p>これでタプルは完成なのですが、コールバック関数があると少々直感的にわかりづらいところがありますので、タプルからどちらか一方の値を取り出すという操作をもうすこし直感的に書ける関数 <code>fst</code> と <code>snd</code> を用意しましょう。<code>fst</code> はタプルから最初の値だけを返り値で返し、<code>snd</code> はふたつめの値だけを返り値で返します。これらの関数を使うと、次のように式変形できます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>fst( tuple(x)(y) ) = x
snd( tuple(x)(y) ) = y
</pre></div></div>

<p>これらの関数 <code>fst</code>、<code>snd</code> を定義してみましょう。<code>fst</code>はタプル <code>Tuple&lt;T,S&gt;</code> から最初の値をとりだすので、その型は<code>fst&lt;T,S&gt;(t: Tuple&lt;T,S&gt;): T</code> となります。<code>snd</code> も同様に考えます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function fst&lt;T,S&gt;(t: Tuple&lt;T,S&gt;): T {
    return ????? ;
}

function snd&lt;T,S&gt;(t: Tuple&lt;T,S&gt;): S {
    return ????? ;
}
</pre></div></div>

<p>さて、本体はどのように定義しましょうか。タプルは関数になっていて、<code>fst</code>なら２引数の関数を渡すと最初の値を返すようなコールバック関数を渡せばいいのでした。そういえば、そのような関数がすでに登場していたことを覚えていますか？実は <code>$true</code> や <code>$false</code> がまさにそのような関数なのです。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>$true(x)(y) = x
$false(x)(y) = y
</pre></div></div>

<p><code>$true</code> と <code>$false</code> を使えば、<code>fst</code> と <code>snd</code> を簡単に定義することができます！</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function fst&lt;T,S&gt;(t: Tuple&lt;T,S&gt;): T {
    return t($true) ;
}

function snd&lt;T,S&gt;(t: Tuple&lt;T,S&gt;): S {
    return t($false) ;
}
</pre></div></div>

<p>念のため、手動で計算して確かめてみましょう。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>  fst( tuple                (x)(y) ) 
= fst( (a=&gt;b=&gt;h =&gt; h(a)(b)) (x)(y) )        (tupleを展開)
= fst( (   b=&gt;h =&gt; h(x)(b))    (y) )        (xを適用)
= fst( (      h =&gt; h(x)(y))        )        (yを適用)
=      (      h =&gt; h(x)(y)) ($true)         (fstを展開)
=              $true(x)(y)                  ($trueを適用)
=      (m =&gt; n =&gt; m)(x)(y)                  ($trueを展開)
=      (     n =&gt; x)   (y)                  (xを適用)
=                 x                         (yを適用)
</pre></div></div>

<p>これで、<code>tuple(x)(y)</code> というようにして作ったタプルから <code>fst</code> を使って <code>x</code> という値が取り出せることが確認できました！</p>

<h5>
<span id="オブジェクトとしてのタプル" class="fragment"></span><a href="#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E3%82%BF%E3%83%97%E3%83%AB"><i class="fa fa-link"></i></a>『オブジェクト』としてのタプル</h5>

<p><code>tuple</code>、<code>fst</code>、<code>snd</code>じゃ抽象的すぎて実際に何のデータを扱っているのかよくわからない！というのはあります。そのようなときは、それぞれの関数に別名を定義してやればいいのです。たとえば、次のような<code>name: string</code>と<code>age: number</code>というふたつのプロパティをもったオブジェクトを表現したいとします。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>{ name: "Yuzuko", age: 16 }
</pre></div></div>

<p>このようなときは、次のようにタプルと同じような関数をそれぞれに対応した名前や型で用意してあげます。<code>user</code>は<code>tuple</code>に対応している関数ですが、<code>tuple</code>と違って<code>string</code>と<code>number</code>という組み合わせでしか渡せないように特殊化された関数です。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>interface User {
    &lt;T&gt;(t: (name: string)=&gt;(age: number)=&gt;T): T;    
}

function user(name: string): (age: number) =&gt; User {
    return age =&gt; tuple(name)(age);
}
</pre></div></div>

<p>この<code>user</code>はデータ型の「コンストラクタ」に相当します。この「コンストラクタ」を使えば、つぎのように <code>User</code> の「オブジェクト」を作ることができます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>user("Yuzuko")(16)
</pre></div></div>

<p>この「オブジェクト」からは<code>fst</code>や<code>snd</code>でもそれぞれのデータを取り出せます(もちろん<code>user("Yuzuko")(16)($true)</code>のように <code>$true</code>や<code>$false</code>を適用しても取り出せます！)が、別名でそれぞれのオブジェクトのプロパティ名に合わせた関数 <code>name</code> や <code>age</code> を用意しておけば読みやすくなります。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>function name(u: User): string {
    return fst(u);
}

function age(u: User): number {
    return snd(u);
}

name( user("Yuzuko")(16) )    // "Yuzuko"
age( user("Yukari")(16) )     // 16
</pre></div></div>

<p>JavaScriptで普通に書けば</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>new User("Yuzuko", 16).name   // "Yuzuko"
new User("Yukari", 16).age    // 16
</pre></div></div>

<p>のようになるでしょうが、<code>new</code> が要らなくなってただの関数になったり、ドット演算子によるプロパティアクセスもただの関数適用になっただけで、読みやすさとしては大差ないように思います。もちろんこの辺りは数値型や文字列型が定義できてからの話になりますが。</p>

<p>このタプルは２要素ですが、タプルとタプルを組み合わせれば、もっと要素の数が多いデータ型を表現することができます。<code>Tuple&lt;T,Tuple&lt;S,U&gt;&gt;</code>は２要素のタプルが入れ子になったものですが、これを３要素のタプルとして扱うこともできるでしょう。もしくは先ほどの定義をさらに拡張して、３要素のタプルを定義するのもいいでしょう。</p>

<p>これでなんと、関数だけで「オブジェクト」に相当するものも定義できてしまいました！関数最高や！オブジェクトなんて最初からいらんかったんや！</p>

<h5>
<span id="練習試合-1" class="fragment"></span><a href="#%E7%B7%B4%E7%BF%92%E8%A9%A6%E5%90%88-1"><i class="fa fa-link"></i></a>練習試合</h5>

<ul>
<li>3要素のタプル型 <code>Tuple3</code> を定義してみましょう。</li>
</ul>

<h2>
<span id="世間というものはとどのつまり肝心なことは何一つ答えたりしない" class="fragment"></span><a href="#%E4%B8%96%E9%96%93%E3%81%A8%E3%81%84%E3%81%86%E3%82%82%E3%81%AE%E3%81%AF%E3%81%A8%E3%81%A9%E3%81%AE%E3%81%A4%E3%81%BE%E3%82%8A%E8%82%9D%E5%BF%83%E3%81%AA%E3%81%93%E3%81%A8%E3%81%AF%E4%BD%95%E4%B8%80%E3%81%A4%E7%AD%94%E3%81%88%E3%81%9F%E3%82%8A%E3%81%97%E3%81%AA%E3%81%84"><i class="fa fa-link"></i></a>　世間というものは、とどのつまり肝心なことは何一つ答えたりしない……！</h2>

<p>真偽値やタプルが定義できたことですし、そろそろ数の計算をしてみたいとは思うところではないでしょうか。ここで残念なお知らせなのですが、 <strong>筆者がそろそろ書くのに疲れてきた</strong> ので、数やリストなどのもっと複雑な型や、繰り返しなどの制御構造をどうやって定義するのか知りたいというかたが万が一いらっしゃいましたら、申し訳ありませんが以下の参考文献とソースコードを御覧になるか、筆者の気力回復を気長に待っていただくようお願いします。今回自分が実装したコードは、以下のgithubリポジトリで参照できます。</p>

<ul>
<li><a href="https://github.com/kontan/picolambda" rel="nofollow noopener" target="_blank">kontan/picolambda</a></li>
</ul>

<p>今回自分が実装したライブラリのコードでは、自然数の定義とともに加算、減算、乗算といった基本的な演算ができるようになっていますし（除算はめんどくさくて実装してないです）、計算結果を文字列として表示する機能も中途半端ながら一応実装しています。これらのコードは主に<a href="http://en.wikipedia.org/wiki/Church_encoding" rel="nofollow noopener" target="_blank">Church encoding - Wikipedia</a>で紹介されている"Church numerals"を参考に書きましたので、このソースコードの理解をしたければそちらを参考にするのも良いと思います。ほかにもEither(共用体みたいなもの)、二分木のような再帰的な型をもつデータ型も定義しています。</p>

<h4>
<span id="入出力部分の言い訳" class="fragment"></span><a href="#%E5%85%A5%E5%87%BA%E5%8A%9B%E9%83%A8%E5%88%86%E3%81%AE%E8%A8%80%E3%81%84%E8%A8%B3"><i class="fa fa-link"></i></a>入出力部分の言い訳</h4>

<p>関数で定義されたデータ型で入力し、関数で定義されたデータ型で出力するだけなら他にはなにも要らないのですが、このシステムには「リテラル」に相当するものがないので、<code>$true</code> や <code>$false</code> のような単純な値以外のデータを記述するのは少々面倒ですし、関数で定義されたデータ型はデバッガで覗こうとしてもとても人間には読めるものではありません(なにしろ関数ですから)。しかたないので、最低限の機能だけ使って、文字列オブジェクトと関数で定義されたデータ型を相互に変換するコードを加えました。</p>

<p>以下の関数 <code>interactive</code> は、関数<code>f</code>と文字列<code>x</code>を引数に取り、<code>x</code>を関数で定義された文字列のデータ型<code>Str</code>に変換してから、<code>f</code>に適用し、結果を再びJavaScriptの文字列にデコーディングしてコンソールに出力します。この <code>interactive</code> が関数だけで定義されたソースコードを実行するための環境で、<code>f</code>がアプリケーションのコードに相当します。この関数が低レベルな入出力をすべて担当しているので、<code>interactive</code>と入力の文字列以外のすべてのソースコードは関数のみでできています。ちなみに、<code>church</code>と<code>unchurch</code>という関数はそれぞれ<code>number</code>を関数だけで定義された自然数型<code>Natural</code>に、<code>Natural</code>を<code>number</code>に変換する関数です。これであとは純粋に関数だけで構成されたこの世界の構築を進めれば、どんな計算も関数だけで可能になるはずです。</p>

<div class="code-frame" data-lang="js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">interactive</span><span class="p">(</span><span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">s</span><span class="o">:</span> <span class="nx">Str</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">Str</span><span class="p">,</span> <span class="nx">x</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">church</span><span class="p">(</span><span class="nx">n</span><span class="o">:</span> <span class="nx">number</span><span class="p">)</span><span class="o">:</span> <span class="nx">Natural</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">?</span> <span class="nx">church</span> <span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="o">:</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">unchurch</span><span class="p">(</span><span class="nx">n</span><span class="o">:</span> <span class="nx">Natural</span><span class="p">)</span><span class="o">:</span> <span class="nx">number</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">(</span><span class="nx">x</span><span class="o">=&gt;</span><span class="nx">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
            <span class="nx">decode</span><span class="p">(</span><span class="s2">""</span><span class="p">)(</span><span class="nx">x</span><span class="o">=&gt;</span><span class="nx">y</span><span class="o">=&gt;</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)(</span><span class="nx">n</span><span class="o">=&gt;</span><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">unchurch</span><span class="p">(</span><span class="nx">n</span><span class="p">)))</span>
        <span class="p">(</span><span class="nx">f</span><span class="p">(</span>   
            <span class="nx">encode</span><span class="p">(</span><span class="nx">i</span><span class="o">=&gt;</span><span class="nx">church</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">unchurch</span><span class="p">(</span><span class="nx">i</span><span class="p">))))(</span><span class="nx">church</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span>
        <span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div></div>

<h5>
<span id="もうちょっと具体的なアプリケーション" class="fragment"></span><a href="#%E3%82%82%E3%81%86%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%85%B7%E4%BD%93%E7%9A%84%E3%81%AA%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3"><i class="fa fa-link"></i></a>もうちょっと具体的なアプリケーション</h5>

<p>たとえば、アルファベットを一文字づつずらして暗号化する<a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%BC%E3%82%B6%E3%83%BC%E6%9A%97%E5%8F%B7" rel="nofollow noopener" target="_blank">シーザー暗号</a>を文字列に対して適用するコードは次のようになります（このコードの詳しい説明は省きます）。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>interactive(x=&gt;concat6 
    (x)                     // plain text
    (char(_0)(_3)(_2))      // " "
    (char(_0)(_6)(_1))      // "="
    (char(_0)(_6)(_2))      // "&gt;"
    (char(_0)(_3)(_2))      // " "
    (map(succ)(x))          // encrypted text
, "Hello,World");
</pre></div></div>

<p>これを実行すると、標準出力に次のように出力されます。</p>

<div class="code-frame" data-lang="text"><div class="highlight"><pre><span></span>Hello,World =&gt; Ifmmp-Xpsme 
</pre></div></div>

<h2>
<span id="参考文献" class="fragment"></span><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><i class="fa fa-link"></i></a>参考文献</h2>

<p>参考になりそうな記事を幾つか挙げておきます。</p>

<ul>
<li><a href="http://qiita.com/fumieval/items/e3907c36435ef040e146" id="reference-73c7eed440b734def6ca">代数的データ型を関数型(-&gt;)のみで表現する</a></li>
<li><a href="http://legacy.e.tir.jp/wiliki?%cb%dd%cc%f5%3a%a5%d7%a5%ed%a5%b0%a5%e9%a5%df%a5%f3%a5%b0%b8%c0%b8%ecLazy_K" rel="nofollow noopener" target="_blank">翻訳:プログラミング言語Lazy_K</a></li>
<li><a href="http://ja.wikipedia.org/wiki/SKI%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E8%A8%88%E7%AE%97" rel="nofollow noopener" target="_blank">SKIコンビネータ計算</a></li>
<li><a href="http://ja.wikipedia.org/wiki/%E8%87%AA%E5%B7%B1%E8%A8%80%E5%8F%8A%E3%81%AE%E3%83%91%E3%83%A9%E3%83%89%E3%83%83%E3%82%AF%E3%82%B9" rel="nofollow noopener" target="_blank">自己言及のパラドックス</a></li>
<li><a href="http://ja.wikibooks.org/wiki/Haskell/Denotational_semantics#.E3.83.9C.E3.83.88.E3.83.A0.E3.81.A8.E9.83.A8.E5.88.86.E9.96.A2.E6.95.B0" rel="nofollow noopener" target="_blank">Haskell/Denotational semantics/ボトムと部分関数</a></li>
<li><a href="http://dic.nicovideo.jp/a/%E3%81%9D%E3%81%86%E3%81%AA%E3%82%93%E3%81%A0%E3%80%81%E3%81%99%E3%81%94%E3%81%84%E3%81%AD!" rel="nofollow noopener" target="_blank">そうなんだ、すごいね!</a></li>
<li><a href="http://en.wikipedia.org/wiki/Church_encoding" rel="nofollow noopener" target="_blank">Church encoding - Wikipedia</a></li>
<li><a href="http://ja.wikipedia.org/wiki/%E3%83%9A%E3%82%A2%E3%83%8E%E3%81%AE%E5%85%AC%E7%90%86" rel="nofollow noopener" target="_blank">ペアノの公理 - Wikipedia</a></li>
<li><a href="http://777news.biz/n/2012/11/15/17196" rel="nofollow noopener" target="_blank">何度も何度も這い上がる賭博黙示録カイジの名言セリフ！</a></li>
<li><a href="http://www.nicovideo.jp/watch/sm15322806" rel="nofollow noopener" target="_blank">一条が金庫の自慢話をするときに流れている曲</a></li>
<li><a href="http://www.yuyushiki.net/" rel="nofollow noopener" target="_blank">ゆゆ式</a></li>
</ul>

<h4>
<span id="筆者用メモ" class="fragment"></span><a href="#%E7%AD%86%E8%80%85%E7%94%A8%E3%83%A1%E3%83%A2"><i class="fa fa-link"></i></a>筆者用メモ</h4>

<ul>
<li><a href="https://karczmarczuk.users.greyc.fr/Essays/church.html" rel="nofollow noopener" target="_blank">Church numerals: a tutorial</a></li>
<li><a href="http://stackoverflow.com/questions/8963376/why-dont-type-synonyms-permit-recursion-in-haskell" rel="nofollow noopener" target="_blank">Why don't type synonyms permit recursion in Haskell?</a></li>
</ul>
</div>
	</td>
</tr>
</table>
<br />
	</body>
</html>
